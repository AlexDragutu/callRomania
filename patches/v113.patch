Index: CSipSimple/.classpath
===================================================================
--- CSipSimple/.classpath	(revision 2470)
+++ CSipSimple/.classpath	(working copy)
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
Index: CSipSimple/.externalToolBuilders/com.csipsimple.android.AddSvnRevisionToVersion.launch
===================================================================
--- CSipSimple/.externalToolBuilders/com.csipsimple.android.AddSvnRevisionToVersion.launch	(revision 2470)
+++ CSipSimple/.externalToolBuilders/com.csipsimple.android.AddSvnRevisionToVersion.launch	(working copy)
@@ -5,7 +5,7 @@
 <booleanAttribute key="org.eclipse.debug.core.ATTR_REFRESH_RECURSIVE" value="false"/>
 <stringAttribute key="org.eclipse.debug.core.ATTR_REFRESH_SCOPE" value="${project}"/>
 <listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS">
-<listEntry value="/CSipSimple"/>
+<listEntry value="/callRomania"/>
 </listAttribute>
 <listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES">
 <listEntry value="4"/>
@@ -15,7 +15,7 @@
 <booleanAttribute key="org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND" value="false"/>
 <stringAttribute key="org.eclipse.jdt.launching.CLASSPATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
 <booleanAttribute key="org.eclipse.jdt.launching.DEFAULT_CLASSPATH" value="true"/>
-<stringAttribute key="org.eclipse.jdt.launching.PROJECT_ATTR" value="CSipSimple"/>
+<stringAttribute key="org.eclipse.jdt.launching.PROJECT_ATTR" value="callRomania"/>
 <booleanAttribute key="org.eclipse.ui.externaltools.ATTR_BUILDER_ENABLED" value="false"/>
 <stringAttribute key="org.eclipse.ui.externaltools.ATTR_LOCATION" value="${workspace_loc:/CSipSimple/svn-revision.build.xml}"/>
 <stringAttribute key="org.eclipse.ui.externaltools.ATTR_RUN_BUILD_KINDS" value="full,incremental,"/>
Index: CSipSimple/AndroidManifest.xml
===================================================================
--- CSipSimple/AndroidManifest.xml	(revision 2470)
+++ CSipSimple/AndroidManifest.xml	(working copy)
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.csipsimple"
+    package="ro.callromania"
     android:installLocation="auto"
-    android:versionCode="2459"
-    android:versionName="1.02.03" >
+    android:versionCode="113"
+    android:versionName="1.1.3" >
 
     <supports-screens
         android:anyDensity="true"
@@ -13,7 +13,7 @@
         android:xlargeScreens="true" />
 
     <uses-sdk
-        android:minSdkVersion="4"
+        android:minSdkVersion="9"
         android:targetSdkVersion="16" />
 
     <uses-permission android:name="android.permission.INTERNET" />
@@ -28,6 +28,7 @@
     <uses-permission android:name="android.permission.READ_CONTACTS" />
     <uses-permission android:name="android.permission.WRITE_CONTACTS" />
     <uses-permission android:name="android.permission.CALL_PHONE" />
+    <uses-permission android:name="com.android.vending.BILLING" />
     <!--
     <uses-permission android:name="android.permission.CALL_PRIVILEGED" /> 
     was useless anyway as only granted to system app and
@@ -46,6 +47,12 @@
     <uses-permission android:name="android.permission.BROADCAST_STICKY" />
     <uses-permission android:name="android.permission.READ_PROFILE" />
     <uses-permission android:name="android.permission.WRITE_CALL_LOG" />
+    
+    <uses-permission android:name="com.google.android.c2dm.permission.RECEIVE" />
+    <uses-permission android:name="android.permission.GET_ACCOUNTS" />
+    <uses-permission android:name="ro.callromania.permission.C2D_MESSAGE" />
+    
+    
     <!--
     Not taken into account?
     Regarding Diane's comment this was never implemented 
@@ -105,7 +112,7 @@
         android:allowBackup="true"
         android:backupAgent="com.csipsimple.backup.SipBackupAgent"
         android:hardwareAccelerated="true"
-        android:icon="@drawable/ic_launcher_nightly"
+        android:icon="@drawable/ic_wizard_callromania"
         android:label="@string/app_name" >
         <meta-data
             android:name="app_type"
@@ -113,9 +120,27 @@
         <meta-data
             android:name="app_channel"
             android:value="trunk" />
+        
+        <!-- 
         <meta-data
             android:name="com.google.android.backup.api_key"
             android:value="AEdPqrEAAAAIL5x8Klvg-Y8nV4j4PNSy2JH6yQZ49yKbrqKJAw" />
+        -->
+         
+        <meta-data 
+            android:name="com.google.android.gms.version"
+        	android:value="@integer/google_play_services_version" />
+        
+        <receiver
+            android:name="ro.callromania.util.GcmBroadcastReceiver"
+            android:permission="com.google.android.c2dm.permission.SEND" >
+            <intent-filter>
+                <action android:name="com.google.android.c2dm.intent.RECEIVE" />
+                <category android:name="com.example.gcm" />
+            </intent-filter>
+        </receiver>
+        <service android:name="ro.callromania.util.GcmIntentService" />
+        
 
         <!--
         Samsung multiview support
@@ -332,7 +357,7 @@
         <activity
             android:name="com.csipsimple.wizards.BasePrefsWizard"
             android:configChanges="orientation"
-            android:label="@string/edit"
+            android:label="@string/w_callromania_title"
             android:theme="@style/DarkTheme" />
 
         <!-- Call management -->
@@ -462,7 +487,7 @@
 
         <receiver android:name="com.csipsimple.service.HeadsetButtonReceiver" />
 
-        <!-- Widget -->
+        <!-- Widget
         <receiver
             android:name="com.csipsimple.widgets.AccountWidgetProvider"
             android:icon="@drawable/appwidget_preview"
@@ -506,7 +531,9 @@
                 <action android:name="android.appwidget.action.APPWIDGET_CONFIGURE" />
             </intent-filter>
         </activity>
-
+        
+        -->
+        
         <!-- Messages -->
         <activity
             android:name="com.csipsimple.ui.messages.MessageActivity"
@@ -569,6 +596,26 @@
         <activity
             android:name="com.csipsimple.wizards.impl.MondotalkCreate"
             android:theme="@style/DarkTheme" />
+        
+        <activity
+            android:name="com.csipsimple.wizards.impl.CallRomaniaCreate"
+            android:theme="@style/DarkTheme"
+            android:windowSoftInputMode="stateHidden|adjustPan" />
+        
+        <!-- //MOD 1.0.4 -->
+        <activity
+		    android:name="com.csipsimple.wizards.CallRomaniaSMS"
+		    android:theme="@style/DarkTheme"
+		    android:windowSoftInputMode="adjustResize|stateHidden"
+		    android:label="@string/new_message"
+		    android:icon="@drawable/ic_callromania_mail" />
+		
+		<!-- //MOD 1.0.5 -->
+        <activity
+		    android:name="com.csipsimple.wizards.CallRomaniaCredit"
+		    android:theme="@style/DarkTheme"
+		    android:windowSoftInputMode="adjustResize|stateHidden"
+		    android:label="@string/w_callromania_buycredit" />
     </application>
 
-</manifest>
\ No newline at end of file
+</manifest>
Index: CSipSimple/ant.properties
===================================================================
--- CSipSimple/ant.properties	(revision 0)
+++ CSipSimple/ant.properties	(working copy)
@@ -0,0 +1,8 @@
+key.store=../callromania.keystore
+key.alias=callRomania
+key.store.password=123456
+key.alias.password=123456
+key.store=../callromania.keystore
+key.alias=callRomania
+key.store.password=123456
+key.alias.password=123456
Index: CSipSimple/build.xml
===================================================================
--- CSipSimple/build.xml	(revision 2470)
+++ CSipSimple/build.xml	(working copy)
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<project name="CSipSimple" default="help">
+<project name="callRomania" default="help">
 
     <!-- The local.properties file is created and updated by the 'android' tool.
          It contains the path to the SDK. It should *NOT* be checked into
Index: CSipSimple/project.properties
===================================================================
--- CSipSimple/project.properties	(revision 2470)
+++ CSipSimple/project.properties	(working copy)
@@ -12,3 +12,4 @@
 # Project target.
 target=android-19
 android.library.reference.1=../ActionBarSherlock
+android.library.reference.2=../../google-play-services_lib
Index: CSipSimple/res/drawable-hdpi/evolio.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: CSipSimple/res/drawable-hdpi/evolio.png
===================================================================
--- CSipSimple/res/drawable-hdpi/evolio.png	(revision 0)
+++ CSipSimple/res/drawable-hdpi/evolio.png	(working copy)

Property changes on: CSipSimple/res/drawable-hdpi/evolio.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: CSipSimple/res/drawable-hdpi/ic_callromania_mail.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: CSipSimple/res/drawable-hdpi/ic_callromania_mail.png
===================================================================
--- CSipSimple/res/drawable-hdpi/ic_callromania_mail.png	(revision 0)
+++ CSipSimple/res/drawable-hdpi/ic_callromania_mail.png	(working copy)

Property changes on: CSipSimple/res/drawable-hdpi/ic_callromania_mail.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: CSipSimple/res/drawable-hdpi/ic_wizard_callromania.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: CSipSimple/res/drawable-hdpi/ic_wizard_callromania_acc.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: CSipSimple/res/drawable-hdpi/ic_wizard_callromania_acc.png
===================================================================
--- CSipSimple/res/drawable-hdpi/ic_wizard_callromania_acc.png	(revision 0)
+++ CSipSimple/res/drawable-hdpi/ic_wizard_callromania_acc.png	(working copy)

Property changes on: CSipSimple/res/drawable-hdpi/ic_wizard_callromania_acc.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: CSipSimple/res/drawable-mdpi/ic_wizard_callromania.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: CSipSimple/res/drawable-mdpi/ic_wizard_callromania_acc.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: CSipSimple/res/drawable-mdpi/ic_wizard_callromania_acc.png
===================================================================
--- CSipSimple/res/drawable-mdpi/ic_wizard_callromania_acc.png	(revision 0)
+++ CSipSimple/res/drawable-mdpi/ic_wizard_callromania_acc.png	(working copy)

Property changes on: CSipSimple/res/drawable-mdpi/ic_wizard_callromania_acc.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: CSipSimple/res/drawable-xhdpi/ic_wizard_callromania.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: CSipSimple/res/drawable-xxhdpi/ic_wizard_callromania.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: CSipSimple/res/drawable-xxhdpi/ic_wizard_callromania.png
===================================================================
--- CSipSimple/res/drawable-xxhdpi/ic_wizard_callromania.png	(revision 0)
+++ CSipSimple/res/drawable-xxhdpi/ic_wizard_callromania.png	(working copy)

Property changes on: CSipSimple/res/drawable-xxhdpi/ic_wizard_callromania.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: CSipSimple/res/drawable-xxhdpi/ic_wizard_callromania_acc.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: CSipSimple/res/drawable-xxhdpi/ic_wizard_callromania_acc.png
===================================================================
--- CSipSimple/res/drawable-xxhdpi/ic_wizard_callromania_acc.png	(revision 0)
+++ CSipSimple/res/drawable-xxhdpi/ic_wizard_callromania_acc.png	(working copy)

Property changes on: CSipSimple/res/drawable-xxhdpi/ic_wizard_callromania_acc.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: CSipSimple/res/drawable-xxxhdpi/ic_wizard_callromania.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: CSipSimple/res/drawable-xxxhdpi/ic_wizard_callromania.png
===================================================================
--- CSipSimple/res/drawable-xxxhdpi/ic_wizard_callromania.png	(revision 0)
+++ CSipSimple/res/drawable-xxxhdpi/ic_wizard_callromania.png	(working copy)

Property changes on: CSipSimple/res/drawable-xxxhdpi/ic_wizard_callromania.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: CSipSimple/res/drawable-xxxhdpi/ic_wizard_callromania.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: CSipSimple/res/drawable-xxxhdpi/ic_wizard_callromania.png
===================================================================
--- CSipSimple/res/drawable-xxxhdpi/ic_wizard_callromania.png	(revision 0)
+++ CSipSimple/res/drawable-xxxhdpi/ic_wizard_callromania.png	(working copy)

Property changes on: CSipSimple/res/drawable-xxxhdpi/ic_wizard_callromania.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: CSipSimple/res/layout/dialpad_additional_buttons.xml
===================================================================
--- CSipSimple/res/layout/dialpad_additional_buttons.xml	(revision 2470)
+++ CSipSimple/res/layout/dialpad_additional_buttons.xml	(working copy)
@@ -17,7 +17,7 @@
 
 <!-- Horizontal row of buttons (Voicemail + DialButton + Delete.) -->
 <merge xmlns:android="http://schemas.android.com/apk/res/android" >
-
+	<!-- //MOD 1.0.4
     <ImageButton
         android:id="@+id/dialVideoButton"
         android:layout_width="0px"
@@ -28,6 +28,18 @@
         android:contentDescription="@string/description_dial_video_button"
         android:src="@drawable/ic_prefs_media_video"
         android:state_enabled="false" />
+    -->
+    
+    <ImageButton
+        android:id="@+id/composeSMSButton"
+        android:layout_width="0px"
+        android:layout_height="match_parent"
+        android:layout_gravity="center_vertical"
+        android:layout_weight="0.30"
+        android:background="?attr/actionBarItemBackground"
+        android:contentDescription="@string/compose_title"
+        android:src="@drawable/ic_callromania_mail"
+        android:state_enabled="true" />
 
     <View
         android:id="@+id/divider1"
Index: CSipSimple/res/layout/help.xml
===================================================================
--- CSipSimple/res/layout/help.xml	(revision 2470)
+++ CSipSimple/res/layout/help.xml	(working copy)
@@ -30,6 +30,7 @@
         android:layout_height="wrap_content"
         android:gravity="center"
         android:padding="6dip"
+        android:autoLink="web"
         android:textAppearance="?android:attr/textAppearanceSmall" />
 
     <ListView
Index: CSipSimple/res/layout/w_callromania_create.xml
===================================================================
--- CSipSimple/res/layout/w_callromania_create.xml	(revision 0)
+++ CSipSimple/res/layout/w_callromania_create.xml	(working copy)
@@ -0,0 +1,103 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- //MOD 1.0.4 -->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:id="@+id/callromania_mview" >
+
+    <ScrollView
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_above="@+id/validation_bar" >
+
+        <RelativeLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content" >
+
+            <EditText
+                android:id="@+id/cr_first_name"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:hint="@string/first_name"
+                android:nextFocusForward="@+id/cr_last_name"
+                android:singleLine="true" />
+
+            <EditText
+                android:id="@+id/cr_last_name"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:layout_below="@+id/cr_first_name"
+                android:hint="@string/last_name"
+                android:singleLine="true" />
+
+            <EditText
+                android:id="@+id/cr_email"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:layout_below="@+id/cr_last_name"
+                android:hint="@string/email_address"
+                android:inputType="textEmailAddress"
+                android:singleLine="true" />
+            
+            <EditText
+                android:id="@+id/cr_pass"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:layout_below="@+id/cr_email"
+                android:hint="@string/w_basic_password"
+                android:inputType="textPassword"
+                android:singleLine="true" />
+            <EditText
+                android:id="@+id/cr_pass2"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:layout_below="@+id/cr_pass"
+                android:hint="@string/w_callromania_password2"
+                android:inputType="textPassword"
+                android:singleLine="true" />
+
+            <EditText
+                android:id="@+id/cr_phone"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+                android:layout_below="@+id/cr_pass2"
+                android:hint="@string/w_common_phone_number"
+                android:inputType="phone"
+                android:singleLine="true"
+                android:enabled="false" />
+            <Button 
+                android:id="@+id/cr_findnumber"
+                android:layout_height="wrap_content"
+                android:layout_width="wrap_content"
+                android:layout_below="@+id/cr_phone"
+                android:text="@string/w_callromania_findnumber"/>
+           
+        </RelativeLayout>
+    </ScrollView>
+
+    <LinearLayout
+        android:id="@+id/cr_validation_bar"
+        style="@style/ButtonBar"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_alignParentBottom="true"
+        android:orientation="horizontal" >
+
+        <Button
+            android:id="@+id/cr_cancel_bt"
+            style="@style/ButtonBarButton"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_weight="0.5"
+            android:text="@string/cancel" />
+
+        <Button
+            android:id="@+id/cr_save_bt"
+            style="@style/ButtonBarButton"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_weight="0.5"
+            android:text="@string/save" />
+    </LinearLayout>
+
+</RelativeLayout>
Index: CSipSimple/res/layout/w_callromania_credit.xml
===================================================================
--- CSipSimple/res/layout/w_callromania_credit.xml	(revision 0)
+++ CSipSimple/res/layout/w_callromania_credit.xml	(working copy)
@@ -0,0 +1,73 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- //MOD 1.0.5 -->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:id="@+id/cr_credit_mview" >
+	
+	<LinearLayout
+		android:id="@+id/cr_credit_validation_bar"
+		android:layout_width="fill_parent"
+		android:layout_height="wrap_content"
+		android:layout_marginTop="20dp"
+		android:layout_marginLeft="5dp"
+		android:layout_marginRight="5dp"
+		android:layout_marginBottom="1dp"
+		android:layout_alignParentTop="true"
+		android:orientation="horizontal" >
+		
+		<Button
+			android:id="@+id/cr_credit_bt"
+			android:layout_width="fill_parent"
+			android:layout_height="wrap_content"
+			android:enabled="false"	/>
+			
+	</LinearLayout>
+
+    <ScrollView
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+		android:fadeScrollbars="false"
+		android:scrollbarAlwaysDrawVerticalTrack="true"
+        android:layout_below="@+id/cr_credit_validation_bar" >
+
+        <LinearLayout
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+			android:orientation="vertical" >
+			
+			<TextView
+				android:id="@+id/cr_credit_instructions"
+				android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+				android:textColor="@android:color/white"
+				android:textAppearance="?android:attr/textAppearanceLarge"
+				android:layout_marginTop="10dp"
+				android:layout_marginLeft="10dp"
+				android:layout_marginRight="10dp"
+				android:layout_marginBottom="20dp"
+				android:textSize="18sp" />
+			
+			<TextView
+				android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
+				android:textColor="@android:color/white"
+				android:textAppearance="?android:attr/textAppearanceLarge"
+				android:layout_marginTop="10dp"
+				android:layout_marginLeft="10dp"
+				android:layout_marginRight="10dp"
+				android:layout_marginBottom="10dp"
+				android:text="@string/w_callromania_info2"
+				android:textSize="14sp" />
+			
+			<Button
+				android:id="@+id/cr_credit_cancel_bt"
+				android:layout_width="fill_parent"
+				android:layout_height="wrap_content"
+				android:layout_marginLeft="5dp"
+				android:layout_marginRight="5dp"
+				android:text="@string/cancel" />
+           
+        </LinearLayout>
+    </ScrollView>
+</RelativeLayout>
Index: CSipSimple/res/layout/w_callromania_sms.xml
===================================================================
--- CSipSimple/res/layout/w_callromania_sms.xml	(revision 0)
+++ CSipSimple/res/layout/w_callromania_sms.xml	(working copy)
@@ -0,0 +1,110 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- //MOD 1.0.4 -->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    android:id="@+id/callromania_sms_compose" >
+    
+    <RelativeLayout
+        android:id="@+id/sms_bottom_panel"
+        style="@style/ButtonBar"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_alignParentBottom="true"
+        android:layout_marginTop="10dip" >       
+
+        <EditText
+            android:id="@+id/sms_text_editor"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_alignParentLeft="true"
+            android:layout_toLeftOf="@+id/sms_send_button"
+            android:hint="@string/type_to_compose_text_enter_to_send"
+            android:imeOptions="actionSend|flagNoEnterAction"
+            android:inputType="textShortMessage|textAutoCorrect|textCapSentences|textMultiLine"
+            android:maxLength="160"
+            android:maxLines="3"
+            android:nextFocusRight="@+id/sms_send_button" />
+
+        <Button
+            android:id="@+id/sms_send_button"
+            style="?android:attr/buttonStyle"
+            android:layout_alignParentRight="true"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="5dip"
+            android:gravity="center"
+            android:nextFocusLeft="@+id/sms_text_editor"
+            android:text="@string/send" />
+    </RelativeLayout>
+
+    <ImageView
+        android:layout_width="fill_parent"
+        android:layout_height="3dip"
+        android:layout_above="@id/sms_bottom_panel"
+        android:background="@android:drawable/divider_horizontal_dark"
+        android:contentDescription="@string/empty_description" />
+    
+    <LinearLayout
+        android:id="@+id/sms_header"
+        android:visibility="gone"
+	    android:layout_alignParentTop="true"
+        android:layout_centerHorizontal="true"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical"
+        android:gravity="center" >
+        
+        <TextView
+	        android:id="@+id/sms_credit_text"
+	        android:layout_width="wrap_content"
+	        android:layout_height="wrap_content"
+	        android:gravity="center"
+	        android:paddingLeft="12dip"
+	        android:paddingRight="12dip"
+	        android:textAppearance="?android:attr/textAppearanceLarge"
+	        android:textColor="@android:color/white" />
+	    
+	    <ImageView
+	        android:layout_width="fill_parent"
+	        android:layout_height="3dip"
+	        android:layout_marginTop="10dip"
+	        android:layout_marginBottom="10dip"
+	        android:background="@android:drawable/divider_horizontal_dark"
+	        android:contentDescription="@string/empty_description" />
+	    
+    </LinearLayout>
+    
+    <ScrollView
+        android:id="@+id/sms_body"
+        android:layout_above="@id/sms_bottom_panel"
+        android:layout_below="@id/sms_header"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="10dip" >
+	    
+        <RelativeLayout
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content" >
+	            
+	        <LinearLayout
+	             android:id="@+id/sms_recipients_list"
+	             android:layout_alignParentTop="true"
+	             android:layout_width="fill_parent"
+	             android:layout_height="wrap_content"
+	             android:orientation="vertical" /> 
+			
+	        <Button 
+	            android:id="@+id/sms_add_recipient"
+	            android:text="@string/w_callromania_add"
+	            android:layout_below="@id/sms_recipients_list"
+	            android:layout_centerHorizontal="true"
+	            android:layout_width="wrap_content"
+	            android:layout_height="wrap_content" />
+	             
+		</RelativeLayout>
+                    
+    </ScrollView>
+
+</RelativeLayout>
Index: CSipSimple/res/layout/wizard_create_or_edit.xml
===================================================================
--- CSipSimple/res/layout/wizard_create_or_edit.xml	(revision 2470)
+++ CSipSimple/res/layout/wizard_create_or_edit.xml	(working copy)
@@ -25,12 +25,12 @@
     android:orientation="vertical" >
 
     <Button
-        android:id="@+id/button0"
-        android:layout_width="wrap_content"
+        android:id="@+id/button1"
+        android:layout_width="150dip"
         android:layout_height="wrap_content"
         android:layout_above="@+id/text"
         android:layout_centerHorizontal="true"
-        android:text="@string/create_account" />
+        android:text="@string/already_have_account" />
 
     <View
         android:id="@+id/text"
@@ -38,14 +38,36 @@
         android:layout_height="0dip"
         android:layout_centerHorizontal="true"
         android:layout_centerVertical="true"
-        android:layout_margin="15dip" />
+        android:layout_margin="10dip" />
 
     <Button
-        android:id="@+id/button1"
-        android:layout_width="wrap_content"
+        android:id="@+id/button0"
+        android:layout_width="150dip"
         android:layout_height="wrap_content"
         android:layout_below="@+id/text"
         android:layout_centerHorizontal="true"
-        android:text="@string/already_have_account" />
+        android:text="@string/create_account" />
+    
+    <TextView
+        android:id="@+id/text_evolio"
+        android:visibility="gone"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:textSize="16sp"
+        android:paddingTop="35dp"
+        android:layout_marginTop="35dp"
+        android:paddingBottom="5dp"
+        android:layout_marginBottom="5dp"
+        android:text="@string/w_callromania_evolio"
+        android:layout_centerHorizontal="true"
+        android:layout_below="@+id/button0" />
+    
+    <ImageView
+        android:visibility="gone"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:src="@drawable/evolio"
+        android:layout_centerHorizontal="true"
+        android:layout_below="@+id/text_evolio" />
 
 </RelativeLayout>
\ No newline at end of file
Index: CSipSimple/res/layout/wizard_prefs_base.xml
===================================================================
--- CSipSimple/res/layout/wizard_prefs_base.xml	(revision 2470)
+++ CSipSimple/res/layout/wizard_prefs_base.xml	(working copy)
@@ -34,7 +34,7 @@
         <LinearLayout
             android:id="@+id/custom_wizard_row"
             android:layout_width="fill_parent"
-            android:layout_height="?android:attr/listPreferredItemHeight"
+            android:layout_height="wrap_content"
             android:background="?attr/actionBarItemBackground"
             android:orientation="vertical"
             android:visibility="gone" >
@@ -42,15 +42,43 @@
             <TextView
                 android:id="@+id/custom_wizard_text"
                 android:layout_width="fill_parent"
-                android:layout_height="0dip"
+                android:layout_height="wrap_content"
+                android:layout_marginLeft="3dip"
+                android:layout_marginBottom="3dip"
+                android:layout_marginRight="3dip"
+                android:layout_marginTop="3dip"
+                android:gravity="left"
+                android:paddingLeft="12dip"
+                android:paddingRight="12dip"
+                android:textAppearance="?android:attr/textAppearanceLarge"
+                android:textColor="@android:color/white" />
+            
+            <!-- //MOD 1.0.4
+            <TextView
+                android:id="@+id/custom_wizard_number"
+                android:layout_width="fill_parent"
+                android:layout_height="wrap_content"
                 android:layout_weight="1"
                 android:gravity="center"
                 android:paddingLeft="12dip"
                 android:paddingRight="12dip"
                 android:textAppearance="?android:attr/textAppearanceLarge"
-                android:textColor="@android:color/white" />
+                android:textColor="@android:color/white" />                
+             -->
 
-            <ImageView
+		<Button
+		android:id="@+id/callromania_credit_sms"
+		android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+		android:layout_marginLeft="12dip"
+                android:layout_marginBottom="4dip"
+                android:layout_marginRight="12dip"
+                android:layout_marginTop="0dip"
+
+		android:text="@string/w_callromania_buycredit" />
+                
+			
+		<ImageView
                 android:layout_width="fill_parent"
                 android:layout_height="1dip"
                 android:background="@android:drawable/divider_horizontal_dark"
Index: CSipSimple/res/values-ro/api_strings.xml
===================================================================
--- CSipSimple/res/values-ro/api_strings.xml	(revision 0)
+++ CSipSimple/res/values-ro/api_strings.xml	(working copy)
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+	Copyright (C) 2010 Regis Montoya (aka r3gis - www.r3gis.fr)
+
+	This file is part of CSipSimple. 
+-->
+
+<resources>
+
+    <string name="app_name">callRomania</string>
+    <string name="permlab_useSip">Foloseste SIP</string>
+    <string name="permdesc_useSip">Efectueaza apeluri SIP, trimite mesaje SIP si controleaza comunicatia SIP</string>
+    <string name="permlab_configureSip">Foloseste SIP</string>
+    <string name="permdesc_configureSip">Efectueaza apeluri SIP, trimite mesaje SIP si controleaza comunicatia SIP</string>
+
+</resources>
Index: CSipSimple/res/values-ro/descriptions_strings.xml
===================================================================
--- CSipSimple/res/values-ro/descriptions_strings.xml	(revision 0)
+++ CSipSimple/res/values-ro/descriptions_strings.xml	(working copy)
@@ -0,0 +1,127 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <!--
+     String describing the image on ImageButton one
+
+        Note: AccessibilityServices use this attribute to announce what the view represents.
+              This is especially valuable for views without textual representation like ImageView.
+    -->
+    <string name="description_image_button_one">unu</string>
+
+    <!--
+         String describing the image on ImageButton two
+
+        Note: AccessibilityServices use this attribute to announce what the view represents.
+              This is especially valuable for views without textual representation like ImageView.
+    -->
+    <string name="description_image_button_two">doi</string>
+
+    <!--
+         String describing the image on ImageButton three
+
+        Note: AccessibilityServices use this attribute to announce what the view represents.
+              This is especially valuable for views without textual representation like ImageView.
+    -->
+    <string name="description_image_button_three">trei</string>
+
+    <!--
+         String describing the image on ImageButton four
+
+        Note: AccessibilityServices use this attribute to announce what the view represents.
+              This is especially valuable for views without textual representation like ImageView.
+    -->
+    <string name="description_image_button_four">patru</string>
+
+    <!--
+         String describing the image on ImageButton five
+
+        Note: AccessibilityServices use this attribute to announce what the view represents.
+              This is especially valuable for views without textual representation like ImageView.
+    -->
+    <string name="description_image_button_five">cinci</string>
+
+    <!--
+         String describing the image on ImageButton six
+
+        Note: AccessibilityServices use this attribute to announce what the view represents.
+              This is especially valuable for views without textual representation like ImageView.
+    -->
+    <string name="description_image_button_six">sase</string>
+
+    <!--
+         String describing the image on ImageButton seven
+
+        Note: AccessibilityServices use this attribute to announce what the view represents.
+              This is especially valuable for views without textual representation like ImageView.
+    -->
+    <string name="description_image_button_seven">sapte</string>
+
+    <!--
+         String describing the image on ImageButton eight
+
+        Note: AccessibilityServices use this attribute to announce what the view represents.
+              This is especially valuable for views without textual representation like ImageView.
+    -->
+    <string name="description_image_button_eight">opt</string>
+
+    <!--
+         String describing the image on ImageButton nine
+
+        Note: AccessibilityServices use this attribute to announce what the view represents.
+              This is especially valuable for views without textual representation like ImageView.
+    -->
+    <string name="description_image_button_nine">noua</string>
+
+    <!--
+         String describing the image on ImageButton star
+
+        Note: AccessibilityServices use this attribute to announce what the view represents.
+              This is especially valuable for views without textual representation like ImageView.
+    -->
+    <string name="description_image_button_star">star</string>
+
+    <!--
+         String describing the image on ImageButton zero
+
+        Note: AccessibilityServices use this attribute to announce what the view represents.
+              This is especially valuable for views without textual representation like ImageView.
+    -->
+    <string name="description_image_button_zero">zero</string>
+
+    <!--
+         String describing the image on ImageButton pound
+
+        Note: AccessibilityServices use this attribute to announce what the view represents.
+              This is especially valuable for views without textual representation like ImageView.
+    -->
+    <string name="description_image_button_pound">pound</string>
+
+    <!--
+         String describing the Dial ImageButton
+
+         Used by AccessibilityService to announce the purpose of the button.
+    -->
+    <string name="description_dial_button">formeaza</string>
+    <!--
+         String describing the Dial Video ImageButton
+
+         Used by AccessibilityService to announce the purpose of the button.
+    -->
+    <string name="description_dial_video_button">video dial</string>
+
+    <!--
+         String describing the Delete/Backspace ImageButton
+
+         Used by AccessibilityService to announce the purpose of the button.
+    -->
+    <string name="description_delete_button">backspace</string>
+
+    <!--
+         String describing the digits text box containing the number to dial.
+
+         Used by AccessibilityService to announce the purpose of the view.
+    -->
+    <string name="description_digits_edittext">numar de apelat</string>
+
+</resources>
Index: CSipSimple/res/values-ro/messages_strings.xml
===================================================================
--- CSipSimple/res/values-ro/messages_strings.xml	(revision 0)
+++ CSipSimple/res/values-ro/messages_strings.xml	(working copy)
@@ -0,0 +1,167 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+ * Copyright (C) 2007-2008 Esmertec AG.
+ * Copyright (C) 2007-2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+-->
+
+<resources>
+
+    <!-- The name of the SMS/MMS app as it appears to the user in the Home screen, task switcher, etc. -->
+    <string name="app_label">Mesagerie</string>
+
+    <!-- Command name to open a Compose screen; displays in conversation list -->
+    <string name="new_message">Mesaj nou</string>
+    <!-- Summary text under "New Message" command; displays in conversation list -->
+    <string name="create_new_message">Scrie mesaj nou</string>
+
+    <!-- Menu item for starting a new conversation -->
+    <string name="menu_compose_new">Compune</string>
+    <!-- Menu item to call the recipient of the conversation on the phone (imperative verb) -->
+    <string name="menu_call">Apeleaza</string>
+    <!-- Menu item for deleting all conversations -->
+    <string name="menu_delete_all">Sterge conversatii</string>
+    <!-- Context menu item on an individual conversation for deleting that conversation -->
+    <string name="menu_delete">Sterge conversatie</string>
+    <!-- Context menu item on an individual conversation for viewing that conversation -->
+    <string name="menu_view">Vezi conversatie</string>
+
+    <!-- Name to use when we have an unspecified sender -->
+    <string name="anonymous_recipient">Anonim</string>
+
+    <!-- Name of the local user when displaying sender of an outgoing message (personal pronoun) -->
+    <string name="messagelist_sender_self">Eu</string>
+    <string name="delete_message">Sterge mesaj</string>
+    <!-- Abbreviation for "kilobyte" -->
+    <string name="kilobyte">KB</string>
+
+    <!-- Dialog box title brought up when warning the user that a message could not be delivered -->
+    <string name="undelivered_msg_dialog_title">Mesaj netrimis</string>
+    <!-- Dialog box message indicating that a message could not be delivered -->
+    <string name="undelivered_sms_dialog_body">Mesajul nu a putut fi trimis.</string>
+    <!-- Menu item for deleting the entire conversation currently being viewed -->
+    <string name="delete_thread">Sterge conversatie</string>
+    <!--
+         Text of a button appearing for MMS messages that have not yet been downloaded, causing the message
+         to be downloaded (imperative verb)
+    -->
+    <string name="download">Downloadeaza</string>
+    <!--
+         Message displayed in place of the "download message" button once it has been pressed,
+         indicating that the download is in progress
+    -->
+    <string name="downloading">Se downloadeaza</string>
+    <!-- Individual message context menu item -->
+    <string name="copy_message_text">Copiaza mesajul text</string>
+    <!-- Header for context menu on an individual message -->
+    <string name="message_options">Optiuni mesaj</string>
+
+    <!-- Button text on edit slide screen indicating the user wants to finish editing that slide -->
+    <string name="done">Gata</string>
+
+    <!-- Title bar displayed in compose message activity before a recipient has been selected -->
+    <string name="compose_title">Compune</string>
+
+    <!-- Menu item in conversation screen for attaching something to the message being composed -->
+    <string name="add_attachment">Ataseaza</string>
+
+    <!-- Button next to an attachment during message composition to view the attachment (imperative verb) -->
+    <string name="view">Vezi</string>
+
+    <!-- Button in conversation screen for sending the SMS message currently being composed (imperative verb) -->
+    <string name="send">Trimite</string>
+
+    <!-- Menu item in conversation screen for returning to the conversation list -->
+    <string name="all_threads">Toate conversatiile</string>
+
+    <!-- Hint text in message body field when keyboard is exposed -->
+    <string name="type_to_compose_text_enter_to_send">Incepe sa scrii</string>
+    <!-- Hint text in message body field when keyboard is hidden -->
+    <string name="open_keyboard_to_compose_message">Deschide tastatura sa incepi sa scrii</string>
+
+    <!-- Dialog title for warning the user that the picture they are trying to attach is too large -->
+    <string name="image_too_large">Imagine prea mare</string>
+    <!-- Dialog message text asking the user if he wants to resize the picture being attached -->
+    <string name="ask_for_automatically_resize">Micsoreaza imaginea automat inainte de trimitere?</string>
+
+    <!-- Toast message while an image is being resized -->
+    <string name="compressing">Imagine prea mare. Compresez…</string>
+
+    <!-- Context menu item on a message recipient for viewing their contact info -->
+    <string name="menu_view_contact">Vezi contactul</string>
+    <!--
+         Context menu item on a message recipient for adding them to the user's
+         contacts (used if the recipient is not already in the address book)
+    -->
+    <string name="menu_add_to_contacts">Adauga la contacte</string>
+
+    <!-- Sender to be used if the sender address has been hidden -->
+    <string name="hidden_sender_address">Identitate ascunsa</string>
+
+    <!-- Text to be used for affirmative response button in dialog boxes -->
+    <string name="yes">OK</string>
+    <!-- Text to be used for negative response button in dialog boxes -->
+    <string name="no">Anuleaza</string>
+
+    <!-- Button text used for editing a slideshow (imperative verb) -->
+    <string name="edit">Editeaza</string>
+
+    <!-- Settings screen menu item for restoring all settings to default -->
+    <string name="restore_default">"Restaureaza setarile initiale"</string>
+
+    <!-- Confirm Delete -->
+    <!-- Delete confirmation dialog title -->
+    <string name="confirm_dialog_title">Sterge</string>
+    <!-- Delete entire thread confirmation dialog message -->
+    <string name="confirm_delete_conversation">Intreaga conversatie va fi stearsa.</string>
+    <!-- Delete all threads confirmation dialog message -->
+    <string name="confirm_delete_all_conversations">Toate conversatiile vor fi sterse.</string>
+    <!-- Delete message confirmation dialog message -->
+    <string name="confirm_delete_message">Mesajul va fi sters.</string>
+    <!-- Delete message confirmation dialog message for a locked message -->
+    <string name="confirm_delete_locked_message">Esti sigur ca vrei sa stergi acest mesaj blocat?</string>
+    <!-- Delete entire thread confirmation dialog message -->
+    <string name="confirm_delete_all_messages">Intreaga conversatie va fi stearsa.</string>
+    <!-- Delete button title -->
+    <string name="delete">Sterge</string>
+
+    <!-- Status in "Report" window -->
+    <string name="status_none">(Nimic)</string>
+    <!-- Status in "Report" window -->
+    <string name="status_pending">In asteptare</string>
+    <!-- Status in "Report" window -->
+    <string name="status_received">Primit</string>
+    <!-- Status in "Report" window -->
+    <string name="status_failed">Fara succes</string>
+    <!-- Status in "Report" window -->
+    <string name="status_unread">Necitit</string>
+    <!-- Status in "Report" window -->
+    <string name="status_rejected">Respins</string>
+    <!-- Label in "Report" window -->
+    <string name="recipient_label">Destinatar: </string>
+    <!-- Label in "Report" window -->
+    <string name="status_label">Status: </string>
+
+    <!-- Menu item -->
+    <string name="menu_insert_smiley">Insereaza smiley</string>
+
+    <!-- Label for the "Me" number of this phone. -->
+    <string name="me">Eu</string>
+
+    <!-- Brief small label shown to right of message when it is being sent. -->
+    <string name="sending_message">Trimitere…</string>
+
+</resources>
Index: CSipSimple/res/values-ro/prefs_strings.xml
===================================================================
--- CSipSimple/res/values-ro/prefs_strings.xml	(revision 0)
+++ CSipSimple/res/values-ro/prefs_strings.xml	(working copy)
@@ -0,0 +1,346 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="prefs">Setari</string>
+    <string name="prefs_fast">Configurare rapida</string>
+    <string name="prefs_fast_desc">Optiuni rapide pentru incepatori</string>
+    <string name="prefs_network">Retea</string>
+    <string name="prefs_network_desc">Cum se poate conecta clientul SIP la retea</string>
+    <string name="prefs_media">Media</string>
+    <string name="prefs_media_desc">Codecuri si sunet in timpul apelului</string>
+    <string name="prefs_ui">Interfata utilizator</string>
+    <string name="prefs_ui_desc">Modifica interfata utilizator</string>
+    <string name="prefs_calls">Optiuni apel</string>
+    <string name="prefs_calls_desc">Optiuni legat de apeluri</string>
+
+    <!-- Network -->
+    <string name="for_incomings">Pentru apeluri primite</string>
+    <string name="for_outgoings">Pentru apeluri efectuate</string>
+    <string name="perfs">Performante</string>
+    <string name="transport">Transport</string>
+    <string name="transport_desc">Forteaza folosirea unui transport pentru acest cont</string>
+    <string name="use_wifi">Foloseste WiFi</string>
+    <string name="use_wifi_in_desc">Foloseste WiFi pentru apelurile primite</string>
+    <string name="use_wifi_out_desc">Foloseste WiFi pentru apelurile efectuate</string>
+    <string name="use_other">Foloseste alte retele</string>
+    <string name="use_other_in_desc">De exemplu WiMax pentru apeluri primite</string>
+    <string name="use_other_out_desc">De exemplu WiMax pentru apeluri efectuate</string>
+    <string name="use_anyway">Foloseste oricum</string>
+    <string name="use_anyway_desc">Nu tine cont de reteaua Android. In mod normal, nu trebuie folosit</string>
+    <string name="use_3g">Foloseste 3G (sau mai bun)</string>
+    <string name="use_3g_disclamer">Operatorul tau TREBUIE sa iti dea voie sa folosesti aceasta optiune. E posibil ca operatorul sa va ceara taxe in plus pentru acest serviciu.</string>
+    <string name="use_edge">Foloseste EDGE</string>
+    <string name="use_gprs">Foloseste GPRS</string>
+    <string name="lock_wifi">Blocheaza WiFi</string>
+    <string name="lock_wifi_desc">Mentine WiFi activ cand contul SIP este conectat</string>
+    <string name="lock_wifi_perfs">Blocheaza performante mari</string>
+    <string name="lock_wifi_perfs_desc">Blocare Wifi in modul de performante mari (bateria se consuma mai repede)</string>
+    <string name="enable_tcp">TCP</string>
+    <string name="enable_tcp_desc">Activeaza transportul TCP</string>
+    <string name="enable_tls">TLS</string>
+    <string name="enable_tls_desc">Activeaza transportul TLS</string>
+    <string name="enable_udp">UDP</string>
+    <string name="enable_udp_desc">Activeaza transportul UDP</string>
+    <string name="network_udp_transport_port">Port UDP</string>
+    <string name="network_udp_transport_port_desc">Numar port pentru bind local</string>
+    <string name="network_tcp_transport_port">Port TCP</string>
+    <string name="network_tcp_transport_port_desc">Numar port pentru bind local</string>
+    <string name="network_rtp_port">Post RTP</string>
+    <string name="network_rtp_port_desc">Port de inceput de pentru RTP</string>
+    <string name="use_ipv6">Foloseste IPv6</string>
+    <string name="use_ipv6_desc">Treci in modul IPv6 (reteaua si telefonul tau trebuie sa suporte asta)</string>
+    <string name="enable_dns_srv">Rezolva DNS SRV</string>
+    <string name="enable_dns_srv_desc">Foloseste resolverul aplicatiei pentru rezolvarea numelor DNS</string>
+    <string name="override_nameserver">Foloseste un DNS customizat</string>
+    <string name="override_nameserver_desc">Lasat gol pentru a obtine DNS de la Android</string>
+    <string name="nat_traversal">NAT traversal</string>
+    <string name="enable_ice">Activeaza ICE</string>
+    <string name="enable_ice_desc">Porneste functia de ICE</string>
+    <string name="enable_turn">Actineaza TURN</string>
+    <string name="enable_turn_desc">Porneste functia de TURN</string>
+    <string name="turn_server">Server TURN</string>
+    <string name="turn_server_desc">Server TURN (HOST:PORT)</string>
+    <string name="turn_username">Utilizator TURN</string>
+    <string name="turn_username_desc">Nume utilizator pentru autentificare TURN</string>
+    <string name="turn_password">Parola TURN</string>
+    <string name="turn_password_desc">Parola pentru autentificare TURN</string>
+    <string name="enable_stun">Activeaza STUN</string>
+    <string name="enable_stun_desc">Porneste functia de STUN</string>
+    <string name="enable_stun2">Foloseste noul format STUN</string>
+    <string name="enable_stun2_desc">Cererile STUN pentru rezolvare adrese mapate pe socket trebuie sa foloseasca noul format</string>
+    <string name="stun_server">Servere STUN</string>
+    <string name="stun_server_desc">Servere STUN (HOST[:PORT], …)</string>
+    <string name="enable_qos">Activeaza QoS</string>
+    <string name="enable_qos_desc">Activeaza QoS la pachete</string>
+    <string name="dscp_val">Valoare DSCP</string>
+    <string name="dscp_val_desc">Valoare DSCP pentru trafic SIP</string>
+    <string name="rtp_dscp_val_desc">Valoare DSCP pentru trafic RTP</string>
+    <string name="udp_keep_alive_interval_wifi">Wifi UDP keep alive</string>
+    <string name="udp_keep_alive_interval_mobile">Mobile UDP keep alive</string>
+    <string name="tcp_keep_alive_interval_wifi">Wifi TCP keep alive</string>
+    <string name="tcp_keep_alive_interval_mobile">Mobile TCP keep alive</string>
+    <string name="tls_keep_alive_interval_wifi">Wifi TLS keep alive</string>
+    <string name="tls_keep_alive_interval_mobile">Mobile TLS keep alive</string>
+    <string name="keep_alive_interval">Mentine conectiunea activa</string>
+    <string name="keep_alive_interval_desc">Interval (sec) pentru pachete KA</string>
+    <string name="use_compact_form">Foloseste compact SIP</string>
+    <string name="use_compact_form_desc">Scade marimea pachetelor SIP. Poate sa nu functioneze pe serverele SIP mai vechi</string>
+    <string name="user_agent">User agent</string>
+    <string name="user_agent_desc">Agent presentat de applicatie (daca e default, va adauga informatii)</string>
+    <!--
+    <string name="ka_use_wake">Keep alive awake</string>
+    <string name="ka_use_wake_desc">If activated keep alive will awake phone</string>
+    -->
+    <string name="force_no_update">Forteaza fara actualizare</string>
+    <string name="force_no_update_desc">Some buggy remote party announce to support UPDATE method while it does not, this option force the legacy way to manage UPDATE/re-INVITE</string>
+    <string name="timer_min_se">Minimum session expiration</string>
+    <string name="timer_min_se_desc">Minimum session expiration period, in seconds. Must not be lower than 90.</string>
+    <string name="timer_sess_expires">Session expiration period</string>
+    <string name="timer_sess_expires_desc">Session expiration period, in seconds. Must not be lower than min_se.</string>
+    <string name="sip_protocol">SIP protocol</string>
+    <string name="sip_protocol_desc">SIP protocol tweak.</string>
+    <string name="tsx_t1_timeout">Transaction T1 timeout value.</string>
+    <string name="tsx_t2_timeout">Transaction T2 timeout value.</string>
+    <string name="tsx_t4_timeout">Transaction T4 timeout value.</string>
+    <string name="tsx_td_timeout">Transaction completed timer for INVITE.</string>
+    <string name="tsx_timeout_desc">Leave -1 for default RFC 3261 values</string>
+    <string name="network_route_polling">Check for network changes each (minutes)</string>
+    <string name="network_route_polling_desc">Android 4.0 VPN check workaround. Leave to 0 if not in this case to disable</string>
+    <string name="disable_tcp_switch">Disable TCP switch</string>
+    <string name="disable_tcp_switch_desc">If activated, prevent the stack to switch to TCP for big UDP packets.</string>
+    <string name="disable_rport">Disable rport in request</string>
+    <string name="disable_rport_desc">Only activate for buggy servers. Disable RFC 3581 support by not sending rport.</string>
+    <string name="add_bandwidth_tias_in_sdp">Add bandwidth modifier TIAS in SDP</string>
+    <string name="add_bandwidth_tias_in_sdp_desc">As per RFC3890. Needed for video on Avaya servers but breaks buggy parsing for some SIP servers.</string>
+
+    <!-- Security -->
+    <string name="tls">TLS</string>
+    <string name="secure_transport">Secure transport</string>
+    <string name="secure_transport_desc">Security mechanism for SIP and RTP</string>
+    <string name="secure_media">Secure media</string>
+    <string name="network_tls_transport_port">TLS Port</string>
+    <string name="network_tls_transport_port_desc">Port number to bind locally</string>
+    <string name="network_tls_server_name">TLS server name</string>
+    <string name="network_tls_server_name_desc">For multi-hosting server (optional)</string>
+    <string name="ca_list_file">TLS CA file</string>
+    <string name="ca_list_file_desc">For example /sdcard/CSipSimple/myAuthority.ca</string>
+    <string name="cert_file">TLS certificate file</string>
+    <string name="cert_file_desc">For example /sdcard/CSipSimple/myCert.crt</string>
+    <string name="privkey_file">TLS private key file</string>
+    <string name="privkey_file_desc">For example /sdcard/CSipSimple/myKey.key</string>
+    <string name="tls_password">TLS password</string>
+    <string name="tls_password_desc">TLS password to private key file</string>
+    <string name="verify_server">Check server</string>
+    <string name="verify_server_desc">Verify server\'s certificate</string>
+    <string name="verify_client">Check client</string>
+    <string name="verify_client_desc">Verify client\'s certificate</string>
+    <string name="tls_method">TLS Method</string>
+    <string name="tls_method_desc">Method for TLS transport</string>
+    <string name="use_srtp">SRTP mode</string>
+    <string name="use_srtp_desc">Mode for Secure RTP</string>
+    <string name="use_zrtp">ZRTP mode</string>
+    <string name="use_zrtp_desc">Mode for Secured ZRTP</string>
+
+    <!-- Media -->
+
+    <string name="audio_quality">Calitate audio</string>
+    <string name="audio_volume">Volum</string>
+    <string name="codecs">Codecuri</string>
+    <string name="echo_cancellation">Anulare ecou</string>
+    <string name="echo_cancellation_desc">Activeaza anulare ecou</string>
+    <string name="enable_vad">Detectare voce audio</string>
+    <string name="enable_vad_desc">Activeaza detectare voce audio</string>
+    <string name="enable_ns">Reducere zgomot</string>
+    <string name="enable_ns_desc">Functioneaza daca este activata si anularea de ecou</string>
+    <string name="snd_mic_level">Amplificare microfon</string>
+    <string name="snd_mic_level_desc">Ajusteaza semnalul microfonului (1 nu modifica nimic)</string>
+    <string name="snd_speaker_level">Aplificare difuzor</string>
+    <string name="snd_speaker_level_desc">Ajusteaza semnalul difuzorului (1 nu modifica nimic)</string>
+    <string name="snd_bt_mic_level">Aplificare microfon Bluetooth</string>
+    <string name="snd_bt_speaker_level">Aplificare ascultare Bluetooth</string>
+    <string name="snd_stream_level">Nivel initial flux</string>
+    <string name="snd_stream_level_desc">Seteaza nivelul initial pentru fluxul audio (flux Android)</string>
+    <string name="snd_auto_close_time">Timp de auto oprire</string>
+    <string name="snd_auto_close_time_desc">Timp de asteptare pentru inchiderea canalului audio</string>
+    <string name="snd_media_quality">Calitate Media</string>
+    <string name="snd_media_quality_desc">Calitatea fluxului media (modificati doar daca stiti ce faceti)</string>
+    <string name="snd_clock_rate">Rata ceas</string>
+    <string name="snd_clock_rate_desc">Frecventa canal audio</string>
+    <string name="snd_ptime">Timp ptime pentru audio frame</string>
+    <string name="snd_ptime_desc">The value here will affect the samples per frame of both the sound device and the conference bridge. Specifying lower ptime will normally reduce the latency.</string>
+    <string name="echo_cancellation_tail">Echo cancellation tail</string>
+    <string name="echo_cancellation_tail_desc">Tail length of echo cancellation</string>
+    <string name="echo_mode">Echo mode</string>
+    <string name="echo_mode_desc">Algorithm for echo</string>
+    <string name="codecs_desc">Priority (0 is disabled)</string>
+    <string name="sip_dtmf">DTMF mode</string>
+    <string name="sip_dtmf_desc">How to send DTMF</string>
+    <string name="dtmf_pause_time">Time of DTMF pause</string>
+    <string name="dtmf_pause_time_desc">Pause (,) separator waiting time in ms</string>
+    <string name="dtmf_wait_time">Time of DTMF wait</string>
+    <string name="dtmf_wait_time_desc">Wait (;) separator waiting time in ms</string>
+    <string name="use_soft_volume">Use software volume</string>
+    <string name="use_soft_volume_desc">Use software volume instead of android volume</string>
+    <string name="use_routing_api">Use routing API</string>
+    <string name="use_routing_api_desc">Try to enable that if audio is routing to speaker instead of earpiece</string>
+    <string name="use_mode_api">Use Mode audio API</string>
+    <string name="use_mode_api_desc">Try to enable that if audio is routing to speaker instead of earpiece</string>
+    <string name="sip_audio_mode">Audio mode for SIP calls</string>
+    <string name="sip_audio_mode_desc">Change only if developers advise you to</string>
+    <string name="use_webrtc_hack">Use WebRTC implementation</string>
+    <string name="use_webrtc_hack_desc">Implementation made by WebRTC team</string>
+    <string name="do_focus_audio">Focus audio</string>
+    <string name="do_focus_audio_desc">Disabling will result overlaps with music but may help with routing</string>
+    <string name="micro_source">Mic source</string>
+    <string name="micro_source_desc">Source for microphone. Choosing the appropriate value may improve echo cancellation</string>
+    <string name="has_io_queue">IO Queue</string>
+    <string name="has_io_queue_desc">Activate Queue for input/output</string>
+    <string name="set_audio_generate_tone">Tone hack</string>
+    <string name="set_audio_generate_tone_desc">Generate a tone before making calls</string>
+    <string name="restart_aud_on_routing_change">Restart stream when change routing</string>
+    <string name="restart_aud_on_routing_change_desc">Mandatory for Bluetooth when default clock rate is different of 8kHz. Disabling could help to switch faster.</string>
+    <string name="band_for_wifi">Band type for wifi</string>
+    <string name="band_for_3g">Band type for 3G</string>
+    <string name="band_for_gprs">Band type for GPRS</string>
+    <string name="band_for_edge">Band type for EDGE</string>
+    <string name="band_for_other">Band type for other</string>
+    <string name="codecs_band_types">Connections bandwidth types for codecs</string>
+    <string name="use_sgs_call_hack">Use Samsung Galaxy Hack</string>
+    <string name="use_sgs_call_hack_desc">Pre set call mode to solve routing</string>
+    <string name="audio_implementation">Audio implementation</string>
+    <string name="audio_implementation_desc">Backend for audio</string>
+    <string name="digest">Digest</string>
+    <string name="pgp">PGP</string>
+    <string name="plain_password">Plain password</string>
+    <string name="data_digest">Data digest</string>
+    <string name="disabled">Disabled</string>
+    <string name="optional">Optional</string>
+    <string name="mandatory">Mandatory</string>
+    <string name="auto">Auto</string>
+    <string name="rtp">RTP</string>
+    <string name="in_band">In band generation</string>
+    <string name="sip_info">SIP INFO</string>
+    <string name="legacy">Legacy</string>
+    <string name="normal">Normal</string>
+    <string name="force">Force</string>
+    <string name="prevent">Prevent</string>
+    <string name="speex">Speex</string>
+    <string name="simple">Simple</string>
+    <string name="webrtc">WebRTC</string>
+    <string name="use_android_setting">Use Android setting</string>
+    <string name="narrowband">Narrowband</string>
+    <string name="wideband">Wideband</string>
+    <string name="slow">Slow</string>
+    <string name="fast">Fast</string>
+    <string name="no_proxy">No proxy</string>
+    <string name="outbound_proxies">Outbound proxies</string>
+    <string name="accounts_proxies">Accounts proxies</string>
+    <string name="all">All</string>
+    <string name="no_zrtp">No ZRTP</string>
+    <string name="create_zrtp">Create ZRTP</string>
+    <string name="default_str">Default</string>
+    <string name="auto_connect_bluetooth">Auto connect bluetooth</string>
+    <string name="auto_connect_bluetooth_desc">Try to use BT SCO automatically (may break standard audio routing case)</string>
+    <string name="auto_connect_speaker">Auto connect rear speaker</string>
+    <string name="auto_connect_speaker_desc">Automatically use rear speaker when answering a call</string>
+    <string name="auto_detect_speaker">Auto detect speaker usage</string>
+    <string name="auto_detect_speaker_desc">Switch to rear speaker when phone is horizontal during a call.</string>
+    <string name="codecs_per_bandwidth">Codec priority list per bandwidth</string>
+    <string name="codecs_per_bandwidth_desc">Use separate codec priority lists for fast and slow networks</string>
+    <string name="audio_troubleshooting">Audio troubleshooting</string>
+    <string name="audio_troubleshooting_desc">Workarounds for audio routing</string>
+    <string name="codecs_extra_settings">Extra codec settings</string>
+    <string name="frames_per_rtp_packet">Frames per RTP packet</string>
+    <string name="g729_frame_per_packet">G729 RTP frames per packet</string>
+    <string name="ilbc_frame_per_packet">iLBC RTP frames per packet</string>
+    <string name="codec_h264_profile">H264 profile</string>
+    <string name="codec_h264_level">H264 level</string>
+    <string name="codec_h264_bitrate">H264 bitrate</string>
+    <string name="codec_h264_bitrate_desc">Use 0 for default for selected level</string>
+    <string name="thread_count">Thread count</string>
+    <string name="thread_count_desc">Number of thread allocated for the native stack</string>
+    <string name="setup_audio_before_init">Setup audio before init</string>
+    <string name="setup_audio_before_init_desc">Put audio in correct mode before audio stream initialization</string>
+    <string name="video_capture_size">Video capture size</string>
+    <string name="video_capture_size_desc">Size of capture frames</string>
+
+    <!-- UI -->
+    <string name="general_ui">Interfata utilizator generala</string>
+    <string name="native_dialer_integration">Integrare telefon nativ</string>
+    <string name="advanced_ui">Customizari avansate</string>
+    <string name="integrate_with_native_dialer">Integrare telefon</string>
+    <string name="integrate_with_native_dialer_desc">Cand suni folosind telefonul nativ, vei fi intrebat daca vrei sa folosesti callRomania sau mobilul tau</string>
+    <string name="integrate_tel_privileged">Integrare privilegiata</string>
+    <string name="integrate_tel_privileged_desc">O cale diferita pentru integrare cu telefonul nativ. Trebuie dezactivata integrarea cu telefonul pentru folosire.</string>
+    <string name="integrate_with_native_calllogs">Integrare istori apeluri</string>
+    <string name="integrate_with_native_calllogs_desc">Apelurile callRomania vor fi alaturate apelurilor native</string>
+    <string name="dial_press_tone">Setari sunete la formare numar</string>
+    <string name="dial_press_tone_desc">Activeaza sunente pentru formare numar</string>
+    <string name="dtmf_press_tone">Setari sunete la DTMF</string>
+    <string name="dtmf_press_tone_desc">Play touch tones when sending DTMF in call</string>
+    <string name="dial_press_vibrate">Dialing vibrate feedback</string>
+    <string name="dial_press_vibrate_desc">Haptic (vibrate) feedback when dialing</string>
+    <string name="start_with_text_dialer">Text dialer</string>
+    <string name="start_with_text_dialer_desc">Start with text dialer</string>
+    <string name="use_alternate_unlocker">Don\'t use slide answer</string>
+    <string name="use_alternate_unlocker_desc">Use buttons instead of slide to take incoming calls</string>
+    <string name="keep_awake_incall">Keep awake while on call</string>
+    <string name="keep_awake_incall_desc">Fixes if you get choppy sound when screen turn off while in WIFI call</string>
+    <string name="use_partial_wake_lock">Use partial wake lock</string>
+    <string name="use_partial_wake_lock_desc">Ensure CPU is always running for the application (drain battery)</string>
+    <string name="log_level">Log level</string>
+    <string name="log_level_desc">Log level for debug between 0 (none) and 5 (verbose)</string>
+    <string name="integrate_with_native_music">Integrate with Music application</string>
+    <string name="integrate_with_native_music_desc">Disable it if you use another music application than the official one</string>
+    <string name="ringtone">Ringtone</string>
+    <string name="ringtone_desc">Default ringtone for SIP calls</string>
+    <string name="prevent_screen_rotation">Prevent screen rotation</string>
+    <string name="prevent_screen_rotation_desc">Avoid rotation of the screen and keep in portrait mode</string>
+    <string name="gsm_integration_type">Mobile phone integration</string>
+    <string name="gsm_integration_type_desc">How the application uses your mobile phone (or not)</string>
+    <string name="invert_proximity_sensor">Invert proximity sensor</string>
+    <string name="invert_proximity_sensor_desc">May help on some devices when manufacturer inverted near and far</string>
+    <string name="theme">Theme</string>
+    <string name="theme_desc">Theme for the application</string>
+    <string name="obtain_themes">Obtain more themes</string>
+    <string name="obtain_themes_desc">Get themes apps on the market</string>
+    <string name="display_icon_in_status_bar_nbr">Display number in status bar</string>
+    <string name="display_icon_in_status_bar_nbr_desc">Display the number of registered accounts in status bar</string>
+    <string name="log_use_direct_file">Log directly to a file</string>
+    <string name="log_use_direct_file_desc">Log into file directly instead of logcat</string>
+
+    <!-- Fast settings -->
+    <string name="android_integration">Integrare cu Android</string>
+    <string name="android_integration_desc">Integrare cu telefonul nativ si istori apeluri</string>
+    <string name="availability_profile">Profil disponibilitate</string>
+    <string name="always_available">Mereu disponibil</string>
+    <string name="always_available_desc">Va folosi bateria, insa apelurile primite nu vor fi ratate</string>
+    <string name="wifi_available">Disponibil pe WiFi</string>
+    <string name="wifi_available_desc">Disponibilitatea pentru apeluri primite se va baza pe profilul WiFi</string>
+    <string name="never_available">Doar pentru apeluri efectuate</string>
+    <string name="never_available_desc">Activeaza clientul SIP automat cand este necesar</string>
+    <string name="availability_tg">Disponibilitate date mobile</string>
+    <string name="tg_allowed">Pot folosi date mobile (3G / EDGE / GPRS)</string>
+    <string name="tg_allowed_desc">Operatorul tau accepta VOIP.</string>
+    <string name="codecs_availability_text">Disponibil doar daca contul SIP este inregistrat</string>
+
+    <!-- Calls settings -->
+    <string name="auto_record_calls">Auto inregistreaza apelurile</string>
+    <string name="auto_record_calls_desc">Inregistreaza apelurile in momentul conectarii</string>
+    <string name="support_multiple_calls">Suporta apeluri multiple</string>
+    <string name="support_multiple_calls_desc">Perminte conferinta si apeluri concurente multiple</string>
+    <string name="vid_in_auto_show">Arata video automat</string>
+    <string name="vid_in_auto_show_desc">Arata video de la partea cealalta automat</string>
+    <string name="vid_out_auto_transmit">Trimite video automat</string>
+    <string name="vid_out_auto_transmit_desc">Trimite video de la dispozitiv automat</string>
+    <string name="use_video">Folosire video</string>
+    <string name="use_video_desc">Trimite video de la dispozitiv automat</string>
+
+    <!-- Settings modes -->
+    <string name="expert_preferences">Modul Expert</string>
+    <string name="normal_preferences">Modul Normal</string>
+
+    <!-- Generic -->
+    <string name="leave_minus_1_default">Leave -1 to default</string>
+
+</resources>
Index: CSipSimple/res/values-ro/strings.xml
===================================================================
--- CSipSimple/res/values-ro/strings.xml	(revision 0)
+++ CSipSimple/res/values-ro/strings.xml	(working copy)
@@ -0,0 +1,118 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+	Copyright (C) 2010 Regis Montoya (aka r3gis - www.r3gis.fr)
+
+	This file is part of CSipSimple. 
+	CSipSimple is free software: you can
+	redistribute it and/or modify it under the terms of the GNU General
+	Public License as published by the Free Software Foundation, either
+	version 3 of the License, or (at your option) any later version.
+
+	CSipSimple is distributed in the hope that it will be useful, but
+	WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+	General Public License for more details. You should have received a
+	copy of the GNU General Public License along with CSipSimple. If not,
+	see <http://www.gnu.org/licenses/>.
+-->
+
+<resources>
+
+    <string name="next">Iainte</string>
+    <string name="init">Initializare…</string>
+    <string name="unable_to_download_file">Imposibil de descarcat fisierul</string>
+    <string name="connection_not_valid">Nu este permisa conectarea la retea cu setarile curente.</string>
+    <string name="invalid_sip_uri">Sip uri este invalid pentru apel</string>
+    <string name="accounts">Conturi</string>
+    <string name="other_accounts">Alte conturi</string>
+    <string name="save">Salveaza</string>
+    <string name="cancel">Anuleaza</string>
+    <string name="activate_account">Activeaza cont</string>
+    <string name="deactivate_account">Deactiveaza cont</string>
+    <string name="delete_account">Sterge cont</string>
+    <string name="modify_account">Modifica cont</string>
+    <string name="add_account">Adauga cont</string>
+    <string name="choose_wizard">Alege wizard</string>
+    <string name="use">Foloseste :</string>
+    <string name="use_pstn">Foloseste Mobilul</string>
+    <string name="ongoing_call">Apel in curs</string>
+    <string name="missed_call">Apel pierdut</string>
+    <string name="recentCalls_empty">Nu exista istoric apeluri</string>
+    <string name="filters">Filtre</string>
+    <string name="filters_desc">Se aplica cand este integrat cu Android</string>
+    <string name="filters_for">Filtre pentru</string>
+    <string name="add_filter">Adauga filtru / regula rescriere</string>
+    <string name="delete_filter">Sterge filtru</string>
+    <string name="callLog_delete_entry">Sterge acest apel</string>
+    <string name="callLog_delete_all">Sterge toate apelurile</string>
+    <string name="callLog_delDialog_title">Sterge istoric apeluri</string>
+    <string name="callLog_delDialog_message">Esti sigur ca vrei sa stergi toate apelurile din istoric?</string>
+    <string name="callLog_delDialog_yes">Da</string>
+    <string name="callLog_delDialog_no">Nu</string>
+    <string name="gsm">Mobil</string>
+    <string name="dial_tab_name_text">Apeleaza</string>
+    <string name="calllog_tab_name_text">Istoric</string>
+    <string name="messages_tab_name_text">Mesaje</string>
+    <string name="favorites_tab_name_text">Favorite</string>
+    <string name="menu_disconnect">Deconectare</string>
+    <string name="service_ticker_registered_text">SIP Inregistrat</string>
+    <string name="outgoing_call_chooser_call_text">Suna</string>
+    <string name="reorder">Rearanjeaza</string>
+    <string name="backup_restore">Backup / Restaureaza</string>
+    <string name="backup">Backup</string>
+    <string name="faq">FAQ</string>
+    <string name="help">Ajutor</string>
+    <string name="record_logs">Inregistreaza logurile si trimite la echipa de suport</string>
+    <string name="send_logs">Opreste inregistrarea de loguri</string>
+    <string name="view_existing_issues">Vezi problemele cunoscute</string>
+    <string name="ok">OK</string>
+    <string name="misc">Misc</string>
+    <string name="warning">ATENTIE</string>
+    <string name="disconnect_and_incoming_explaination">Cand selectezi OK, confirmi ca nu vei mai fi disponibil pana la repornirea aplicatiei</string>
+    <string name="disconnect_and_future_incoming_explaination">Prin deconectare, nu vei mai fi disponibil pe SIP pana la repornirea aplicatiei</string>
+    <string name="gadget_title">SIP - Schimbare cont</string>
+    <string name="pickup_sip_uri">Selecteaza contact SIP</string>
+    <string name="display_icon_in_status_bar_desc">Aplicatia trebuie sa afiseze o icoana in bara de status cand este inregistrata</string>
+    <string name="display_icon_in_status_bar">Afiseaza icoana in bara de status</string>
+    <string name="another_application_use_sip_port">Alta aplicatie foloseste portul SIP, nu pot porni</string>
+    <string name="choose_phone">Selecteaza telefon</string>
+    <string name="no_phone_found">Nici un telefon gasit pentru acest contact</string>
+    <string name="show_password">Arata parola</string>
+    <string name="this_codec_is_not_free">**Acest codec nu e gratis !!!**</string>
+    <string name="voice_mail">Casuta vocala</string>
+    <string name="voice_mail_number">Numar casuta vocala</string>
+    <string name="type_sip_uri_or_autocomplete">Sip uri sau autocompletare</string>
+    <string name="not_configured_multiple_calls">Aplicatia nu e configurata sa suporte apeluri multiple</string>
+    <string name="legal_information">Informatii legale</string>
+    <string name="update_nightly_build">Update nightly build</string>
+    <string name="loading">Incarcare</string>
+    <string name="reconnect">Reconectare</string>
+    <string name="switch_to_text">Schimba in modul text</string>
+    <string name="switch_to_digit">Schimba in modul digiti</string>
+    <string name="no_voice_mail_configured">Casuta vocala neconfigurata</string>
+    <string name="no_accounts">Nici un cont</string>
+    <string name="activate">Activeaza</string>
+    <string name="deactivate">Deactiveaza</string>
+    <string name="audio">Audio</string>
+    <string name="video">Video</string>
+    <string name="invert_selection">Inverseaza selectia</string>
+    <string name="cant_write_file">Eroare scriere fisier</string>
+    <string name="info">Info</string>
+    <string name="csipsimple_shortcut">SIP - scurtatura</string>
+
+    <!-- Presence stuff -->
+    <string name="online">Online</string>
+    <string name="offline">Offline</string>
+    <string name="away">Away</string>
+    <string name="busy">Busy</string>
+    <string name="activate_presence_sharing">Arata prezenta</string>
+    <string name="deactivate_presence_sharing">Opreste aratarea prezentei</string>
+    <string name="presence">Status</string>
+    <string name="configure">Configureaza</string>
+    <string name="set_android_group">Selecteaza grupul Android</string>
+    <string name="set_sip_data">Selecteaza sip uri data</string>
+    <string name="uri_nbr">Numar de telefon</string>
+    <string name="uri_im">IM with custom SIP scheme</string>
+    <string name="uri_sip">Apel Internet</string>
+
+</resources>
Index: CSipSimple/res/values-ro/tests_strings.xml
===================================================================
--- CSipSimple/res/values-ro/tests_strings.xml	(revision 0)
+++ CSipSimple/res/values-ro/tests_strings.xml	(working copy)
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="test_audio">Audio test</string>
+    <string name="test_audio_prepare">Preparing audio test…</string>
+    <string name="test_audio_ongoing">Test ongoing… \nSpeak on mic and listen on earpiece</string>
+    <string name="test_audio_network_failure">Test failed : \nSwitch to a valid network first</string>
+
+</resources>
Index: CSipSimple/res/values-ro/warn_strings.xml
===================================================================
--- CSipSimple/res/values-ro/warn_strings.xml	(revision 0)
+++ CSipSimple/res/values-ro/warn_strings.xml	(working copy)
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+	Copyright (C) 2010 Regis Montoya (aka r3gis - www.r3gis.fr)
+
+	This file is part of CSipSimple. 
+	CSipSimple is free software: you can
+	redistribute it and/or modify it under the terms of the GNU General
+	Public License as published by the Free Software Foundation, either
+	version 3 of the License, or (at your option) any later version.
+
+	CSipSimple is distributed in the hope that it will be useful, but
+	WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+	General Public License for more details. You should have received a
+	copy of the GNU General Public License along with CSipSimple. If not,
+	see <http://www.gnu.org/licenses/>.
+-->
+
+<resources>
+
+    <string name="warn_ignore">Ignora</string>
+    <!-- STUN enabled -->
+    <string name="warn_no_stun">STUN dezactivat</string>
+    <string name="warn_no_stun_description"> Daca nu auzi in timpul unui apel, cel mai probabil este legat de faptul ca esti in spatele unei retea tip NAT.\n 
+       	De aceea, este folositor sa activezi optiunea STUN.\n
+       	Daca nu ai nici o problema cu sunetul la apelurile incoming, poti ignora aceasta notificare.\n
+       	Folosirea STUN creste consumul bateriei.</string>
+    <string name="warn_no_stun_enable">Primesc apeluri si nu aud</string>
+    <string name="warn_no_stun_ignore">Apelurile mele sunt ok</string>
+
+    <!-- Vpn on android 4.0 -->
+    <string name="warn_vpn_ics">VPN changes for 4.0</string>
+    <string name="warn_vpn_ics_description"> You are running android 4.0 which doesn\'t notify about VPN status.\n
+        A possible workaround is to check the route at regular interval.</string>
+    <string name="warn_vpn_ics_1">Check each 1 minute</string>
+    <string name="warn_vpn_ics_5">Check each 5 minutes</string>
+
+    <!-- Privileged intent -->
+    <string name="warn_priv_int">Dialer integration</string>
+    <string name="warn_priv_int_description">It appears that other applications installed on the phone tries to integrate to android too.\n
+	    They do that a way that doesn\'t allow clever features like the one provided by us such as Filtering/Rewriting rules.\n\n
+	    You have two choice : \n
+	    Continue using our integration and install plugins to support other applications. (This will allow to apply filtering/rewriting rules on these applications too). \n
+	    To do so, choose to always use mobile dialer instead of other applications using the checkbox when you\'ll make your next call.</string>
+    <string name="warn_priv_int_description2">Second solution is to make the application integrate the same non clever way than other application.\n
+	    This is an option supported by the application but discouraged because it\'s way less clever and provide a worse user experience.</string>
+    <string name="warn_priv_int_register">Use non clever integration</string>
+    <string name="warn_sdcard">Installation on SDCard</string>
+    <string name="warn_sdcard_description">You have configured to be available for incoming call. But you have moved the application to SDCard.\nThis is discouraged, you should leave the application on internal storage.</string>
+
+</resources>
Index: CSipSimple/res/values-ro/welcome_strings.xml
===================================================================
--- CSipSimple/res/values-ro/welcome_strings.xml	(revision 0)
+++ CSipSimple/res/values-ro/welcome_strings.xml	(working copy)
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+	Copyright (C) 2010 Regis Montoya (aka r3gis - www.r3gis.fr)
+
+	This file is part of CSipSimple. 
+	CSipSimple is free software: you can
+	redistribute it and/or modify it under the terms of the GNU General
+	Public License as published by the Free Software Foundation, either
+	version 3 of the License, or (at your option) any later version.
+
+	CSipSimple is distributed in the hope that it will be useful, but
+	WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+	General Public License for more details. You should have received a
+	copy of the GNU General Public License along with CSipSimple. If not,
+	see <http://www.gnu.org/licenses/>.
+	
+	
+-->
+<resources>
+	<string name="intializing_text">Initializare</string>
+	<string name="downloading_text">Descarcare</string>
+	<string name="installing_library_text">Instalare librarie…</string>
+	<string name="welcome_caption_text">Bine ai venit</string>
+</resources>
Index: CSipSimple/res/values-ro/wizard_basic_strings.xml
===================================================================
--- CSipSimple/res/values-ro/wizard_basic_strings.xml	(revision 0)
+++ CSipSimple/res/values-ro/wizard_basic_strings.xml	(working copy)
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- 
+	Copyright (C) 2010 Regis Montoya (aka r3gis - www.r3gis.fr)
+
+	This file is part of CSipSimple.
+
+    CSipSimple is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    CSipSimple is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with CSipSimple.  If not, see <http://www.gnu.org/licenses/>.
+ -->
+<resources>
+	<string name="w_basic_username">Utilizator</string>
+	<string name="w_basic_username_desc">Adresa ta de email</string>
+	<string name="w_basic_password">Parola</string>
+	<string name="w_basic_password_desc">Parola ta callromania.ro</string>
+
+</resources>
Index: CSipSimple/res/values-ro/wizard_callromania_strings.xml
===================================================================
--- CSipSimple/res/values-ro/wizard_callromania_strings.xml	(revision 0)
+++ CSipSimple/res/values-ro/wizard_callromania_strings.xml	(working copy)
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="w_callromania_title">callRomania</string>
+    <string name="w_callromania_findnumber">Alege un numar</string>
+    <string name="w_callromania_emptyfield">Camp gol</string>
+    <string name="w_callromania_hint">Selecteaza un judet pentru a vedea numerele de telefon disponibile:</string>
+    <string name="w_callromania_choose">Alege un numar de telefon:</string>
+    <string name="w_callromania_error">Crearea contului a fost nereusita. Va rugam incercati din nou.</string>
+    <string name="w_callromania_username">Utilizator</string>
+	<string name="w_callromania_username_desc">Adresa ta de email</string>
+	<string name="w_callromania_password">Parola</string>
+	<string name="w_callromania_password_desc">Parola ta callromania.ro</string>
+	<string name="w_callromania_loginfailed">Adresa email sau parola incorecte. Va rugam incercati din nou.</string>
+	<string name="w_callromania_nointernet">Conectare nereusita. Ai nevoie de o conexiune activa de Internet.</string>
+	<string name="w_callromania_errornumbers">Nu s-au putut obtine numerele disponibile. Ai nevoie de o conexiune activa de Internet.</string>
+	<!-- //MOD 1.0.4 -->
+	<string name="w_callromania_smsto">Catre: </string>
+	<string name="w_callromania_add">Adauga</string>
+	<string name="w_callromania_remove">Sterge</string>
+	<string name="w_callromania_password2">Introdu parola din nou</string>
+	<string name="w_callromania_passwordsdontmatch">Parolele nu se potrivesc</string>
+	<string name="w_callromania_invalidnumber">Doar numere de mobil din România!</string>
+	<string name="w_callromania_smsstatus">Au fost trimise $num$ mesaje.</string>
+	<string name="w_callromania_smsstatus_singular">A fost trimis $num$ mesaj.</string>
+	<string name="w_callromania_expiration">Data expirare:</string>	
+	<string name="w_callromania_buycredit">Cumpara credit</string>
+	<!-- //MOD 1.0.5 -->
+	<string name="w_callromania_selectvalue">Alege valoarea dorita:</string>
+	<string name="w_callromania_info1">
+		Trimite un SMS la numarul 7425 (numar disponibil din retelele Orange si Vodafone Romania) cu textul:\nCupon_CREDIT_ _NUMBER_\n\nCostul acestui SMS este de 0,05 EUR + TVA.\n\nVei primi un SMS de confirmare a comenzi. Dupa ce primesti acest SMS, trebuie sa trimiti un nou SMS la 7425 cu textul DA, pentru confirmarea platii.\n\nAl doilea SMS costa 0,05 EUR + TVA la care se adauga costul cuponului comandat, _CREDIT_ EUR + TVA.\n\n
+	</string>
+	<string name="w_callromania_sendcreditsms">Trimite acum SMS pentru _CREDIT_ EUR</string>
+	<string name="w_callromania_info2">* Fiecare plata prin SMS creste valabilitatea contului cu 12 luni de la data achizitiei.</string>
+	<string name="w_callromania_evolio">* Creeaza un cont callRomania si primesti 5 EUR credit cadou de la Evolio</string>
+	<!-- //MOD 1.0.7 -->
+	<string name="w_callromania_about">Dezvoltat de Alexandru Dragutu\nBazat pe aplicatia GPL CSipSimple\n(http://csipsimple.googlecode.com rev.2470)</string>
+	<!-- //MOD 1.0.8 -->
+	<string name="w_callromania_pleasewait">Asteptati...</string>	
+</resources>
Index: CSipSimple/res/values-ro/wizard_common_strings.xml
===================================================================
--- CSipSimple/res/values-ro/wizard_common_strings.xml	(revision 2470)
+++ CSipSimple/res/values-ro/wizard_common_strings.xml	(working copy)
@@ -1,4 +1,5 @@
 <?xml version='1.0' encoding='UTF-8'?>
+<!-- //MOD 1.0.4 -->
 <resources>
   <string name="w_common_display_name">Nume cont</string>
   <string name="w_common_display_name_desc">Numele acestui cont</string>
@@ -9,4 +10,9 @@
   <string name="w_common_password_desc">Parola pentru contul dvs</string>
   <string name="w_common_server">Server</string>
   <string name="w_common_server_desc">SIP server /IP[:port]</string>
+  <string name="create_account">Cont nou</string>
+  <string name="already_have_account">Autentificare</string>
+  <string name="first_name">Prenume</string>
+  <string name="last_name">Nume</string>
+  <string name="email_address">Adresă email</string>
 </resources>
Index: CSipSimple/res/values/api_strings.xml
===================================================================
--- CSipSimple/res/values/api_strings.xml	(revision 2470)
+++ CSipSimple/res/values/api_strings.xml	(working copy)
@@ -7,7 +7,7 @@
 
 <resources>
 
-    <string name="app_name">CSipSimple</string>
+    <string name="app_name">callRomania</string>
     <string name="permlab_useSip">Use sip</string>
     <string name="permdesc_useSip">Place SIP calls, send SIP messages</string>
     <string name="permlab_configureSip">Full access to SIP Accounts/Calls/Messages</string>
Index: CSipSimple/res/values/wizard_basic_strings.xml
===================================================================
--- CSipSimple/res/values/wizard_basic_strings.xml	(revision 2470)
+++ CSipSimple/res/values/wizard_basic_strings.xml	(working copy)
@@ -19,7 +19,7 @@
  -->
 <resources>
 <string name="w_basic_username">User</string>
-<string name="w_basic_username_desc">Account name / Login (do not write the @sip.server)</string>
+<string name="w_basic_username_desc">Your email address</string>
 <string name="w_basic_password">Password</string>
 <string name="w_basic_password_desc">Password to access your account</string>
 
Index: CSipSimple/res/values/wizard_callromania_strings.xml
===================================================================
--- CSipSimple/res/values/wizard_callromania_strings.xml	(revision 0)
+++ CSipSimple/res/values/wizard_callromania_strings.xml	(working copy)
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- //MOD.0.4 -->
+<resources>
+    <string name="w_callromania_title">callRomania</string>
+    <string name="w_callromania_findnumber">Choose a number</string>
+    <string name="w_callromania_emptyfield">Empty</string>
+    <string name="w_callromania_hint">Select region to view available phone numbers:</string>
+    <string name="w_callromania_choose">Select a phone number:</string>
+    <string name="w_callromania_error">Error creating an account. Please try again.</string>
+    <string name="w_callromania_username">User</string>
+	<string name="w_callromania_username_desc">Your email address</string>
+	<string name="w_callromania_password">Password</string>
+	<string name="w_callromania_password_desc">Password to access your account</string>
+	<string name="w_callromania_loginfailed">Email or password incorrect. Please try again.</string>
+	<string name="w_callromania_nointernet">Error connecting. You need an active Internet connection.</string>
+	<string name="w_callromania_errornumbers">Error retrieving available numbers. You need an active Internet connection.</string>
+	<!-- //MOD 1.0.4 -->
+	<string name="w_callromania_smsto">To: </string>
+	<string name="w_callromania_add">Add</string>
+	<string name="w_callromania_remove">Remove</string>
+	<string name="w_callromania_password2">Enter password again</string>
+	<string name="w_callromania_passwordsdontmatch">Passwords don\'t match</string>
+	<string name="w_callromania_invalidnumber">Only Romanian mobile numbers are allowed!</string>
+	<string name="w_callromania_smsstatus">$num$ messages were sent successfully.</string>
+	<string name="w_callromania_smsstatus_singular">$num$ message was sent successfully.</string>
+	<string name="w_callromania_expiration">Expiration date:</string>
+	<string name="w_callromania_buycredit">Buy credit</string>
+	<!-- //MOD 1.0.5 -->
+	<string name="w_callromania_selectvalue">Select the value:</string>
+	<string name="w_callromania_info1">
+		Send an SMS to 7425 (number available from Orange and Vodafone Romania mobile networks) with the text:\nCupon_CREDIT_ _NUMBER_\n\nCost of this SMS is 0,05 EUR + VAT\n\nYou will receive an order confirmation SMS. After you receive this SMS, you have to send a new SMS to 7425 with text DA, for payment confirmation.\n\nThe second SMS costs 0,05 EUR + VAT plus the cost of the coupon ordered, _CREDIT_ EUR + VAT.
+	</string>
+	<string name="w_callromania_sendcreditsms">Send now an SMS for _CREDIT_ EUR</string>
+	<string name="w_callromania_info2">* Each SMS payment increases the account validity with 12 months from purchase date.</string>
+	<string name="w_callromania_evolio">* Create a callRomania account and receive 5 EUR credit from Evolio</string>
+	<!-- //MOD 1.0.7 -->
+	<string name="w_callromania_about">Developed by Alexandru Dragutu\nBased on GPL application CSipSimple\n(http://csipsimple.googlecode.com rev.2470)</string>
+	<!-- //MOD 1.0.8 -->
+	<string name="w_callromania_pleasewait">Please wait...</string>
+</resources>
Index: CSipSimple/src/com/android/vending/billing/IInAppBillingService.aidl
===================================================================
--- CSipSimple/src/com/android/vending/billing/IInAppBillingService.aidl	(revision 0)
+++ CSipSimple/src/com/android/vending/billing/IInAppBillingService.aidl	(working copy)
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.vending.billing;
+
+import android.os.Bundle;
+
+/**
+ * InAppBillingService is the service that provides in-app billing version 3 and beyond.
+ * This service provides the following features:
+ * 1. Provides a new API to get details of in-app items published for the app including
+ *    price, type, title and description.
+ * 2. The purchase flow is synchronous and purchase information is available immediately
+ *    after it completes.
+ * 3. Purchase information of in-app purchases is maintained within the Google Play system
+ *    till the purchase is consumed.
+ * 4. An API to consume a purchase of an inapp item. All purchases of one-time
+ *    in-app items are consumable and thereafter can be purchased again.
+ * 5. An API to get current purchases of the user immediately. This will not contain any
+ *    consumed purchases.
+ *
+ * All calls will give a response code with the following possible values
+ * RESULT_OK = 0 - success
+ * RESULT_USER_CANCELED = 1 - user pressed back or canceled a dialog
+ * RESULT_BILLING_UNAVAILABLE = 3 - this billing API version is not supported for the type requested
+ * RESULT_ITEM_UNAVAILABLE = 4 - requested SKU is not available for purchase
+ * RESULT_DEVELOPER_ERROR = 5 - invalid arguments provided to the API
+ * RESULT_ERROR = 6 - Fatal error during the API action
+ * RESULT_ITEM_ALREADY_OWNED = 7 - Failure to purchase since item is already owned
+ * RESULT_ITEM_NOT_OWNED = 8 - Failure to consume since item is not owned
+ */
+interface IInAppBillingService {
+    /**
+     * Checks support for the requested billing API version, package and in-app type.
+     * Minimum API version supported by this interface is 3.
+     * @param apiVersion the billing version which the app is using
+     * @param packageName the package name of the calling app
+     * @param type type of the in-app item being purchased "inapp" for one-time purchases
+     *        and "subs" for subscription.
+     * @return RESULT_OK(0) on success, corresponding result code on failures
+     */
+    int isBillingSupported(int apiVersion, String packageName, String type);
+
+    /**
+     * Provides details of a list of SKUs
+     * Given a list of SKUs of a valid type in the skusBundle, this returns a bundle
+     * with a list JSON strings containing the productId, price, title and description.
+     * This API can be called with a maximum of 20 SKUs.
+     * @param apiVersion billing API version that the Third-party is using
+     * @param packageName the package name of the calling app
+     * @param skusBundle bundle containing a StringArrayList of SKUs with key "ITEM_ID_LIST"
+     * @return Bundle containing the following key-value pairs
+     *         "RESPONSE_CODE" with int value, RESULT_OK(0) if success, other response codes on
+     *              failure as listed above.
+     *         "DETAILS_LIST" with a StringArrayList containing purchase information
+     *              in JSON format similar to:
+     *              '{ "productId" : "exampleSku", "type" : "inapp", "price" : "$5.00",
+     *                 "title : "Example Title", "description" : "This is an example description" }'
+     */
+    Bundle getSkuDetails(int apiVersion, String packageName, String type, in Bundle skusBundle);
+
+    /**
+     * Returns a pending intent to launch the purchase flow for an in-app item by providing a SKU,
+     * the type, a unique purchase token and an optional developer payload.
+     * @param apiVersion billing API version that the app is using
+     * @param packageName package name of the calling app
+     * @param sku the SKU of the in-app item as published in the developer console
+     * @param type the type of the in-app item ("inapp" for one-time purchases
+     *        and "subs" for subscription).
+     * @param developerPayload optional argument to be sent back with the purchase information
+     * @return Bundle containing the following key-value pairs
+     *         "RESPONSE_CODE" with int value, RESULT_OK(0) if success, other response codes on
+     *              failure as listed above.
+     *         "BUY_INTENT" - PendingIntent to start the purchase flow
+     *
+     * The Pending intent should be launched with startIntentSenderForResult. When purchase flow
+     * has completed, the onActivityResult() will give a resultCode of OK or CANCELED.
+     * If the purchase is successful, the result data will contain the following key-value pairs
+     *         "RESPONSE_CODE" with int value, RESULT_OK(0) if success, other response codes on
+     *              failure as listed above.
+     *         "INAPP_PURCHASE_DATA" - String in JSON format similar to
+     *              '{"orderId":"12999763169054705758.1371079406387615",
+     *                "packageName":"com.example.app",
+     *                "productId":"exampleSku",
+     *                "purchaseTime":1345678900000,
+     *                "purchaseToken" : "122333444455555",
+     *                "developerPayload":"example developer payload" }'
+     *         "INAPP_DATA_SIGNATURE" - String containing the signature of the purchase data that
+     *                                  was signed with the private key of the developer
+     *                                  TODO: change this to app-specific keys.
+     */
+    Bundle getBuyIntent(int apiVersion, String packageName, String sku, String type,
+        String developerPayload);
+
+    /**
+     * Returns the current SKUs owned by the user of the type and package name specified along with
+     * purchase information and a signature of the data to be validated.
+     * This will return all SKUs that have been purchased in V3 and managed items purchased using
+     * V1 and V2 that have not been consumed.
+     * @param apiVersion billing API version that the app is using
+     * @param packageName package name of the calling app
+     * @param type the type of the in-app items being requested
+     *        ("inapp" for one-time purchases and "subs" for subscription).
+     * @param continuationToken to be set as null for the first call, if the number of owned
+     *        skus are too many, a continuationToken is returned in the response bundle.
+     *        This method can be called again with the continuation token to get the next set of
+     *        owned skus.
+     * @return Bundle containing the following key-value pairs
+     *         "RESPONSE_CODE" with int value, RESULT_OK(0) if success, other response codes on
+     *              failure as listed above.
+     *         "INAPP_PURCHASE_ITEM_LIST" - StringArrayList containing the list of SKUs
+     *         "INAPP_PURCHASE_DATA_LIST" - StringArrayList containing the purchase information
+     *         "INAPP_DATA_SIGNATURE_LIST"- StringArrayList containing the signatures
+     *                                      of the purchase information
+     *         "INAPP_CONTINUATION_TOKEN" - String containing a continuation token for the
+     *                                      next set of in-app purchases. Only set if the
+     *                                      user has more owned skus than the current list.
+     */
+    Bundle getPurchases(int apiVersion, String packageName, String type, String continuationToken);
+
+    /**
+     * Consume the last purchase of the given SKU. This will result in this item being removed
+     * from all subsequent responses to getPurchases() and allow re-purchase of this item.
+     * @param apiVersion billing API version that the app is using
+     * @param packageName package name of the calling app
+     * @param purchaseToken token in the purchase information JSON that identifies the purchase
+     *        to be consumed
+     * @return 0 if consumption succeeded. Appropriate error values for failures.
+     */
+    int consumePurchase(int apiVersion, String packageName, String purchaseToken);
+}
Index: CSipSimple/src/com/android/vending/billing/IInAppBillingService.aidl
===================================================================
--- CSipSimple/src/com/android/vending/billing/IInAppBillingService.aidl	(revision 0)
+++ CSipSimple/src/com/android/vending/billing/IInAppBillingService.aidl	(working copy)
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.vending.billing;
+
+import android.os.Bundle;
+
+/**
+ * InAppBillingService is the service that provides in-app billing version 3 and beyond.
+ * This service provides the following features:
+ * 1. Provides a new API to get details of in-app items published for the app including
+ *    price, type, title and description.
+ * 2. The purchase flow is synchronous and purchase information is available immediately
+ *    after it completes.
+ * 3. Purchase information of in-app purchases is maintained within the Google Play system
+ *    till the purchase is consumed.
+ * 4. An API to consume a purchase of an inapp item. All purchases of one-time
+ *    in-app items are consumable and thereafter can be purchased again.
+ * 5. An API to get current purchases of the user immediately. This will not contain any
+ *    consumed purchases.
+ *
+ * All calls will give a response code with the following possible values
+ * RESULT_OK = 0 - success
+ * RESULT_USER_CANCELED = 1 - user pressed back or canceled a dialog
+ * RESULT_BILLING_UNAVAILABLE = 3 - this billing API version is not supported for the type requested
+ * RESULT_ITEM_UNAVAILABLE = 4 - requested SKU is not available for purchase
+ * RESULT_DEVELOPER_ERROR = 5 - invalid arguments provided to the API
+ * RESULT_ERROR = 6 - Fatal error during the API action
+ * RESULT_ITEM_ALREADY_OWNED = 7 - Failure to purchase since item is already owned
+ * RESULT_ITEM_NOT_OWNED = 8 - Failure to consume since item is not owned
+ */
+interface IInAppBillingService {
+    /**
+     * Checks support for the requested billing API version, package and in-app type.
+     * Minimum API version supported by this interface is 3.
+     * @param apiVersion the billing version which the app is using
+     * @param packageName the package name of the calling app
+     * @param type type of the in-app item being purchased "inapp" for one-time purchases
+     *        and "subs" for subscription.
+     * @return RESULT_OK(0) on success, corresponding result code on failures
+     */
+    int isBillingSupported(int apiVersion, String packageName, String type);
+
+    /**
+     * Provides details of a list of SKUs
+     * Given a list of SKUs of a valid type in the skusBundle, this returns a bundle
+     * with a list JSON strings containing the productId, price, title and description.
+     * This API can be called with a maximum of 20 SKUs.
+     * @param apiVersion billing API version that the Third-party is using
+     * @param packageName the package name of the calling app
+     * @param skusBundle bundle containing a StringArrayList of SKUs with key "ITEM_ID_LIST"
+     * @return Bundle containing the following key-value pairs
+     *         "RESPONSE_CODE" with int value, RESULT_OK(0) if success, other response codes on
+     *              failure as listed above.
+     *         "DETAILS_LIST" with a StringArrayList containing purchase information
+     *              in JSON format similar to:
+     *              '{ "productId" : "exampleSku", "type" : "inapp", "price" : "$5.00",
+     *                 "title : "Example Title", "description" : "This is an example description" }'
+     */
+    Bundle getSkuDetails(int apiVersion, String packageName, String type, in Bundle skusBundle);
+
+    /**
+     * Returns a pending intent to launch the purchase flow for an in-app item by providing a SKU,
+     * the type, a unique purchase token and an optional developer payload.
+     * @param apiVersion billing API version that the app is using
+     * @param packageName package name of the calling app
+     * @param sku the SKU of the in-app item as published in the developer console
+     * @param type the type of the in-app item ("inapp" for one-time purchases
+     *        and "subs" for subscription).
+     * @param developerPayload optional argument to be sent back with the purchase information
+     * @return Bundle containing the following key-value pairs
+     *         "RESPONSE_CODE" with int value, RESULT_OK(0) if success, other response codes on
+     *              failure as listed above.
+     *         "BUY_INTENT" - PendingIntent to start the purchase flow
+     *
+     * The Pending intent should be launched with startIntentSenderForResult. When purchase flow
+     * has completed, the onActivityResult() will give a resultCode of OK or CANCELED.
+     * If the purchase is successful, the result data will contain the following key-value pairs
+     *         "RESPONSE_CODE" with int value, RESULT_OK(0) if success, other response codes on
+     *              failure as listed above.
+     *         "INAPP_PURCHASE_DATA" - String in JSON format similar to
+     *              '{"orderId":"12999763169054705758.1371079406387615",
+     *                "packageName":"com.example.app",
+     *                "productId":"exampleSku",
+     *                "purchaseTime":1345678900000,
+     *                "purchaseToken" : "122333444455555",
+     *                "developerPayload":"example developer payload" }'
+     *         "INAPP_DATA_SIGNATURE" - String containing the signature of the purchase data that
+     *                                  was signed with the private key of the developer
+     *                                  TODO: change this to app-specific keys.
+     */
+    Bundle getBuyIntent(int apiVersion, String packageName, String sku, String type,
+        String developerPayload);
+
+    /**
+     * Returns the current SKUs owned by the user of the type and package name specified along with
+     * purchase information and a signature of the data to be validated.
+     * This will return all SKUs that have been purchased in V3 and managed items purchased using
+     * V1 and V2 that have not been consumed.
+     * @param apiVersion billing API version that the app is using
+     * @param packageName package name of the calling app
+     * @param type the type of the in-app items being requested
+     *        ("inapp" for one-time purchases and "subs" for subscription).
+     * @param continuationToken to be set as null for the first call, if the number of owned
+     *        skus are too many, a continuationToken is returned in the response bundle.
+     *        This method can be called again with the continuation token to get the next set of
+     *        owned skus.
+     * @return Bundle containing the following key-value pairs
+     *         "RESPONSE_CODE" with int value, RESULT_OK(0) if success, other response codes on
+     *              failure as listed above.
+     *         "INAPP_PURCHASE_ITEM_LIST" - StringArrayList containing the list of SKUs
+     *         "INAPP_PURCHASE_DATA_LIST" - StringArrayList containing the purchase information
+     *         "INAPP_DATA_SIGNATURE_LIST"- StringArrayList containing the signatures
+     *                                      of the purchase information
+     *         "INAPP_CONTINUATION_TOKEN" - String containing a continuation token for the
+     *                                      next set of in-app purchases. Only set if the
+     *                                      user has more owned skus than the current list.
+     */
+    Bundle getPurchases(int apiVersion, String packageName, String type, String continuationToken);
+
+    /**
+     * Consume the last purchase of the given SKU. This will result in this item being removed
+     * from all subsequent responses to getPurchases() and allow re-purchase of this item.
+     * @param apiVersion billing API version that the app is using
+     * @param packageName package name of the calling app
+     * @param purchaseToken token in the purchase information JSON that identifies the purchase
+     *        to be consumed
+     * @return 0 if consumption succeeded. Appropriate error values for failures.
+     */
+    int consumePurchase(int apiVersion, String packageName, String purchaseToken);
+}
Index: CSipSimple/src/com/android/vending/billing/IInAppBillingService.aidl
===================================================================
--- CSipSimple/src/com/android/vending/billing/IInAppBillingService.aidl	(revision 0)
+++ CSipSimple/src/com/android/vending/billing/IInAppBillingService.aidl	(working copy)
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.vending.billing;
+
+import android.os.Bundle;
+
+/**
+ * InAppBillingService is the service that provides in-app billing version 3 and beyond.
+ * This service provides the following features:
+ * 1. Provides a new API to get details of in-app items published for the app including
+ *    price, type, title and description.
+ * 2. The purchase flow is synchronous and purchase information is available immediately
+ *    after it completes.
+ * 3. Purchase information of in-app purchases is maintained within the Google Play system
+ *    till the purchase is consumed.
+ * 4. An API to consume a purchase of an inapp item. All purchases of one-time
+ *    in-app items are consumable and thereafter can be purchased again.
+ * 5. An API to get current purchases of the user immediately. This will not contain any
+ *    consumed purchases.
+ *
+ * All calls will give a response code with the following possible values
+ * RESULT_OK = 0 - success
+ * RESULT_USER_CANCELED = 1 - user pressed back or canceled a dialog
+ * RESULT_BILLING_UNAVAILABLE = 3 - this billing API version is not supported for the type requested
+ * RESULT_ITEM_UNAVAILABLE = 4 - requested SKU is not available for purchase
+ * RESULT_DEVELOPER_ERROR = 5 - invalid arguments provided to the API
+ * RESULT_ERROR = 6 - Fatal error during the API action
+ * RESULT_ITEM_ALREADY_OWNED = 7 - Failure to purchase since item is already owned
+ * RESULT_ITEM_NOT_OWNED = 8 - Failure to consume since item is not owned
+ */
+interface IInAppBillingService {
+    /**
+     * Checks support for the requested billing API version, package and in-app type.
+     * Minimum API version supported by this interface is 3.
+     * @param apiVersion the billing version which the app is using
+     * @param packageName the package name of the calling app
+     * @param type type of the in-app item being purchased "inapp" for one-time purchases
+     *        and "subs" for subscription.
+     * @return RESULT_OK(0) on success, corresponding result code on failures
+     */
+    int isBillingSupported(int apiVersion, String packageName, String type);
+
+    /**
+     * Provides details of a list of SKUs
+     * Given a list of SKUs of a valid type in the skusBundle, this returns a bundle
+     * with a list JSON strings containing the productId, price, title and description.
+     * This API can be called with a maximum of 20 SKUs.
+     * @param apiVersion billing API version that the Third-party is using
+     * @param packageName the package name of the calling app
+     * @param skusBundle bundle containing a StringArrayList of SKUs with key "ITEM_ID_LIST"
+     * @return Bundle containing the following key-value pairs
+     *         "RESPONSE_CODE" with int value, RESULT_OK(0) if success, other response codes on
+     *              failure as listed above.
+     *         "DETAILS_LIST" with a StringArrayList containing purchase information
+     *              in JSON format similar to:
+     *              '{ "productId" : "exampleSku", "type" : "inapp", "price" : "$5.00",
+     *                 "title : "Example Title", "description" : "This is an example description" }'
+     */
+    Bundle getSkuDetails(int apiVersion, String packageName, String type, in Bundle skusBundle);
+
+    /**
+     * Returns a pending intent to launch the purchase flow for an in-app item by providing a SKU,
+     * the type, a unique purchase token and an optional developer payload.
+     * @param apiVersion billing API version that the app is using
+     * @param packageName package name of the calling app
+     * @param sku the SKU of the in-app item as published in the developer console
+     * @param type the type of the in-app item ("inapp" for one-time purchases
+     *        and "subs" for subscription).
+     * @param developerPayload optional argument to be sent back with the purchase information
+     * @return Bundle containing the following key-value pairs
+     *         "RESPONSE_CODE" with int value, RESULT_OK(0) if success, other response codes on
+     *              failure as listed above.
+     *         "BUY_INTENT" - PendingIntent to start the purchase flow
+     *
+     * The Pending intent should be launched with startIntentSenderForResult. When purchase flow
+     * has completed, the onActivityResult() will give a resultCode of OK or CANCELED.
+     * If the purchase is successful, the result data will contain the following key-value pairs
+     *         "RESPONSE_CODE" with int value, RESULT_OK(0) if success, other response codes on
+     *              failure as listed above.
+     *         "INAPP_PURCHASE_DATA" - String in JSON format similar to
+     *              '{"orderId":"12999763169054705758.1371079406387615",
+     *                "packageName":"com.example.app",
+     *                "productId":"exampleSku",
+     *                "purchaseTime":1345678900000,
+     *                "purchaseToken" : "122333444455555",
+     *                "developerPayload":"example developer payload" }'
+     *         "INAPP_DATA_SIGNATURE" - String containing the signature of the purchase data that
+     *                                  was signed with the private key of the developer
+     *                                  TODO: change this to app-specific keys.
+     */
+    Bundle getBuyIntent(int apiVersion, String packageName, String sku, String type,
+        String developerPayload);
+
+    /**
+     * Returns the current SKUs owned by the user of the type and package name specified along with
+     * purchase information and a signature of the data to be validated.
+     * This will return all SKUs that have been purchased in V3 and managed items purchased using
+     * V1 and V2 that have not been consumed.
+     * @param apiVersion billing API version that the app is using
+     * @param packageName package name of the calling app
+     * @param type the type of the in-app items being requested
+     *        ("inapp" for one-time purchases and "subs" for subscription).
+     * @param continuationToken to be set as null for the first call, if the number of owned
+     *        skus are too many, a continuationToken is returned in the response bundle.
+     *        This method can be called again with the continuation token to get the next set of
+     *        owned skus.
+     * @return Bundle containing the following key-value pairs
+     *         "RESPONSE_CODE" with int value, RESULT_OK(0) if success, other response codes on
+     *              failure as listed above.
+     *         "INAPP_PURCHASE_ITEM_LIST" - StringArrayList containing the list of SKUs
+     *         "INAPP_PURCHASE_DATA_LIST" - StringArrayList containing the purchase information
+     *         "INAPP_DATA_SIGNATURE_LIST"- StringArrayList containing the signatures
+     *                                      of the purchase information
+     *         "INAPP_CONTINUATION_TOKEN" - String containing a continuation token for the
+     *                                      next set of in-app purchases. Only set if the
+     *                                      user has more owned skus than the current list.
+     */
+    Bundle getPurchases(int apiVersion, String packageName, String type, String continuationToken);
+
+    /**
+     * Consume the last purchase of the given SKU. This will result in this item being removed
+     * from all subsequent responses to getPurchases() and allow re-purchase of this item.
+     * @param apiVersion billing API version that the app is using
+     * @param packageName package name of the calling app
+     * @param purchaseToken token in the purchase information JSON that identifies the purchase
+     *        to be consumed
+     * @return 0 if consumption succeeded. Appropriate error values for failures.
+     */
+    int consumePurchase(int apiVersion, String packageName, String purchaseToken);
+}
Index: CSipSimple/src/com/android/vending/billing/IInAppBillingService.aidl
===================================================================
--- CSipSimple/src/com/android/vending/billing/IInAppBillingService.aidl	(revision 0)
+++ CSipSimple/src/com/android/vending/billing/IInAppBillingService.aidl	(working copy)
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.vending.billing;
+
+import android.os.Bundle;
+
+/**
+ * InAppBillingService is the service that provides in-app billing version 3 and beyond.
+ * This service provides the following features:
+ * 1. Provides a new API to get details of in-app items published for the app including
+ *    price, type, title and description.
+ * 2. The purchase flow is synchronous and purchase information is available immediately
+ *    after it completes.
+ * 3. Purchase information of in-app purchases is maintained within the Google Play system
+ *    till the purchase is consumed.
+ * 4. An API to consume a purchase of an inapp item. All purchases of one-time
+ *    in-app items are consumable and thereafter can be purchased again.
+ * 5. An API to get current purchases of the user immediately. This will not contain any
+ *    consumed purchases.
+ *
+ * All calls will give a response code with the following possible values
+ * RESULT_OK = 0 - success
+ * RESULT_USER_CANCELED = 1 - user pressed back or canceled a dialog
+ * RESULT_BILLING_UNAVAILABLE = 3 - this billing API version is not supported for the type requested
+ * RESULT_ITEM_UNAVAILABLE = 4 - requested SKU is not available for purchase
+ * RESULT_DEVELOPER_ERROR = 5 - invalid arguments provided to the API
+ * RESULT_ERROR = 6 - Fatal error during the API action
+ * RESULT_ITEM_ALREADY_OWNED = 7 - Failure to purchase since item is already owned
+ * RESULT_ITEM_NOT_OWNED = 8 - Failure to consume since item is not owned
+ */
+interface IInAppBillingService {
+    /**
+     * Checks support for the requested billing API version, package and in-app type.
+     * Minimum API version supported by this interface is 3.
+     * @param apiVersion the billing version which the app is using
+     * @param packageName the package name of the calling app
+     * @param type type of the in-app item being purchased "inapp" for one-time purchases
+     *        and "subs" for subscription.
+     * @return RESULT_OK(0) on success, corresponding result code on failures
+     */
+    int isBillingSupported(int apiVersion, String packageName, String type);
+
+    /**
+     * Provides details of a list of SKUs
+     * Given a list of SKUs of a valid type in the skusBundle, this returns a bundle
+     * with a list JSON strings containing the productId, price, title and description.
+     * This API can be called with a maximum of 20 SKUs.
+     * @param apiVersion billing API version that the Third-party is using
+     * @param packageName the package name of the calling app
+     * @param skusBundle bundle containing a StringArrayList of SKUs with key "ITEM_ID_LIST"
+     * @return Bundle containing the following key-value pairs
+     *         "RESPONSE_CODE" with int value, RESULT_OK(0) if success, other response codes on
+     *              failure as listed above.
+     *         "DETAILS_LIST" with a StringArrayList containing purchase information
+     *              in JSON format similar to:
+     *              '{ "productId" : "exampleSku", "type" : "inapp", "price" : "$5.00",
+     *                 "title : "Example Title", "description" : "This is an example description" }'
+     */
+    Bundle getSkuDetails(int apiVersion, String packageName, String type, in Bundle skusBundle);
+
+    /**
+     * Returns a pending intent to launch the purchase flow for an in-app item by providing a SKU,
+     * the type, a unique purchase token and an optional developer payload.
+     * @param apiVersion billing API version that the app is using
+     * @param packageName package name of the calling app
+     * @param sku the SKU of the in-app item as published in the developer console
+     * @param type the type of the in-app item ("inapp" for one-time purchases
+     *        and "subs" for subscription).
+     * @param developerPayload optional argument to be sent back with the purchase information
+     * @return Bundle containing the following key-value pairs
+     *         "RESPONSE_CODE" with int value, RESULT_OK(0) if success, other response codes on
+     *              failure as listed above.
+     *         "BUY_INTENT" - PendingIntent to start the purchase flow
+     *
+     * The Pending intent should be launched with startIntentSenderForResult. When purchase flow
+     * has completed, the onActivityResult() will give a resultCode of OK or CANCELED.
+     * If the purchase is successful, the result data will contain the following key-value pairs
+     *         "RESPONSE_CODE" with int value, RESULT_OK(0) if success, other response codes on
+     *              failure as listed above.
+     *         "INAPP_PURCHASE_DATA" - String in JSON format similar to
+     *              '{"orderId":"12999763169054705758.1371079406387615",
+     *                "packageName":"com.example.app",
+     *                "productId":"exampleSku",
+     *                "purchaseTime":1345678900000,
+     *                "purchaseToken" : "122333444455555",
+     *                "developerPayload":"example developer payload" }'
+     *         "INAPP_DATA_SIGNATURE" - String containing the signature of the purchase data that
+     *                                  was signed with the private key of the developer
+     *                                  TODO: change this to app-specific keys.
+     */
+    Bundle getBuyIntent(int apiVersion, String packageName, String sku, String type,
+        String developerPayload);
+
+    /**
+     * Returns the current SKUs owned by the user of the type and package name specified along with
+     * purchase information and a signature of the data to be validated.
+     * This will return all SKUs that have been purchased in V3 and managed items purchased using
+     * V1 and V2 that have not been consumed.
+     * @param apiVersion billing API version that the app is using
+     * @param packageName package name of the calling app
+     * @param type the type of the in-app items being requested
+     *        ("inapp" for one-time purchases and "subs" for subscription).
+     * @param continuationToken to be set as null for the first call, if the number of owned
+     *        skus are too many, a continuationToken is returned in the response bundle.
+     *        This method can be called again with the continuation token to get the next set of
+     *        owned skus.
+     * @return Bundle containing the following key-value pairs
+     *         "RESPONSE_CODE" with int value, RESULT_OK(0) if success, other response codes on
+     *              failure as listed above.
+     *         "INAPP_PURCHASE_ITEM_LIST" - StringArrayList containing the list of SKUs
+     *         "INAPP_PURCHASE_DATA_LIST" - StringArrayList containing the purchase information
+     *         "INAPP_DATA_SIGNATURE_LIST"- StringArrayList containing the signatures
+     *                                      of the purchase information
+     *         "INAPP_CONTINUATION_TOKEN" - String containing a continuation token for the
+     *                                      next set of in-app purchases. Only set if the
+     *                                      user has more owned skus than the current list.
+     */
+    Bundle getPurchases(int apiVersion, String packageName, String type, String continuationToken);
+
+    /**
+     * Consume the last purchase of the given SKU. This will result in this item being removed
+     * from all subsequent responses to getPurchases() and allow re-purchase of this item.
+     * @param apiVersion billing API version that the app is using
+     * @param packageName package name of the calling app
+     * @param purchaseToken token in the purchase information JSON that identifies the purchase
+     *        to be consumed
+     * @return 0 if consumption succeeded. Appropriate error values for failures.
+     */
+    int consumePurchase(int apiVersion, String packageName, String purchaseToken);
+}
Index: CSipSimple/src/com/csipsimple/models/Filter.java
===================================================================
--- CSipSimple/src/com/csipsimple/models/Filter.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/models/Filter.java	(working copy)
@@ -29,7 +29,7 @@
 import android.text.TextUtils;
 import android.util.SparseIntArray;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.utils.Log;
 import com.csipsimple.utils.bluetooth.BluetoothWrapper;
Index: CSipSimple/src/com/csipsimple/pjsip/PjSipService.java
===================================================================
--- CSipSimple/src/com/csipsimple/pjsip/PjSipService.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/pjsip/PjSipService.java	(working copy)
@@ -39,7 +39,7 @@
 import android.view.KeyEvent;
 import android.view.SurfaceView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipCallSession;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipManager;
Index: CSipSimple/src/com/csipsimple/pjsip/UAStateReceiver.java
===================================================================
--- CSipSimple/src/com/csipsimple/pjsip/UAStateReceiver.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/pjsip/UAStateReceiver.java	(working copy)
@@ -40,7 +40,7 @@
 import android.text.TextUtils;
 import android.util.SparseArray;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipCallSession;
 import com.csipsimple.api.SipCallSession.StatusCode;
 import com.csipsimple.api.SipConfigManager;
Index: CSipSimple/src/com/csipsimple/plugins/telephony/CallHandler.java
===================================================================
--- CSipSimple/src/com/csipsimple/plugins/telephony/CallHandler.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/plugins/telephony/CallHandler.java	(working copy)
@@ -33,7 +33,7 @@
 import android.net.Uri;
 import android.os.Bundle;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.utils.CallHandlerPlugin;
 import com.csipsimple.utils.Log;
Index: CSipSimple/src/com/csipsimple/service/Downloader.java
===================================================================
--- CSipSimple/src/com/csipsimple/service/Downloader.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/service/Downloader.java	(working copy)
@@ -48,7 +48,7 @@
 import android.view.View;
 import android.widget.RemoteViews;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.ui.SipHome;
 import com.csipsimple.utils.Log;
 import com.csipsimple.utils.MD5;
Index: CSipSimple/src/com/csipsimple/service/SipNotifications.java
===================================================================
--- CSipSimple/src/com/csipsimple/service/SipNotifications.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/service/SipNotifications.java	(working copy)
@@ -39,7 +39,7 @@
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipCallSession;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.api.SipMessage;
Index: CSipSimple/src/com/csipsimple/service/SipService.java
===================================================================
--- CSipSimple/src/com/csipsimple/service/SipService.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/service/SipService.java	(working copy)
@@ -52,7 +52,7 @@
 import android.view.SurfaceView;
 import android.widget.Toast;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.ISipConfiguration;
 import com.csipsimple.api.ISipService;
 import com.csipsimple.api.MediaState;
Index: CSipSimple/src/com/csipsimple/ui/account/AccountsChooserListActivity.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/account/AccountsChooserListActivity.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/account/AccountsChooserListActivity.java	(working copy)
@@ -24,7 +24,7 @@
 import android.os.Bundle;
 
 import com.actionbarsherlock.app.SherlockFragmentActivity;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.ui.account.AccountsChooserListFragment.OnAccountClickListener;
 
 public abstract class AccountsChooserListActivity extends SherlockFragmentActivity implements OnAccountClickListener {
Index: CSipSimple/src/com/csipsimple/ui/account/AccountsChooserListFragment.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/account/AccountsChooserListFragment.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/account/AccountsChooserListFragment.java	(working copy)
@@ -33,7 +33,7 @@
 import android.widget.ListView;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.CallHandlerPlugin;
 import com.csipsimple.widgets.CSSListFragment;
Index: CSipSimple/src/com/csipsimple/ui/account/AccountsEditList.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/account/AccountsEditList.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/account/AccountsEditList.java	(working copy)
@@ -25,7 +25,7 @@
 
 import com.actionbarsherlock.app.SherlockFragmentActivity;
 import com.actionbarsherlock.view.MenuItem;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.utils.Compatibility;
 
 public class AccountsEditList extends SherlockFragmentActivity {
Index: CSipSimple/src/com/csipsimple/ui/account/AccountsEditListAdapter.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/account/AccountsEditListAdapter.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/account/AccountsEditListAdapter.java	(working copy)
@@ -30,7 +30,7 @@
 import android.widget.ImageView;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.AccountListUtils;
 import com.csipsimple.utils.AccountListUtils.AccountStatusDisplay;
Index: CSipSimple/src/com/csipsimple/ui/account/AccountsEditListFragment.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/account/AccountsEditListFragment.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/account/AccountsEditListFragment.java	(working copy)
@@ -54,7 +54,7 @@
 import com.actionbarsherlock.view.Menu;
 import com.actionbarsherlock.view.MenuInflater;
 import com.actionbarsherlock.view.MenuItem;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.backup.SipProfileJson;
 import com.csipsimple.ui.account.AccountsEditListAdapter.AccountRowTag;
Index: CSipSimple/src/com/csipsimple/ui/calllog/CallDetailHistoryAdapter.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/calllog/CallDetailHistoryAdapter.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/calllog/CallDetailHistoryAdapter.java	(working copy)
@@ -36,7 +36,7 @@
 import android.widget.BaseAdapter;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 
 /**
  * Adapter for a ListView containing history items from the details of a call.
Index: CSipSimple/src/com/csipsimple/ui/calllog/CallLogAdapter.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/calllog/CallLogAdapter.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/calllog/CallLogAdapter.java	(working copy)
@@ -31,7 +31,7 @@
 import android.view.View;
 import android.view.ViewGroup;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.api.SipUri;
 import com.csipsimple.models.CallerInfo;
Index: CSipSimple/src/com/csipsimple/ui/calllog/CallLogDetailsFragment.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/calllog/CallLogDetailsFragment.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/calllog/CallLogDetailsFragment.java	(working copy)
@@ -42,7 +42,7 @@
 import android.widget.TextView;
 
 import com.actionbarsherlock.app.SherlockFragment;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.api.SipUri;
Index: CSipSimple/src/com/csipsimple/ui/calllog/CallLogListFragment.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/calllog/CallLogListFragment.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/calllog/CallLogListFragment.java	(working copy)
@@ -46,7 +46,7 @@
 import com.actionbarsherlock.view.MenuInflater;
 import com.actionbarsherlock.view.MenuItem;
 import com.actionbarsherlock.view.MenuItem.OnMenuItemClickListener;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.api.SipUri;
Index: CSipSimple/src/com/csipsimple/ui/calllog/CallLogListItemHelper.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/calllog/CallLogListItemHelper.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/calllog/CallLogListItemHelper.java	(working copy)
@@ -31,7 +31,7 @@
 import android.text.TextUtils;
 import android.view.View;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.utils.Theme;
 
 /**
Index: CSipSimple/src/com/csipsimple/ui/calllog/CallLogListItemViews.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/calllog/CallLogListItemViews.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/calllog/CallLogListItemViews.java	(working copy)
@@ -28,7 +28,7 @@
 import android.view.View;
 import android.widget.ImageView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.widgets.contactbadge.QuickContactBadge;
 
 /**
Index: CSipSimple/src/com/csipsimple/ui/calllog/CallTypeIconsView.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/calllog/CallTypeIconsView.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/calllog/CallTypeIconsView.java	(working copy)
@@ -32,7 +32,7 @@
 import android.util.AttributeSet;
 import android.view.View;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.utils.Theme;
 
 import java.util.ArrayList;
Index: CSipSimple/src/com/csipsimple/ui/calllog/PhoneCallDetailsHelper.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/calllog/PhoneCallDetailsHelper.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/calllog/PhoneCallDetailsHelper.java	(working copy)
@@ -35,7 +35,7 @@
 import android.view.View;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipUri;
 
 /**
Index: CSipSimple/src/com/csipsimple/ui/calllog/PhoneCallDetailsViews.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/calllog/PhoneCallDetailsViews.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/calllog/PhoneCallDetailsViews.java	(working copy)
@@ -29,7 +29,7 @@
 import android.view.View;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 
 /**
  * Encapsulates the views that are used to display the details of a phone call
Index: CSipSimple/src/com/csipsimple/ui/dialpad/DialerFragment.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/dialpad/DialerFragment.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/dialpad/DialerFragment.java	(working copy)
@@ -66,7 +66,7 @@
 import com.actionbarsherlock.view.MenuInflater;
 import com.actionbarsherlock.view.MenuItem;
 import com.actionbarsherlock.view.MenuItem.OnMenuItemClickListener;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.ISipService;
 import com.csipsimple.api.SipCallSession;
 import com.csipsimple.api.SipConfigManager;
@@ -89,6 +89,7 @@
 import com.csipsimple.widgets.DialerCallBar.OnDialActionListener;
 import com.csipsimple.widgets.Dialpad;
 import com.csipsimple.widgets.Dialpad.OnDialKeyListener;
+import com.csipsimple.wizards.CallRomaniaSMS;
 
 public class DialerFragment extends SherlockFragment implements OnClickListener, OnLongClickListener,
         OnDialKeyListener, TextWatcher, OnDialActionListener, ViewPagerVisibilityListener, OnKeyListener,
@@ -297,7 +298,9 @@
             }
             
             // Additional button
-            subV = v.findViewById(R.id.dialVideoButton);
+            //MOD 1.0.4 
+            //subV = v.findViewById(R.id.dialVideoButton);
+            subV = v.findViewById(R.id.composeSMSButton);
             if(subV != null) {
                 t.applyBackgroundDrawable(subV, "btn_add_action");
                 t.applyLayoutMargin(subV, "btn_dial_add_margin");
@@ -637,6 +640,39 @@
             }
         });
     }
+    
+    @Override
+    public void composeSMS()
+    {
+    	 //MOD 1.0.4 
+    	 String toCall = PhoneNumberUtils.stripSeparators(digits.getText().toString());
+         
+                  
+         SipProfile acc = null;
+         
+         try
+         {
+        	 acc = SipProfile.getProfileFromDbId
+	              	(
+	              		getActivity().getApplicationContext(), 
+	              		accountChooserButton.getSelectedAccount().id, 
+	              		new String[] { "data", "username", "id" }
+	          		);
+         }
+         catch(Exception e)
+         {
+        	 acc = null;
+         }
+         
+         if (acc == null)
+        	 return;
+         
+         CallRomaniaSMS.initAccount(acc);
+         
+         Intent i = new Intent(getActivity().getApplicationContext(), CallRomaniaSMS.class);
+         i.putExtra("init_number", PhoneNumberUtils.stripSeparators(digits.getText().toString()));
+         getActivity().startActivity(i);
+    }
 
     @Override
     public void placeCall() {
Index: CSipSimple/src/com/csipsimple/ui/dialpad/DialerLayout.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/dialpad/DialerLayout.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/dialpad/DialerLayout.java	(working copy)
@@ -27,7 +27,7 @@
 import android.view.View;
 import android.widget.LinearLayout;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.utils.Log;
 
 public class DialerLayout extends LinearLayout {
Index: CSipSimple/src/com/csipsimple/ui/dialpad/DigitsEditText.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/dialpad/DigitsEditText.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/dialpad/DigitsEditText.java	(working copy)
@@ -32,7 +32,7 @@
 import android.widget.EditText;
 
 import com.actionbarsherlock.internal.utils.UtilityWrapper;
-import com.csipsimple.R;
+import ro.callromania.R;
 
 import java.lang.reflect.Method;
 
Index: CSipSimple/src/com/csipsimple/ui/favorites/FavAdapter.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/favorites/FavAdapter.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/favorites/FavAdapter.java	(working copy)
@@ -49,7 +49,7 @@
 import com.actionbarsherlock.internal.view.menu.MenuBuilder.Callback;
 import com.actionbarsherlock.view.MenuInflater;
 import com.actionbarsherlock.view.MenuItem;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.api.SipUri;
Index: CSipSimple/src/com/csipsimple/ui/favorites/FavListFragment.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/favorites/FavListFragment.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/favorites/FavListFragment.java	(working copy)
@@ -27,7 +27,7 @@
 import android.view.View;
 import android.widget.ListView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.ui.SipHome.ViewPagerVisibilityListener;
 import com.csipsimple.widgets.CSSListFragment;
 
Index: CSipSimple/src/com/csipsimple/ui/favorites/PresenceStatusSpinner.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/favorites/PresenceStatusSpinner.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/favorites/PresenceStatusSpinner.java	(working copy)
@@ -39,7 +39,7 @@
 import android.widget.Spinner;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.ISipService;
 import com.csipsimple.api.SipManager.PresenceStatus;
 import com.csipsimple.api.SipProfile;
Index: CSipSimple/src/com/csipsimple/ui/filters/AccountFilters.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/filters/AccountFilters.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/filters/AccountFilters.java	(working copy)
@@ -28,7 +28,7 @@
 import com.actionbarsherlock.app.ActionBar;
 import com.actionbarsherlock.app.SherlockFragmentActivity;
 import com.actionbarsherlock.view.MenuItem;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.Compatibility;
 import com.csipsimple.utils.Log;
Index: CSipSimple/src/com/csipsimple/ui/filters/AccountFiltersListAdapter.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/filters/AccountFiltersListAdapter.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/filters/AccountFiltersListAdapter.java	(working copy)
@@ -28,7 +28,7 @@
 import android.widget.ImageView;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.models.Filter;
 
 public class AccountFiltersListAdapter extends ResourceCursorAdapter {
Index: CSipSimple/src/com/csipsimple/ui/filters/AccountFiltersListFragment.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/filters/AccountFiltersListFragment.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/filters/AccountFiltersListFragment.java	(working copy)
@@ -49,7 +49,7 @@
 import com.actionbarsherlock.view.Menu;
 import com.actionbarsherlock.view.MenuInflater;
 import com.actionbarsherlock.view.MenuItem;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.models.Filter;
Index: CSipSimple/src/com/csipsimple/ui/filters/EditFilter.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/filters/EditFilter.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/filters/EditFilter.java	(working copy)
@@ -37,7 +37,7 @@
 import android.widget.EditText;
 import android.widget.Spinner;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.models.Filter;
Index: CSipSimple/src/com/csipsimple/ui/help/Faq.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/help/Faq.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/help/Faq.java	(working copy)
@@ -33,7 +33,7 @@
 import android.widget.LinearLayout;
 
 import com.actionbarsherlock.app.SherlockDialogFragment;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.utils.CustomDistribution;
 
 public class Faq extends SherlockDialogFragment {
Index: CSipSimple/src/com/csipsimple/ui/help/Help.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/help/Help.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/help/Help.java	(working copy)
@@ -21,6 +21,9 @@
 
 package com.csipsimple.ui.help;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.app.Dialog;
@@ -29,7 +32,9 @@
 import android.content.Intent;
 import android.net.Uri;
 import android.os.Bundle;
+import android.text.Html;
 import android.text.TextUtils;
+import android.text.method.LinkMovementMethod;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
@@ -40,7 +45,7 @@
 import android.widget.TextView;
 
 import com.actionbarsherlock.app.SherlockDialogFragment;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.utils.CollectLogs;
@@ -148,6 +153,7 @@
         lv.setAdapter(new HelpArrayAdapter(getActivity(), items));
         
         TextView tv = (TextView) v.findViewById(android.R.id.text1);
+        tv.setMovementMethod(LinkMovementMethod.getInstance());
         tv.setText(CollectLogs.getApplicationInfo(getActivity()));
         
         return v;
Index: CSipSimple/src/com/csipsimple/ui/help/Legal.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/help/Legal.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/help/Legal.java	(working copy)
@@ -31,7 +31,7 @@
 import android.webkit.WebView;
 
 import com.actionbarsherlock.app.SherlockDialogFragment;
-import com.csipsimple.R;
+import ro.callromania.R;
 
 public class Legal extends SherlockDialogFragment {
 
Index: CSipSimple/src/com/csipsimple/ui/incall/DtmfDialogFragment.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/incall/DtmfDialogFragment.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/incall/DtmfDialogFragment.java	(working copy)
@@ -33,7 +33,7 @@
 import android.widget.TextView;
 
 import com.actionbarsherlock.app.SherlockDialogFragment;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.utils.Log;
 import com.csipsimple.widgets.Dialpad;
 import com.csipsimple.widgets.Dialpad.OnDialKeyListener;
Index: CSipSimple/src/com/csipsimple/ui/incall/InCallActivity.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/incall/InCallActivity.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/incall/InCallActivity.java	(working copy)
@@ -54,7 +54,7 @@
 import android.widget.RelativeLayout;
 
 import com.actionbarsherlock.app.SherlockFragmentActivity;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.ISipService;
 import com.csipsimple.api.MediaState;
 import com.csipsimple.api.SipCallSession;
Index: CSipSimple/src/com/csipsimple/ui/incall/InCallCard.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/incall/InCallCard.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/incall/InCallCard.java	(working copy)
@@ -48,7 +48,7 @@
 import com.actionbarsherlock.internal.view.menu.MenuBuilder.Callback;
 import com.actionbarsherlock.view.MenuInflater;
 import com.actionbarsherlock.view.MenuItem;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipCallSession;
 import com.csipsimple.api.SipCallSession.MediaState;
 import com.csipsimple.api.SipConfigManager;
Index: CSipSimple/src/com/csipsimple/ui/incall/InCallControls.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/incall/InCallControls.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/incall/InCallControls.java	(working copy)
@@ -38,7 +38,7 @@
 import com.actionbarsherlock.internal.view.menu.MenuView;
 import com.actionbarsherlock.view.MenuInflater;
 import com.actionbarsherlock.view.MenuItem;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.MediaState;
 import com.csipsimple.api.SipCallSession;
 import com.csipsimple.api.SipConfigManager;
Index: CSipSimple/src/com/csipsimple/ui/incall/InCallMediaControl.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/incall/InCallMediaControl.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/incall/InCallMediaControl.java	(working copy)
@@ -44,7 +44,7 @@
 import android.widget.SeekBar;
 import android.widget.SeekBar.OnSeekBarChangeListener;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.ISipService;
 import com.csipsimple.api.SipCallSession;
 import com.csipsimple.api.SipConfigManager;
Index: CSipSimple/src/com/csipsimple/ui/incall/locker/buttons/AlternateUnlocker.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/incall/locker/buttons/AlternateUnlocker.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/incall/locker/buttons/AlternateUnlocker.java	(working copy)
@@ -33,7 +33,7 @@
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.ui.incall.locker.IOnLeftRightChoice;
 import com.csipsimple.ui.incall.locker.IOnLeftRightChoice.IOnLeftRightProvider;
 import com.csipsimple.ui.incall.locker.IOnLeftRightChoice.TypeOfLock;
Index: CSipSimple/src/com/csipsimple/ui/incall/locker/multiwaveview/GlowPadView.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/incall/locker/multiwaveview/GlowPadView.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/incall/locker/multiwaveview/GlowPadView.java	(working copy)
@@ -55,7 +55,7 @@
 import android.view.accessibility.AccessibilityManager;
 import android.widget.LinearLayout.LayoutParams;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.ui.incall.locker.IOnLeftRightChoice;
 import com.csipsimple.ui.incall.locker.IOnLeftRightChoice.IOnLeftRightProvider;
 import com.csipsimple.ui.incall.locker.IOnLeftRightChoice.TypeOfLock;
Index: CSipSimple/src/com/csipsimple/ui/incall/locker/ScreenLocker.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/incall/locker/ScreenLocker.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/incall/locker/ScreenLocker.java	(working copy)
@@ -33,7 +33,7 @@
 import android.view.WindowManager;
 import android.widget.RelativeLayout;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.ui.incall.locker.slidingtab.SlidingTab;
 
 import java.lang.ref.WeakReference;
Index: CSipSimple/src/com/csipsimple/ui/incall/locker/slidingtab/SlidingTab.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/incall/locker/slidingtab/SlidingTab.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/incall/locker/slidingtab/SlidingTab.java	(working copy)
@@ -39,7 +39,7 @@
 import android.widget.TextView;
 
 import com.actionbarsherlock.internal.utils.UtilityWrapper;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.ui.incall.locker.IOnLeftRightChoice;
 import com.csipsimple.ui.incall.locker.IOnLeftRightChoice.IOnLeftRightProvider;
 import com.csipsimple.ui.incall.locker.IOnLeftRightChoice.TypeOfLock;
Index: CSipSimple/src/com/csipsimple/ui/messages/ConversationsAdapter.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/messages/ConversationsAdapter.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/messages/ConversationsAdapter.java	(working copy)
@@ -34,7 +34,7 @@
 import android.view.ViewGroup;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipMessage;
 import com.csipsimple.api.SipUri;
 import com.csipsimple.models.CallerInfo;
@@ -43,8 +43,8 @@
 
 public class ConversationsAdapter extends SimpleCursorAdapter {
 
-	private Context mContext;
-	
+	private Context mContext;
+	
     public ConversationsAdapter(Context context, Cursor c) {
         super(context, R.layout.conversation_list_item, c, new String[] {
                 SipMessage.FIELD_BODY
@@ -52,7 +52,7 @@
                 new int[] {
                         R.id.subject
                 }, 0);
-        mContext = context;
+        mContext = context;
     }
 
     public static final class ConversationListItemViews {
@@ -155,14 +155,14 @@
         }
         */
         String remoteContactFull = cursor.getString(cursor.getColumnIndex(SipMessage.FIELD_FROM_FULL));
-        CallerInfo callerInfo = CallerInfo.getCallerInfoFromSipUri(mContext, remoteContactFull);
-        if (callerInfo != null && callerInfo.contactExists) {
-        	buf.append(callerInfo.name);
-        	buf.append(" / ");
-            buf.append(SipUri.getDisplayedSimpleContact(remoteContactFull));
-        } else {
-            buf.append(SipUri.getDisplayedSimpleContact(remoteContactFull));
-        }
+        CallerInfo callerInfo = CallerInfo.getCallerInfoFromSipUri(mContext, remoteContactFull);
+        if (callerInfo != null && callerInfo.contactExists) {
+        	buf.append(callerInfo.name);
+        	buf.append(" / ");
+            buf.append(SipUri.getDisplayedSimpleContact(remoteContactFull));
+        } else {
+            buf.append(SipUri.getDisplayedSimpleContact(remoteContactFull));
+        }
         
         int counter = cursor.getInt(cursor.getColumnIndex("counter"));
         if (counter > 1) {
Index: CSipSimple/src/com/csipsimple/ui/messages/ConversationsListFragment.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/messages/ConversationsListFragment.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/messages/ConversationsListFragment.java	(working copy)
@@ -47,7 +47,7 @@
 import com.actionbarsherlock.view.MenuInflater;
 import com.actionbarsherlock.view.MenuItem;
 import com.actionbarsherlock.view.MenuItem.OnMenuItemClickListener;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipMessage;
 import com.csipsimple.service.SipNotifications;
 import com.csipsimple.ui.SipHome.ViewPagerVisibilityListener;
Index: CSipSimple/src/com/csipsimple/ui/messages/MessageAdapter.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/messages/MessageAdapter.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/messages/MessageAdapter.java	(working copy)
@@ -38,7 +38,7 @@
 import android.widget.RelativeLayout.LayoutParams;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipMessage;
 import com.csipsimple.models.CallerInfo;
 import com.csipsimple.utils.ContactsAsyncHelper;
Index: CSipSimple/src/com/csipsimple/ui/messages/MessageFragment.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/messages/MessageFragment.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/messages/MessageFragment.java	(working copy)
@@ -54,7 +54,7 @@
 import com.actionbarsherlock.view.MenuInflater;
 import com.actionbarsherlock.view.MenuItem;
 import com.actionbarsherlock.view.MenuItem.OnMenuItemClickListener;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.ISipService;
 import com.csipsimple.api.SipMessage;
 import com.csipsimple.api.SipProfile;
@@ -248,12 +248,12 @@
             if (remoteFrom != from) {
                 remoteFrom = from;
                 fromText.setText(remoteFrom);
-                CallerInfo callerInfo = CallerInfo.getCallerInfoFromSipUri(getActivity(), fullFrom);
-                if (callerInfo != null && callerInfo.contactExists) {
-                	fullFromText.setText(callerInfo.name);
-                } else {
-                	fullFromText.setText(SipUri.getDisplayedSimpleContact(fullFrom));
-                }
+                CallerInfo callerInfo = CallerInfo.getCallerInfoFromSipUri(getActivity(), fullFrom);
+                if (callerInfo != null && callerInfo.contactExists) {
+                	fullFromText.setText(callerInfo.name);
+                } else {
+                	fullFromText.setText(SipUri.getDisplayedSimpleContact(fullFrom));
+                }
                 loadMessageContent();
                 notifications.setViewingMessageFrom(remoteFrom);
             }
Index: CSipSimple/src/com/csipsimple/ui/outgoingcall/OutgoingAccountsAdapter.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/outgoingcall/OutgoingAccountsAdapter.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/outgoingcall/OutgoingAccountsAdapter.java	(working copy)
@@ -30,7 +30,7 @@
 import android.widget.TextView;
 
 import com.actionbarsherlock.internal.utils.UtilityWrapper;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.ui.account.AccountsLoader;
 import com.csipsimple.utils.CallHandlerPlugin;
Index: CSipSimple/src/com/csipsimple/ui/outgoingcall/OutgoingCallChooser.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/outgoingcall/OutgoingCallChooser.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/outgoingcall/OutgoingCallChooser.java	(working copy)
@@ -33,7 +33,7 @@
 import android.view.KeyEvent;
 
 import com.actionbarsherlock.app.SherlockFragmentActivity;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.ISipService;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.api.SipProfile;
Index: CSipSimple/src/com/csipsimple/ui/PickupSipUri.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/PickupSipUri.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/PickupSipUri.java	(working copy)
@@ -32,7 +32,7 @@
 import android.widget.TextView;
 import android.widget.TextView.OnEditorActionListener;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.widgets.EditSipUri;
 import com.csipsimple.widgets.EditSipUri.ToCall;
Index: CSipSimple/src/com/csipsimple/ui/prefs/AudioTester.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/prefs/AudioTester.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/prefs/AudioTester.java	(working copy)
@@ -35,7 +35,7 @@
 import android.widget.ProgressBar;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.ISipService;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.service.SipService;
Index: CSipSimple/src/com/csipsimple/ui/prefs/Codecs.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/prefs/Codecs.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/prefs/Codecs.java	(working copy)
@@ -34,7 +34,7 @@
 import com.actionbarsherlock.app.ActionBar;
 import com.actionbarsherlock.app.ActionBar.Tab;
 import com.actionbarsherlock.app.SherlockFragmentActivity;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.utils.Log;
 
Index: CSipSimple/src/com/csipsimple/ui/prefs/CodecsFragment.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/prefs/CodecsFragment.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/prefs/CodecsFragment.java	(working copy)
@@ -44,7 +44,7 @@
 import android.widget.TextView;
 
 import com.actionbarsherlock.app.SherlockListFragment;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.utils.Log;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/ui/prefs/cupcake/MainPrefs.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/prefs/cupcake/MainPrefs.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/prefs/cupcake/MainPrefs.java	(working copy)
@@ -36,7 +36,7 @@
 import com.actionbarsherlock.view.Menu;
 import com.actionbarsherlock.view.MenuInflater;
 import com.actionbarsherlock.view.MenuItem;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.ui.prefs.PrefsFilters;
 import com.csipsimple.ui.prefs.PrefsLogic;
Index: CSipSimple/src/com/csipsimple/ui/prefs/GenericPrefs.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/prefs/GenericPrefs.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/prefs/GenericPrefs.java	(working copy)
@@ -32,7 +32,7 @@
 import android.text.TextUtils;
 
 import com.actionbarsherlock.app.SherlockPreferenceActivity;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.utils.Log;
 
 @SuppressWarnings("deprecation")
Index: CSipSimple/src/com/csipsimple/ui/prefs/hc/MainPrefs.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/prefs/hc/MainPrefs.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/prefs/hc/MainPrefs.java	(working copy)
@@ -30,7 +30,7 @@
 import com.actionbarsherlock.view.Menu;
 import com.actionbarsherlock.view.MenuInflater;
 import com.actionbarsherlock.view.MenuItem;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.ui.prefs.CodecsFragment;
 import com.csipsimple.ui.prefs.PrefsFilters;
Index: CSipSimple/src/com/csipsimple/ui/prefs/hc/PrefsLoaderFragment.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/prefs/hc/PrefsLoaderFragment.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/prefs/hc/PrefsLoaderFragment.java	(working copy)
@@ -30,7 +30,7 @@
 import android.preference.PreferenceScreen;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.ui.prefs.IPreferenceHelper;
 import com.csipsimple.ui.prefs.PrefsLogic;
 import com.csipsimple.utils.Log;
Index: CSipSimple/src/com/csipsimple/ui/prefs/PrefsFast.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/prefs/PrefsFast.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/prefs/PrefsFast.java	(working copy)
@@ -29,7 +29,7 @@
 import android.widget.RadioButton;
 
 import com.actionbarsherlock.app.SherlockActivity;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.utils.PreferencesWrapper;
 
@@ -104,6 +104,8 @@
 		
 		globGsm.setChecked( useGsm );
 		
+		globGsm.toggle();
+		
 		Profile mode = Profile.UNKOWN;
 		
 		if( ( !useGsm && wifiIn && wifiOut && lockWifi) ||
Index: CSipSimple/src/com/csipsimple/ui/prefs/PrefsLogic.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/prefs/PrefsLogic.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/prefs/PrefsLogic.java	(working copy)
@@ -29,7 +29,7 @@
 
 import com.actionbarsherlock.view.Menu;
 import com.actionbarsherlock.view.MenuItem;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.utils.Compatibility;
@@ -310,21 +310,29 @@
                     
                 }
                 
-                ListPreference lp = (ListPreference) pfh.findPreference(SipConfigManager.THEME);
-                HashMap<String, String> themes = Theme.getAvailableThemes(ctxt);
+				if (com.csipsimple.wizards.CallRomaniaSettings.BUILD_TYPE.equals("AMAZON"))
+				{
+					pfh.hidePreference("android_integration", "selected_theme");
+					pfh.hidePreference("android_integration", "obtain_themes");
+				}
+				else
+				{
+					ListPreference lp = (ListPreference) pfh.findPreference(SipConfigManager.THEME);
+					HashMap<String, String> themes = Theme.getAvailableThemes(ctxt);
+					
+					CharSequence[] entries = new CharSequence[themes.size()];
+					CharSequence[] values = new CharSequence[themes.size()];
+					int i = 0;
+					for( Entry<String, String> theme : themes.entrySet() ) {
+						entries[i] = theme.getValue();
+						values[i] = theme.getKey();
+						i++;
+					}
+					
+					lp.setEntries(entries);
+					lp.setEntryValues(values);
+				}
                 
-                CharSequence[] entries = new CharSequence[themes.size()];
-                CharSequence[] values = new CharSequence[themes.size()];
-                int i = 0;
-                for( Entry<String, String> theme : themes.entrySet() ) {
-                    entries[i] = theme.getValue();
-                    values[i] = theme.getKey();
-                    i++;
-                }
-                
-                lp.setEntries(entries);
-                lp.setEntryValues(values);
-                
                 break;
             }
             case TYPE_CALLS : {
Index: CSipSimple/src/com/csipsimple/ui/SipHome.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/SipHome.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/SipHome.java	(working copy)
@@ -21,11 +21,20 @@
 
 package com.csipsimple.ui;
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.http.NameValuePair;
+import org.apache.http.message.BasicNameValuePair;
+
+import ro.callromania.R;
 import android.app.AlertDialog;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
+import android.content.SharedPreferences;
 import android.content.pm.ActivityInfo;
 import android.database.Cursor;
 import android.graphics.drawable.Drawable;
@@ -54,7 +63,6 @@
 import com.actionbarsherlock.internal.utils.UtilityWrapper;
 import com.actionbarsherlock.view.Menu;
 import com.actionbarsherlock.view.MenuItem;
-import com.csipsimple.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.api.SipProfile;
@@ -78,11 +86,12 @@
 import com.csipsimple.utils.UriUtils;
 import com.csipsimple.utils.backup.BackupWrapper;
 import com.csipsimple.wizards.BasePrefsWizard;
+import com.csipsimple.wizards.CallRomaniaBilling;
 import com.csipsimple.wizards.WizardUtils.WizardInfo;
+import com.google.android.gms.common.ConnectionResult;
+import com.google.android.gms.common.GooglePlayServicesUtil;
+import com.google.android.gms.gcm.GoogleCloudMessaging;
 
-import java.util.ArrayList;
-import java.util.List;
-
 public class SipHome extends SherlockFragmentActivity implements OnWarningChanged {
     public static final int ACCOUNTS_MENU = Menu.FIRST + 1;
     public static final int PARAMS_MENU = Menu.FIRST + 2;
@@ -113,6 +122,15 @@
     private Thread asyncSanityChecker;
     private Tab warningTab;
     private ObjectAnimator warningTabfadeAnim;
+    
+    
+    
+    private static final int PLAY_SERVICES_RESOLUTION_REQUEST = 9000;
+	private String gcm_reg_id;	
+	
+    static final String TAG = "CallroPN";
+    
+    
 
     /**
      * Listener interface for Fragments accommodated in {@link ViewPager}
@@ -122,6 +140,14 @@
     public interface ViewPagerVisibilityListener {
         void onVisibilityChanged(boolean visible);
     }
+    
+    @Override
+	protected void onStart() {
+	    super.onStart();
+	    
+	    CallRomaniaBilling.setActivity(this);
+	    CallRomaniaBilling.sendConfirmation();
+	}
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -200,7 +226,66 @@
         };
         asyncSanityChecker.start();
         
+        
+        //PN stuff here
+        if (checkPlayServices()) 
+        {
+	        new Thread()
+	        {
+	        	public void run()
+	        	{
+	        		GoogleCloudMessaging gcm = GoogleCloudMessaging.getInstance(getApplicationContext());
+	        		try {
+						gcm_reg_id = gcm.register("342962053698");
+					} catch (IOException e1) {
+						gcm_reg_id = "null";
+					}
+	        		
+	        		SharedPreferences prefs = getApplicationContext().getSharedPreferences("wizard_callromania_setup_prefs", 0);
+	        		String number = prefs.getString("callromania_number", null);
+	        		if (number != null)
+	        		{
+	        			List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(2);
+	        	    	nameValuePairs.add(new BasicNameValuePair("telefon", number));
+	        	    	nameValuePairs.add(new BasicNameValuePair("gcm_reg_id", gcm_reg_id));
+	        	    	
+	        	    	String response = CallRomaniaBilling.postData("https://www.callromania.ro/api/android.php", nameValuePairs);   
+	        		}
+	        		
+	        	}
+	        }.start();
+        }       
+        
+        
     }
+    
+    /**
+     * Check the device to make sure it has the Google Play Services APK. If
+     * it doesn't, display a dialog that allows users to download the APK from
+     * the Google Play Store or enable it in the device's system settings.
+     */
+	private boolean checkPlayServices() 
+	{
+	    int resultCode = GooglePlayServicesUtil.isGooglePlayServicesAvailable(this);
+	    if (resultCode != ConnectionResult.SUCCESS) 
+	    {
+	        if (GooglePlayServicesUtil.isUserRecoverableError(resultCode)) 
+	        {
+	            GooglePlayServicesUtil.getErrorDialog(resultCode, this, PLAY_SERVICES_RESOLUTION_REQUEST).show();
+	        } 
+	        else 
+	        {
+	            Log.i(TAG, "This device is not supported.");
+	            finish();
+	        }
+	        return false;
+	    }
+	    return true;
+	}
+    
+    
+    
+    
 
     /**
      * This is a helper class that implements the management of tabs and all
@@ -764,7 +849,8 @@
         WizardInfo distribWizard = CustomDistribution.getCustomDistributionWizard();
         if (distribWizard != null) {
             menu.add(Menu.NONE, DISTRIB_ACCOUNT_MENU, Menu.NONE, "My " + distribWizard.label)
-                    .setIcon(distribWizard.icon)
+            		//MOD 1.0.4
+                    .setIcon(R.drawable.ic_wizard_callromania)
                     .setShowAsAction(actionRoom);
         }
         if (CustomDistribution.distributionWantsOtherAccounts()) {
Index: CSipSimple/src/com/csipsimple/ui/warnings/WarningFragment.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/warnings/WarningFragment.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/warnings/WarningFragment.java	(working copy)
@@ -29,7 +29,7 @@
 import android.widget.LinearLayout.LayoutParams;
 
 import com.actionbarsherlock.app.SherlockFragment;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.ui.warnings.WarningUtils.OnWarningChanged;
 import com.csipsimple.ui.warnings.WarningUtils.WarningBlockView;
 import com.csipsimple.utils.Log;
Index: CSipSimple/src/com/csipsimple/ui/warnings/WarningNoStun.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/warnings/WarningNoStun.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/warnings/WarningNoStun.java	(working copy)
@@ -26,7 +26,7 @@
 import android.util.AttributeSet;
 import android.view.View;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.ui.warnings.WarningUtils.WarningBlockView;
Index: CSipSimple/src/com/csipsimple/ui/warnings/WarningPrivilegedIntent.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/warnings/WarningPrivilegedIntent.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/warnings/WarningPrivilegedIntent.java	(working copy)
@@ -26,7 +26,7 @@
 import android.util.AttributeSet;
 import android.view.View;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.ui.warnings.WarningUtils.WarningBlockView;
Index: CSipSimple/src/com/csipsimple/ui/warnings/WarningSDCard.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/warnings/WarningSDCard.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/warnings/WarningSDCard.java	(working copy)
@@ -24,7 +24,7 @@
 import android.content.Context;
 import android.util.AttributeSet;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.ui.warnings.WarningUtils.WarningBlockView;
 
 public class WarningSDCard extends WarningBlockView {
Index: CSipSimple/src/com/csipsimple/ui/warnings/WarningUtils.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/warnings/WarningUtils.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/warnings/WarningUtils.java	(working copy)
@@ -29,7 +29,7 @@
 import android.view.View.OnClickListener;
 import android.widget.RelativeLayout;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.utils.Compatibility;
 import com.csipsimple.utils.PhoneCapabilityTester;
Index: CSipSimple/src/com/csipsimple/ui/warnings/WarningVpnIcs.java
===================================================================
--- CSipSimple/src/com/csipsimple/ui/warnings/WarningVpnIcs.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/ui/warnings/WarningVpnIcs.java	(working copy)
@@ -27,7 +27,7 @@
 import android.view.View;
 import android.view.View.OnClickListener;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.ui.warnings.WarningUtils.WarningBlockView;
Index: CSipSimple/src/com/csipsimple/utils/AccountListUtils.java
===================================================================
--- CSipSimple/src/com/csipsimple/utils/AccountListUtils.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/utils/AccountListUtils.java	(working copy)
@@ -25,9 +25,11 @@
 import android.content.Context;
 import android.content.res.Resources;
 import android.database.Cursor;
+import android.os.Handler;
 import android.text.TextUtils;
+import android.widget.Toast;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipCallSession;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.api.SipProfile;
@@ -46,7 +48,31 @@
 
 	private static final String THIS_FILE = "AccountListUtils";
 	
+	static Toast toasty = null; 
 	
+	static void showToastMessage(final Context ctx, final String message)
+	{
+		Handler h = new Handler(ctx.getMainLooper());
+		h.post(new Runnable() 
+		{			
+			public void run() 
+			{
+				try
+				{
+					if (toasty != null)
+						toasty.cancel();
+					toasty = Toast.makeText(ctx, message, Toast.LENGTH_SHORT);
+					toasty.show();
+				}
+				catch(Exception e)
+				{
+					e.printStackTrace();
+				}
+			}
+		});
+	}
+	
+	
 	public static AccountStatusDisplay getAccountDisplay(Context context, long accountId) {
 		AccountStatusDisplay accountDisplay = new AccountStatusDisplay();
 		accountDisplay.statusLabel = context.getString(R.string.acct_inactive);
@@ -89,6 +115,8 @@
 					accountDisplay.checkBoxIndicator = R.drawable.ic_indicator_on;
 					accountDisplay.statusLabel = context.getString(R.string.acct_registered);
 					accountDisplay.availableForCalls = true;
+					
+					showToastMessage(context, context.getString(R.string.acct_registered));
 				}else if (accountInfo.isAddedToStack()) {
 					String pjStat = accountInfo.getStatusText();	// Used only on error status message
 					int statusCode = accountInfo.getStatusCode();
@@ -101,6 +129,7 @@
 							accountDisplay.checkBoxIndicator = R.drawable.ic_indicator_on;
 							accountDisplay.statusLabel = context.getString(R.string.acct_registered);
 							accountDisplay.availableForCalls = true;
+							showToastMessage(context, context.getString(R.string.acct_registered));
 						} else {
 							// Yellow unregistered
 							accountDisplay.statusColor = resources.getColor(R.color.account_unregistered);
@@ -113,6 +142,7 @@
 							accountDisplay.statusColor = resources.getColor(R.color.account_unregistered);
 							accountDisplay.checkBoxIndicator = R.drawable.ic_indicator_yellow;
 							accountDisplay.statusLabel = context.getString(R.string.acct_registering);
+							showToastMessage(context, context.getString(R.string.acct_registering));
 						} else {
 							//TODO : treat 403 with special message
 							// Red : error
@@ -119,6 +149,7 @@
 							accountDisplay.statusColor = resources.getColor(R.color.account_error);
 							accountDisplay.checkBoxIndicator = R.drawable.ic_indicator_red;
 							accountDisplay.statusLabel = context.getString(R.string.acct_regerror) + " - " + pjStat;	// Why can't ' - ' be in resource?
+							showToastMessage(context, context.getString(R.string.acct_regerror));
 						}
 					}else {
 						// Account is currently registering (added to pjsua but not replies yet from pjsua registration)
@@ -125,6 +156,7 @@
 						accountDisplay.statusColor = resources.getColor(R.color.account_inactive);
 						accountDisplay.checkBoxIndicator = R.drawable.ic_indicator_yellow;
 						accountDisplay.statusLabel = context.getString(R.string.acct_registering);
+						showToastMessage(context, context.getString(R.string.acct_registering));
 					}
 				}
 			} else {
@@ -131,10 +163,12 @@
 				if(accountInfo.isAddedToStack()) {
 					accountDisplay.statusLabel = context.getString(R.string.acct_regfailed);
 					accountDisplay.statusColor = resources.getColor(R.color.account_error);
+					showToastMessage(context, context.getString(R.string.acct_regfailed));
 				}else {
 					accountDisplay.statusColor = resources.getColor(R.color.account_inactive);
 					accountDisplay.checkBoxIndicator = R.drawable.ic_indicator_yellow;
 					accountDisplay.statusLabel = context.getString(R.string.acct_registering);
+					showToastMessage(context, context.getString(R.string.acct_registering));
 					
 				}
 			}
Index: CSipSimple/src/com/csipsimple/utils/CallsUtils.java
===================================================================
--- CSipSimple/src/com/csipsimple/utils/CallsUtils.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/utils/CallsUtils.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.content.Context;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipCallSession;
 
 public class CallsUtils {
Index: CSipSimple/src/com/csipsimple/utils/CollectLogs.java
===================================================================
--- CSipSimple/src/com/csipsimple/utils/CollectLogs.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/utils/CollectLogs.java	(working copy)
@@ -33,6 +33,8 @@
 import java.io.InputStreamReader;
 import java.util.ArrayList;
 
+import ro.callromania.R;
+
 public class CollectLogs {
 
 	private static final Object LINE_SEPARATOR = "\n";
@@ -154,15 +156,15 @@
 	
 	public final static String getApplicationInfo(Context ctx) {
 		String result = "";
-		PackageManager pm = ctx.getPackageManager();
-        result += "Based on GPL application ";
-        result += ctx.getApplicationInfo().loadLabel(pm);
-        result += " version : ";
+	        result += ctx.getString(R.string.w_callromania_about);
+		//PackageManager pm = ctx.getPackageManager();
+        	//result += ctx.getApplicationInfo().loadLabel(pm);
+        	//result += " version : ";
 		
-		PackageInfo pinfo = PreferencesProviderWrapper.getCurrentPackageInfos(ctx);
-		if(pinfo != null) {
-			result += pinfo.versionName + " r" + pinfo.versionCode;
-		}
+		//PackageInfo pinfo = PreferencesProviderWrapper.getCurrentPackageInfos(ctx);
+		//if(pinfo != null) {
+			//result += pinfo.versionName + " r" + pinfo.versionCode;
+		//}
 		return result;
 	}
 	
Index: CSipSimple/src/com/csipsimple/utils/contacts/ContactsSearchAdapter.java
===================================================================
--- CSipSimple/src/com/csipsimple/utils/contacts/ContactsSearchAdapter.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/utils/contacts/ContactsSearchAdapter.java	(working copy)
@@ -44,7 +44,7 @@
 import android.widget.SectionIndexer;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.models.Filter;
 
Index: CSipSimple/src/com/csipsimple/utils/contacts/ContactsUtils3.java
===================================================================
--- CSipSimple/src/com/csipsimple/utils/contacts/ContactsUtils3.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/utils/contacts/ContactsUtils3.java	(working copy)
@@ -39,7 +39,7 @@
 import android.widget.ImageView;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.models.CallerInfo;
 import com.csipsimple.utils.Log;
Index: CSipSimple/src/com/csipsimple/utils/contacts/ContactsUtils5.java
===================================================================
--- CSipSimple/src/com/csipsimple/utils/contacts/ContactsUtils5.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/utils/contacts/ContactsUtils5.java	(working copy)
@@ -53,7 +53,7 @@
 import android.widget.ImageView;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.api.SipUri;
 import com.csipsimple.models.CallerInfo;
Index: CSipSimple/src/com/csipsimple/utils/contacts/ContactsWrapper.java
===================================================================
--- CSipSimple/src/com/csipsimple/utils/contacts/ContactsWrapper.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/utils/contacts/ContactsWrapper.java	(working copy)
@@ -28,6 +28,7 @@
 import android.net.Uri;
 import android.view.View;
 
+import ro.callromania.R;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.models.CallerInfo;
 import com.csipsimple.utils.Compatibility;
Index: CSipSimple/src/com/csipsimple/utils/ContactsAsyncHelper.java
===================================================================
--- CSipSimple/src/com/csipsimple/utils/ContactsAsyncHelper.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/utils/ContactsAsyncHelper.java	(working copy)
@@ -38,7 +38,7 @@
 import android.view.View;
 import android.widget.ImageView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.models.CallerInfo;
 import com.csipsimple.utils.contacts.ContactsWrapper;
 
Index: CSipSimple/src/com/csipsimple/utils/CustomDistribution.java
===================================================================
--- CSipSimple/src/com/csipsimple/utils/CustomDistribution.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/utils/CustomDistribution.java	(working copy)
@@ -22,9 +22,14 @@
 
 package com.csipsimple.utils;
 
+import java.util.Locale;
+
+import ro.callromania.R;
 import com.csipsimple.wizards.WizardUtils.WizardInfo;
+import com.csipsimple.wizards.impl.CallRomania;
 
-public final class CustomDistribution {
+public final class CustomDistribution 
+{
 	
 	private CustomDistribution() {}
 	
@@ -34,8 +39,9 @@
 	 * than the one of the distribution
 	 * @return Whether other accounts can be created
 	 */
-	public static boolean distributionWantsOtherAccounts() {
-		return true;
+	public static boolean distributionWantsOtherAccounts() 
+	{
+		return false;
 	}
 	
 	/**
@@ -43,8 +49,9 @@
 	 * other accounts creation
 	 * @return Whether other provider are listed is wizard picker
 	 */
-	public static boolean distributionWantsOtherProviders() {
-		return true;
+	public static boolean distributionWantsOtherProviders() 
+	{
+		return false;
 	}
 	
 	/**
@@ -52,8 +59,9 @@
 	 * If none return the feedback feature is disabled
 	 * @return the email address of support
 	 */
-	public static String getSupportEmail() {
-		return "developers@csipsimple.com";
+	public static String getSupportEmail() 
+	{
+		return "info@callromania.ro";
 	}
 	
 	/**
@@ -60,8 +68,9 @@
 	 * SIP User agent to send by default in SIP messages (by default device infos are added to User Agent string)
 	 * @return the default user agent
 	 */
-	public static String getUserAgent() {
-		return "CSipSimple";
+	public static String getUserAgent() 
+	{
+		return "callRomania_Android";
 	}
 	
 	/**
@@ -68,8 +77,12 @@
 	 * The default wizard info for this distrib. If none no custom distribution wizard is shown
 	 * @return the default wizard info
 	 */
-	public static WizardInfo getCustomDistributionWizard() {
-		return null; 
+	public static WizardInfo getCustomDistributionWizard() 
+	{
+		return new WizardInfo("CALLROMANIA", "callRomania", 
+                R.drawable.ic_wizard_callromania, 12, 
+                new Locale[]{ new Locale("ro_RO"), new Locale("RO", "ro")  }, false, false, 
+                CallRomania.class); 
 	}
 	
 	/**
@@ -76,8 +89,9 @@
 	 * Show or not the issue list in help
 	 * @return whether link to issue list should be displayed
 	 */
-	public static boolean showIssueList() {
-		return true;
+	public static boolean showIssueList() 
+	{
+		return false;
 	}
 	
 	/**
@@ -84,8 +98,9 @@
 	 * Get the link to the FAQ. If null or empty the link to FAQ is not displayed
 	 * @return link to the FAQ
 	 */
-	public static String getFaqLink() {
-		return "http://code.google.com/p/csipsimple/wiki/FAQ?show=content,nav#Summary";
+	public static String getFaqLink() 
+	{
+		return null;
 	}
 	
 	/**
@@ -93,7 +108,8 @@
 	 * allow user to quickly configure the sip client
 	 * @return true if the fast setting screen should be displayed
 	 */
-	public static boolean showFirstSettingScreen() {
+	public static boolean showFirstSettingScreen() 
+	{
 		return true;
 	}
 	
@@ -101,8 +117,9 @@
 	 * Do we want to display messaging feature
 	 * @return true if the feature is enabled in this distribution
 	 */
-	public static boolean supportMessaging() {
-		return true;
+	public static boolean supportMessaging() 
+	{
+		return false;
 	}
 	
 	/**
@@ -109,7 +126,8 @@
 	 * Do we want to display the favorites feature
 	 * @return true if the feature is enabled in this distribution
 	 */
-	public static boolean supportFavorites() {
+	public static boolean supportFavorites() 
+	{
 	    return true;
 	}
 	
@@ -119,7 +137,8 @@
 	 * ongoing call view and in settings as "auto record" feature
 	 * @return true if the feature is enabled in this distribution
 	 */
-    public static boolean supportCallRecord() {
+    public static boolean supportCallRecord() 
+    {
         return true;
     }
 
@@ -127,8 +146,9 @@
 	 * Shall we force the no mulitple call feature to be set to false
 	 * @return true if we don't want to support multiple calls at all.
 	 */
-	public static boolean forceNoMultipleCalls() {
-		return false;
+	public static boolean forceNoMultipleCalls() 
+	{
+		return true;
 	}
 
 	/**
@@ -136,8 +156,9 @@
 	 * @param wizardTag the tag of the generic wizard
 	 * @return true if you'd like the wizard to be listed
 	 */
-    public static boolean distributionWantsGeneric(String wizardTag) {
-        return true;
+    public static boolean distributionWantsGeneric(String wizardTag) 
+    {
+        return false;
     }
 
     /**
@@ -145,8 +166,9 @@
      * This folder will be used to store call records, configs and logs
      * @return the name of the folder to use
      */
-    public static String getSDCardFolder() {
-        return "CSipSimple";
+    public static String getSDCardFolder() 
+    {
+        return "callRomania";
     }
 
     /**
@@ -155,7 +177,8 @@
      * Check NightlyUpdater.java for the full URL and how the server should respond...
      * @return
      */
-	public static String getNightlyUpdaterURL() {
-		return "http://nightlies.csipsimple.com/";
+	public static String getNightlyUpdaterURL() 
+	{
+		return null;
 	}
 }
Index: CSipSimple/src/com/csipsimple/utils/NightlyUpdater.java
===================================================================
--- CSipSimple/src/com/csipsimple/utils/NightlyUpdater.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/utils/NightlyUpdater.java	(working copy)
@@ -39,7 +39,7 @@
 import android.preference.PreferenceManager;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.service.DeviceStateReceiver;
 import com.csipsimple.service.Downloader;
 
Index: CSipSimple/src/com/csipsimple/utils/PhoneCapabilityTester.java
===================================================================
--- CSipSimple/src/com/csipsimple/utils/PhoneCapabilityTester.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/utils/PhoneCapabilityTester.java	(working copy)
@@ -35,7 +35,7 @@
 //import android.net.sip.SipManager;
 import android.telephony.TelephonyManager;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 
 import java.util.ArrayList;
 import java.util.List;
Index: CSipSimple/src/com/csipsimple/utils/PreferencesProviderWrapper.java
===================================================================
--- CSipSimple/src/com/csipsimple/utils/PreferencesProviderWrapper.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/utils/PreferencesProviderWrapper.java	(working copy)
@@ -433,18 +433,16 @@
     }
 
     public String getUserAgent(Context ctx) {
-        String userAgent = getPreferenceStringValue(SipConfigManager.USER_AGENT);
-        if (userAgent.equalsIgnoreCase(CustomDistribution.getUserAgent())) {
-            // If that's the official -not custom- user agent, send the release,
-            // the device and the api level
-            PackageInfo pinfo = getCurrentPackageInfos(ctx);
-            if (pinfo != null) {
-                userAgent += "_" + android.os.Build.DEVICE + "-" + Compatibility.getApiLevel()
-                        + "/r" + pinfo.versionCode;
-            }
-        }
-        return userAgent;
-    }
+		String userAgent = getPreferenceStringValue(SipConfigManager.USER_AGENT);
+		if(userAgent.equalsIgnoreCase(CustomDistribution.getUserAgent())) {
+			//If that's the official -not custom- user agent, send the release, the device and the api level
+			PackageInfo pinfo = getCurrentPackageInfos(ctx);
+			if(pinfo != null) {
+				userAgent +=  "#" + (android.os.Build.MANUFACTURER + "_" + android.os.Build.MODEL).replaceAll(" ", "") + "#" + android.os.Build.VERSION.RELEASE + "#" + pinfo.versionCode;
+			}
+		}
+		return userAgent;
+	}
 
     public final static PackageInfo getCurrentPackageInfos(Context ctx) {
         PackageInfo pinfo = null;
Index: CSipSimple/src/com/csipsimple/utils/SmileyParser.java
===================================================================
--- CSipSimple/src/com/csipsimple/utils/SmileyParser.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/utils/SmileyParser.java	(working copy)
@@ -36,7 +36,7 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 
 /**
  * A class for annotating a CharSequence with spans to convert textual emoticons
Index: CSipSimple/src/com/csipsimple/utils/Theme.java
===================================================================
--- CSipSimple/src/com/csipsimple/utils/Theme.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/utils/Theme.java	(working copy)
@@ -42,7 +42,7 @@
 import android.widget.TextView;
 
 import com.actionbarsherlock.internal.utils.UtilityWrapper;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipManager;
 
Index: CSipSimple/src/com/csipsimple/widgets/AccountChooserButton.java
===================================================================
--- CSipSimple/src/com/csipsimple/widgets/AccountChooserButton.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/widgets/AccountChooserButton.java	(working copy)
@@ -43,7 +43,7 @@
 import com.actionbarsherlock.internal.view.menu.MenuPopupHelper;
 import com.actionbarsherlock.view.MenuItem;
 import com.actionbarsherlock.view.MenuItem.OnMenuItemClickListener;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.AccountListUtils;
 import com.csipsimple.utils.AccountListUtils.AccountStatusDisplay;
Index: CSipSimple/src/com/csipsimple/widgets/AccountWidgetProvider.java
===================================================================
--- CSipSimple/src/com/csipsimple/widgets/AccountWidgetProvider.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/widgets/AccountWidgetProvider.java	(working copy)
@@ -35,7 +35,7 @@
 import android.view.View;
 import android.widget.RemoteViews;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.AccountListUtils;
Index: CSipSimple/src/com/csipsimple/widgets/CheckableListItemView.java
===================================================================
--- CSipSimple/src/com/csipsimple/widgets/CheckableListItemView.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/widgets/CheckableListItemView.java	(working copy)
@@ -25,7 +25,7 @@
 
 package com.csipsimple.widgets;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 
 import android.content.Context;
 import android.util.AttributeSet;
Index: CSipSimple/src/com/csipsimple/widgets/CSSListFragment.java
===================================================================
--- CSipSimple/src/com/csipsimple/widgets/CSSListFragment.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/widgets/CSSListFragment.java	(working copy)
@@ -29,7 +29,7 @@
 import android.view.animation.AnimationUtils;
 
 import com.actionbarsherlock.app.SherlockListFragment;
-import com.csipsimple.R;
+import ro.callromania.R;
 
 /**
  * Helper class for list fragments.<br/>
Index: CSipSimple/src/com/csipsimple/widgets/DialerCallBar.java
===================================================================
--- CSipSimple/src/com/csipsimple/widgets/DialerCallBar.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/widgets/DialerCallBar.java	(working copy)
@@ -30,7 +30,7 @@
 import android.view.View.OnLongClickListener;
 import android.widget.LinearLayout;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 
 public class DialerCallBar extends LinearLayout implements OnClickListener, OnLongClickListener {
 
@@ -52,6 +52,11 @@
          * The delete button has been long pressed
          */
         void deleteAll();
+        /** 
+         * //MOD 1.0.4
+         * The compose button was pressed 
+         */
+        void composeSMS();
     }
 
     private OnDialActionListener actionListener;
@@ -68,7 +73,9 @@
         super(context, attrs);
         LayoutInflater inflater = LayoutInflater.from(context);
         inflater.inflate(R.layout.dialpad_additional_buttons, this, true);
-        findViewById(R.id.dialVideoButton).setOnClickListener(this);
+        //MOD 1.0.4 
+        //findViewById(R.id.dialVideoButton).setOnClickListener(this);
+        findViewById(R.id.composeSMSButton).setOnClickListener(this);
         findViewById(R.id.dialButton).setOnClickListener(this);
         findViewById(R.id.deleteButton).setOnClickListener(this);
         findViewById(R.id.deleteButton).setOnLongClickListener(this);
@@ -101,7 +108,9 @@
      */
     public void setEnabled(boolean enabled) {
         findViewById(R.id.dialButton).setEnabled(enabled);
-        findViewById(R.id.dialVideoButton).setEnabled(enabled);
+        //MOD 1.0.4 
+        //findViewById(R.id.dialVideoButton).setEnabled(enabled);
+        //findViewById(R.id.composeSMSButton).setEnabled(enabled);
         findViewById(R.id.deleteButton).setEnabled(enabled);
     }
     
@@ -110,7 +119,8 @@
      * @param enabled whether the client is able to make video calls
      */
     public void setVideoEnabled(boolean enabled) {
-        findViewById(R.id.dialVideoButton).setVisibility(enabled ? View.VISIBLE : View.INVISIBLE);
+    	//MOD 1.0.4 
+        //findViewById(R.id.dialVideoButton).setVisibility(enabled ? View.VISIBLE : View.INVISIBLE);
     }
 
     @Override
@@ -117,8 +127,12 @@
     public void onClick(View v) {
         if (actionListener != null) {
             int viewId = v.getId();
-            if (viewId == R.id.dialVideoButton) {
-                actionListener.placeVideoCall();
+            //MOD 1.0.4 
+            //if (viewId == R.id.dialVideoButton) {
+                //actionListener.placeVideoCall();
+            //}
+            if (viewId == R.id.composeSMSButton) {
+            	actionListener.composeSMS();
             }else if(viewId == R.id.dialButton) {
                 actionListener.placeCall();
             }else if(viewId == R.id.deleteButton) {
Index: CSipSimple/src/com/csipsimple/widgets/Dialpad.java
===================================================================
--- CSipSimple/src/com/csipsimple/widgets/Dialpad.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/widgets/Dialpad.java	(working copy)
@@ -35,7 +35,7 @@
 import android.widget.FrameLayout;
 import android.widget.ImageButton;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.utils.Log;
 import com.csipsimple.utils.Theme;
 
Index: CSipSimple/src/com/csipsimple/widgets/DragnDropListView.java
===================================================================
--- CSipSimple/src/com/csipsimple/widgets/DragnDropListView.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/widgets/DragnDropListView.java	(working copy)
@@ -42,7 +42,7 @@
 import android.widget.ImageView;
 import android.widget.ListView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.utils.Log;
 
 public class DragnDropListView extends ListView {
Index: CSipSimple/src/com/csipsimple/widgets/EditSipUri.java
===================================================================
--- CSipSimple/src/com/csipsimple/widgets/EditSipUri.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/widgets/EditSipUri.java	(working copy)
@@ -37,7 +37,7 @@
 import android.widget.ListView;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.models.Filter;
 import com.csipsimple.utils.Log;
Index: CSipSimple/src/com/csipsimple/widgets/PasswordPreference.java
===================================================================
--- CSipSimple/src/com/csipsimple/widgets/PasswordPreference.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/widgets/PasswordPreference.java	(working copy)
@@ -35,7 +35,7 @@
 import android.widget.CheckBox;
 import android.widget.EditText;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.utils.Compatibility;
 import com.csipsimple.utils.Log;
 
Index: CSipSimple/src/com/csipsimple/widgets/RegistrationNotification.java
===================================================================
--- CSipSimple/src/com/csipsimple/widgets/RegistrationNotification.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/widgets/RegistrationNotification.java	(working copy)
@@ -27,7 +27,7 @@
 import android.view.View;
 import android.widget.RemoteViews;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfileState;
 import com.csipsimple.wizards.WizardUtils;
 import com.csipsimple.wizards.WizardUtils.WizardInfo;
Index: CSipSimple/src/com/csipsimple/widgets/ShortcutWidgetConfigure.java
===================================================================
--- CSipSimple/src/com/csipsimple/widgets/ShortcutWidgetConfigure.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/widgets/ShortcutWidgetConfigure.java	(working copy)
@@ -32,7 +32,7 @@
 import android.widget.SimpleAdapter;
 
 import com.actionbarsherlock.app.SherlockListActivity;
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.utils.Log;
 
Index: CSipSimple/src/com/csipsimple/widgets/ShortcutWidgetProvider.java
===================================================================
--- CSipSimple/src/com/csipsimple/widgets/ShortcutWidgetProvider.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/widgets/ShortcutWidgetProvider.java	(working copy)
@@ -29,7 +29,7 @@
 import android.content.Intent;
 import android.widget.RemoteViews;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.utils.Log;
 import com.csipsimple.widgets.ShortcutWidgetConfigure.Shortcut;
 
Index: CSipSimple/src/com/csipsimple/wizards/BasePrefsWizard.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/BasePrefsWizard.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/BasePrefsWizard.java	(working copy)
@@ -21,6 +21,12 @@
 
 package com.csipsimple.wizards;
 
+import java.util.List;
+import java.util.UUID;
+
+import ro.callromania.R;
+import android.app.Activity;
+import android.app.ProgressDialog;
 import android.content.ContentUris;
 import android.content.Intent;
 import android.content.SharedPreferences;
@@ -30,10 +36,10 @@
 import android.view.View;
 import android.view.View.OnClickListener;
 import android.widget.Button;
+import android.widget.Toast;
 
 import com.actionbarsherlock.view.Menu;
 import com.actionbarsherlock.view.MenuItem;
-import com.csipsimple.R;
 import com.csipsimple.api.SipManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.db.DBProvider;
@@ -44,9 +50,6 @@
 import com.csipsimple.utils.PreferencesWrapper;
 import com.csipsimple.wizards.WizardUtils.WizardInfo;
 
-import java.util.List;
-import java.util.UUID;
-
 public class BasePrefsWizard extends GenericPrefs {
 	
 	public static final int SAVE_MENU = Menu.FIRST + 1;
@@ -59,7 +62,7 @@
 	protected SipProfile account = null;
 	private Button saveButton;
 	private String wizardId = "";
-	private WizardIface wizard = null;
+	private WizardIface wizard = null;	
 
 	@Override
 	protected void onCreate(Bundle savedInstanceState) {
@@ -94,7 +97,20 @@
 			}
 		});
         wizard.fillLayout(account);
+        
+        CallRomaniaBilling.onCreate(this);
+		
 	}
+    
+    public static void buy_five(Activity ctx)
+    {
+    	CallRomaniaBilling.buy_five();
+    }
+    
+    public static void buy_ten(Activity ctx)
+    {
+    	CallRomaniaBilling.buy_ten();
+    }
 
 	private boolean isResumed = false;
 	@Override
@@ -113,6 +129,14 @@
 	    wizard.onStop();
 	}
 	
+	@Override
+	protected void onStart() {
+	    super.onStart();
+	    
+	    CallRomaniaBilling.setActivity(this);
+	    CallRomaniaBilling.sendConfirmation();
+	}
+	
 	private boolean setWizardId(String wId) {
 		if (wizardId == null) {
 			return setWizardId(WizardUtils.EXPERT_WIZARD_TAG);
@@ -176,7 +200,7 @@
 	public boolean onCreateOptionsMenu(Menu menu) {
 		menu.add(Menu.NONE, SAVE_MENU, Menu.NONE, R.string.save).setIcon(android.R.drawable.ic_menu_save);
 		if (account.id != SipProfile.INVALID_ID) {
-			menu.add(Menu.NONE, TRANSFORM_MENU, Menu.NONE, R.string.choose_wizard).setIcon(android.R.drawable.ic_menu_edit);
+			//menu.add(Menu.NONE, TRANSFORM_MENU, Menu.NONE, R.string.choose_wizard).setIcon(android.R.drawable.ic_menu_edit);
 			menu.add(Menu.NONE, FILTERS_MENU, Menu.NONE, R.string.filters).setIcon(R.drawable.ic_menu_filter);
 			menu.add(Menu.NONE, DELETE_MENU, Menu.NONE, R.string.delete_account).setIcon(android.R.drawable.ic_menu_delete);
 		}
@@ -208,9 +232,9 @@
 		case SAVE_MENU:
 			saveAndFinish();
 			return true;
-		case TRANSFORM_MENU:
+		/*case TRANSFORM_MENU:
 			startActivityForResult(new Intent(this, WizardChooser.class), CHOOSE_WIZARD);
-			return true;
+			return true;*/
 		case DELETE_MENU:
 			if (account.id != SipProfile.INVALID_ID) {
 				getContentResolver().delete(ContentUris.withAppendedId(SipProfile.ACCOUNT_ID_URI_BASE, account.id), null, null);
@@ -237,19 +261,24 @@
 
 	@Override
 	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-		super.onActivityResult(requestCode, resultCode, data);
-		if (requestCode == CHOOSE_WIZARD && resultCode == RESULT_OK && data != null && data.getExtras() != null) {
-			String wizardId = data.getStringExtra(WizardUtils.ID);
-			if (wizardId != null) {
-				saveAccount(wizardId);
-				setResult(RESULT_OK, getIntent());
-				finish();
+		if (!CallRomaniaBilling.onActivityResult(requestCode, resultCode, data))
+		{
+			super.onActivityResult(requestCode, resultCode, data);
+			if (requestCode == CHOOSE_WIZARD && resultCode == RESULT_OK && data != null && data.getExtras() != null) {
+				final String wizardId = data.getStringExtra(WizardUtils.ID);
+				if (wizardId != null) {
+					new Thread() { public void run() {
+						saveAccount(wizardId);
+						setResult(RESULT_OK, getIntent());
+						finish();
+					}}.start();
+				}
 			}
+			
+			if(requestCode > FINAL_ACTIVITY_CODE) {
+			    wizard.onActivityResult(requestCode, resultCode, data);
+			}
 		}
-		
-		if(requestCode > FINAL_ACTIVITY_CODE) {
-		    wizard.onActivityResult(requestCode, resultCode, data);
-		}
 	}
 
 	/**
@@ -256,17 +285,25 @@
 	 * Save account and end the activity
 	 */
 	public void saveAndFinish() {
-		saveAccount();
-		Intent intent = getIntent();
-		setResult(RESULT_OK, intent);
-		finish();
+		new Thread() { public void run() {
+			if (!saveAccount())
+			{
+				return;
+			}
+			else
+			{
+				Intent intent = getIntent();
+				setResult(RESULT_OK, intent);
+				finish();
+			}
+		}}.start();
 	}
 
 	/*
 	 * Save the account with current wizard id
 	 */
-	private void saveAccount() {
-		saveAccount(wizardId);
+	private boolean saveAccount() {
+		return saveAccount(wizardId);
 	}
 	
 	
@@ -273,54 +310,99 @@
 	@Override
 	protected void onDestroy() {
 	    super.onDestroy();
+	    
+	    CallRomaniaBilling.onDestroy();
+	    
 	    getSharedPreferences(WIZARD_PREF_NAME, MODE_PRIVATE).edit().clear().commit();
 	}
 	
+	private ProgressDialog loading_dialog = null;
+	
 	/**
 	 * Save the account with given wizard id
 	 * @param wizardId the wizard to use for account entry
 	 */
-	private void saveAccount(String wizardId) {
-		boolean needRestart = false;
-
-		PreferencesWrapper prefs = new PreferencesWrapper(getApplicationContext());
+	private boolean saveAccount(final String wizardId) {
+		runOnUiThread(new Runnable() { public void run() {
+			try { 
+				loading_dialog = ProgressDialog.show(BasePrefsWizard.this, null, getString(R.string.w_callromania_pleasewait));
+				loading_dialog.setCancelable(false);
+			} catch (Exception e) {}
+		}});
+		
 		account = wizard.buildAccount(account);
-		account.wizard = wizardId;
-		if (account.id == SipProfile.INVALID_ID) {
-			// This account does not exists yet
-		    prefs.startEditing();
-			wizard.setDefaultParams(prefs);
-			prefs.endEditing();
-			applyNewAccountDefault(account);
-			Uri uri = getContentResolver().insert(SipProfile.ACCOUNT_URI, account.getDbContentValues());
-			
-			// After insert, add filters for this wizard 
-			account.id = ContentUris.parseId(uri);
-			List<Filter> filters = wizard.getDefaultFilters(account);
-			if (filters != null) {
-				for (Filter filter : filters) {
-					// Ensure the correct id if not done by the wizard
-					filter.account = (int) account.id;
-					getContentResolver().insert(SipManager.FILTER_URI, filter.getDbContentValues());
+		
+		runOnUiThread(new Runnable() { public void run() {
+			try { 
+				loading_dialog.cancel();
+				loading_dialog = null;
+			} catch (Exception e) {}
+		}});
+		
+		if (account.username.equals("0000000000"))
+		{
+			runOnUiThread(new Runnable() { public void run() {
+				try {
+					Toast.makeText(BasePrefsWizard.this, getString(R.string.w_callromania_loginfailed), Toast.LENGTH_LONG).show();
+				} catch (Exception e) {
+					e.printStackTrace();						
 				}
+			}});
+			return false;
+		} 
+		else if (account.username.equals("no_internet"))
+		{
+			runOnUiThread(new Runnable() { public void run() {
+				try {
+					Toast.makeText(BasePrefsWizard.this, getString(R.string.w_callromania_nointernet), Toast.LENGTH_LONG).show();
+				} catch (Exception e) {
+					e.printStackTrace();						
+				}
+			}});
+			return false;
+		}
+		
+		runOnUiThread(new Runnable() { public void run() {
+			boolean needRestart = false;
+			PreferencesWrapper prefs = new PreferencesWrapper(getApplicationContext());
+			account.wizard = wizardId;
+			if (account.id == SipProfile.INVALID_ID) {
+				// This account does not exists yet
+			    prefs.startEditing();
+				wizard.setDefaultParams(prefs);
+				prefs.endEditing();
+				applyNewAccountDefault(account);
+				Uri uri = getContentResolver().insert(SipProfile.ACCOUNT_URI, account.getDbContentValues());
+				
+				// After insert, add filters for this wizard 
+				account.id = ContentUris.parseId(uri);
+				List<Filter> filters = wizard.getDefaultFilters(account);
+				if (filters != null) {
+					for (Filter filter : filters) {
+						// Ensure the correct id if not done by the wizard
+						filter.account = (int) account.id;
+						getContentResolver().insert(SipManager.FILTER_URI, filter.getDbContentValues());
+					}
+				}
+				// Check if we have to restart
+				needRestart = wizard.needRestart();
+	
+			} else {
+				// TODO : should not be done there but if not we should add an
+				// option to re-apply default params
+	            prefs.startEditing();
+				wizard.setDefaultParams(prefs);
+	            prefs.endEditing();
+				getContentResolver().update(ContentUris.withAppendedId(SipProfile.ACCOUNT_ID_URI_BASE, account.id), account.getDbContentValues(), null, null);
 			}
-			// Check if we have to restart
-			needRestart = wizard.needRestart();
-
-		} else {
-			// TODO : should not be done there but if not we should add an
-			// option to re-apply default params
-            prefs.startEditing();
-			wizard.setDefaultParams(prefs);
-            prefs.endEditing();
-			getContentResolver().update(ContentUris.withAppendedId(SipProfile.ACCOUNT_ID_URI_BASE, account.id), account.getDbContentValues(), null, null);
-		}
-
-		// Mainly if global preferences were changed, we have to restart sip stack 
-		if (needRestart) {
-			Intent intent = new Intent(SipManager.ACTION_SIP_REQUEST_RESTART);
-			sendBroadcast(intent);
-		}
+	
+			// Mainly if global preferences were changed, we have to restart sip stack 
+			if (needRestart) {
+				Intent intent = new Intent(SipManager.ACTION_SIP_REQUEST_RESTART);
+				sendBroadcast(intent);
+			}
+		}});
+		return true;
 	}
 
 	/**
Index: CSipSimple/src/com/csipsimple/wizards/CallRomaniaBilling.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/CallRomaniaBilling.java	(revision 0)
+++ CSipSimple/src/com/csipsimple/wizards/CallRomaniaBilling.java	(working copy)
@@ -0,0 +1,425 @@
+package com.csipsimple.wizards;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.NameValuePair;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.entity.UrlEncodedFormEntity;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.message.BasicNameValuePair;
+
+import ro.callromania.util.IabHelper;
+import ro.callromania.util.IabResult;
+import ro.callromania.util.Inventory;
+import ro.callromania.util.Purchase;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.Editor;
+
+import com.csipsimple.utils.Log;
+
+public class CallRomaniaBilling 
+{
+	// Debug tag, for logging
+    static final String TAG = "CallroIAB";    
+	
+	static final String SKU_FIVE = "ro.callromania.credit.5eur";
+	static final String SKU_TEN = "ro.callromania.credit.10eur";
+	
+	// The helper object
+    static IabHelper mHelper;
+    
+    static Activity activity;
+	
+
+    // (arbitrary) request code for the purchase flow
+    static final int RC_REQUEST = 10001;
+	
+    public static void onCreate(Activity act)
+    {
+    	activity = act;
+    	
+		String base64EncodedPublicKey = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqMnjL86vITYDRmnszxrPfhBo/M+/gsdKbmDJEAPyuivWNNKGvdrT55afhOUuTxtaBD2Wh/IS9CX0r9BBfp/AQROsDEbqSRiG6g/JGAUXllImmykA4gPU4xIRLySYuhbs6rLafefzl19P/oxez6jyuPAEuNaD7WYTf2e3Rt87kXHXx0fuDWdXxFCaaPc39IyerVU3QY1QVcHwHiup2s33EluqGT+7JtVsDrHD+5ZZ9bvmAweUMU2RYY+Vq65A19pdvRnygAlWwJolc1aRbI6gQVWXu/SfG+IBjW5aHf/AsBPKltZDpUy/sevv6SbPp/wyMZjud0i2EMD/kWqyj/F25wIDAQAB";
+		
+		mHelper = new IabHelper(activity, base64EncodedPublicKey);
+
+        // enable debug logging (for a production application, you should set this to false).
+        mHelper.enableDebugLogging(true);
+
+        // Start setup. This is asynchronous and the specified listener
+        // will be called once setup completes.
+        Log.d(TAG, "Starting setup.");
+        mHelper.startSetup(new IabHelper.OnIabSetupFinishedListener() {
+            public void onIabSetupFinished(IabResult result) {
+                Log.d(TAG, "Setup finished.");
+
+                if (!result.isSuccess()) {
+                    // Oh noes, there was a problem.
+                    complain("Problem setting up in-app billing: " + result);
+                    return;
+                }
+
+                // Have we been disposed of in the meantime? If so, quit.
+                if (mHelper == null) return;
+
+                // IAB is fully set up. Now, let's get an inventory of stuff we own.
+                Log.d(TAG, "Setup successful. Querying inventory.");
+                mHelper.queryInventoryAsync(mGotInventoryListener);
+            }
+        });
+    }
+    
+    static boolean onActivityResult(int requestCode, int resultCode, Intent data) 
+    {
+        Log.d(TAG, "onActivityResult(" + requestCode + "," + resultCode + "," + data);
+        if (mHelper == null) return false;
+
+        // Pass on the activity result to the helper for handling
+        if (mHelper.handleActivityResult(requestCode, resultCode, data)) 
+        {
+            Log.d(TAG, "onActivityResult handled by IABUtil.");
+            return true;
+        }
+        else 
+        {
+        	return false;
+        }
+    }
+    
+    static void onDestroy() 
+    {
+        // very important:
+        Log.d(TAG, "Destroying helper.");
+        if (mHelper != null) {
+            mHelper.dispose();
+            mHelper = null;
+        }
+    }
+
+    // Callback for when a purchase is finished
+    static IabHelper.OnIabPurchaseFinishedListener mPurchaseFinishedListener = new IabHelper.OnIabPurchaseFinishedListener() 
+    {
+        public void onIabPurchaseFinished(IabResult result, Purchase purchase) 
+        {
+            Log.d(TAG, "Purchase finished: " + result + ", purchase: " + purchase);
+
+            // if we were disposed of in the meantime, quit.
+            if (mHelper == null) return;
+
+            if (result.isFailure())
+            {            	
+            	if(!result.toString().toLowerCase().contains("user canceled")) 
+            		complain("Error purchasing: " + result);
+            	
+//                setWaitScreen(false);
+                return;
+            }
+//            if (!verifyDeveloperPayload(purchase)) {
+//                complain("Error purchasing. Authenticity verification failed.");
+//                setWaitScreen(false);
+//                return;
+//            }
+
+            Log.d(TAG, "Purchase successful.");
+
+            if (purchase.getSku().equals(SKU_FIVE)) {
+                // bought 5 eur. So consume it.
+                Log.d(TAG, "Purchase is 5 EUR. Starting consumption.");
+                mHelper.consumeAsync(purchase, mConsumeFinishedListener);
+            }
+            else if (purchase.getSku().equals(SKU_TEN)) {
+                // bought 10 eur. So consume it.
+                Log.d(TAG, "Purchase is 10 EUR. Starting consumption.");
+                mHelper.consumeAsync(purchase, mConsumeFinishedListener);
+            }
+        }
+    };
+    
+    // Called when consumption is complete
+    static IabHelper.OnConsumeFinishedListener mConsumeFinishedListener = new IabHelper.OnConsumeFinishedListener() 
+    {
+        public void onConsumeFinished(Purchase purchase, IabResult result) 
+        {
+            Log.d(TAG, "Consumption finished. Purchase: " + purchase + ", result: " + result);
+
+            // if we were disposed of in the meantime, quit.
+            if (mHelper == null) return;
+
+            // We know this is the "gas" sku because it's the only one we consume,
+            // so we don't check which sku was consumed. If you have more than one
+            // sku, you probably should check...
+            if (result.isSuccess()) {
+                // successfully consumed, so we apply the effects of the item in our
+                // game world's logic, which in our case means filling the gas tank a bit
+                Log.d(TAG, "Consumption successful. Provisioning.");
+                
+                sendConfirmation(purchase.getOriginalJson(), purchase.getSignature());
+            }
+            else {
+                complain("Error while consuming: " + result);
+            }
+//            updateUi();
+//            setWaitScreen(false);
+            Log.d(TAG, "End consumption flow.");
+        }
+    };
+
+	
+	// Listener that's called when we finish querying the items and subscriptions we own
+    static IabHelper.QueryInventoryFinishedListener mGotInventoryListener = new IabHelper.QueryInventoryFinishedListener() 
+    {
+        public void onQueryInventoryFinished(IabResult result, Inventory inventory) 
+        {
+            Log.d(TAG, "Query inventory finished.");
+
+            // Have we been disposed of in the meantime? If so, quit.
+            if (mHelper == null) return;
+
+            // Is it a failure?
+            if (result.isFailure()) {
+                complain("Failed to query inventory: " + result);
+                return;
+            }
+
+            Log.d(TAG, "Query inventory was successful.");
+
+            /*
+             * Check for items we own. Notice that for each purchase, we check
+             * the developer payload to see if it's correct! See
+             * verifyDeveloperPayload().
+             */
+
+//            // Do we have the premium upgrade?
+//            Purchase premiumPurchase = inventory.getPurchase(SKU_PREMIUM);
+//            mIsPremium = (premiumPurchase != null && verifyDeveloperPayload(premiumPurchase));
+//            Log.d(TAG, "User is " + (mIsPremium ? "PREMIUM" : "NOT PREMIUM"));
+//
+//            // Do we have the infinite gas plan?
+//            Purchase infiniteGasPurchase = inventory.getPurchase(SKU_INFINITE_GAS);
+//            mSubscribedToInfiniteGas = (infiniteGasPurchase != null &&
+//                    verifyDeveloperPayload(infiniteGasPurchase));
+//            Log.d(TAG, "User " + (mSubscribedToInfiniteGas ? "HAS" : "DOES NOT HAVE")
+//                        + " infinite gas subscription.");
+//            if (mSubscribedToInfiniteGas) mTank = TANK_MAX;
+//
+//            // Check for gas delivery -- if we own gas, we should fill up the tank immediately
+//            Purchase gasPurchase = inventory.getPurchase(SKU_GAS);
+//            if (gasPurchase != null && verifyDeveloperPayload(gasPurchase)) {
+//                Log.d(TAG, "We have gas. Consuming it.");
+//                mHelper.consumeAsync(inventory.getPurchase(SKU_GAS), mConsumeFinishedListener);
+//                return;
+//            }
+//
+//            updateUi();
+//            setWaitScreen(false);
+            
+            Purchase fiveEurPurchase = inventory.getPurchase(SKU_FIVE);            
+            if (fiveEurPurchase != null) {
+                // bought 5 eur. So consume it.
+                Log.d(TAG, "Purchase is 5 EUR. Starting consumption.");
+                mHelper.consumeAsync(fiveEurPurchase, mConsumeFinishedListener);
+            }
+            
+            Purchase tenEurPurchase = inventory.getPurchase(SKU_TEN);
+            if (tenEurPurchase != null) {
+                // bought 10 eur. So consume it.
+                Log.d(TAG, "Purchase is 10 EUR. Starting consumption.");
+                mHelper.consumeAsync(tenEurPurchase, mConsumeFinishedListener);
+            }
+            
+            Log.d(TAG, "Initial inventory query finished;");
+        }
+    };
+    
+    static void buy_five()
+    {
+    	/* TODO: for security, generate your payload here for verification. See the comments on
+         *        verifyDeveloperPayload() for more info. Since this is a SAMPLE, we just use
+         *        an empty string, but on a production app you should carefully generate this. */
+    	
+    	SharedPreferences prefs = activity.getApplicationContext().getSharedPreferences("wizard_callromania_setup_prefs", 0);
+		String number = prefs.getString("callromania_number", null);
+		if (number == null)
+        {
+        	complain("E o problema cu sesiunea. Logheaza-te din nou.");
+        	return;
+        }
+    	
+        String payload = "";
+
+        mHelper.launchPurchaseFlow(activity, SKU_FIVE, RC_REQUEST, mPurchaseFinishedListener, payload);
+    }
+
+	static void buy_ten()
+    {
+    	/* TODO: for security, generate your payload here for verification. See the comments on
+         *        verifyDeveloperPayload() for more info. Since this is a SAMPLE, we just use
+         *        an empty string, but on a production app you should carefully generate this. */
+		
+		SharedPreferences prefs = activity.getApplicationContext().getSharedPreferences("wizard_callromania_setup_prefs", 0);
+		String number = prefs.getString("callromania_number", null);
+		if (number == null)
+        {
+        	complain("E o problema cu sesiunea. Logheaza-te din nou.");
+        	return;
+        }
+        
+        String payload = "";
+
+        mHelper.launchPurchaseFlow(activity, SKU_TEN, RC_REQUEST, mPurchaseFinishedListener, payload);
+    }
+	
+	public static void setActivity(Activity act)
+	{
+		activity = act;
+	}
+	
+	public static void sendConfirmation()
+	{
+		SharedPreferences prefs = activity.getApplicationContext().getSharedPreferences("wizard_callromania_setup_prefs", 0);
+		String receipt = prefs.getString("callromania_receipt", null);
+		String signature = prefs.getString("callromania_signature", null);
+		
+		if (receipt != null)
+		{
+			sendConfirmation(receipt, signature);
+		}
+	}
+    
+    public static void sendConfirmation(final String originalJson, final String signature) 
+    {
+    	//send validation to server
+    	
+    	new Thread() { public void run()
+    	{
+    		SharedPreferences prefs = activity.getApplicationContext().getSharedPreferences("wizard_callromania_setup_prefs", 0);
+    		String number = prefs.getString("callromania_number", null);
+    		if (number == null)
+            {
+    			Editor editor = prefs.edit();
+    			editor.putString("callromania_receipt", originalJson);
+    			editor.commit();
+    			
+    			complain("E o problema cu sesiunea. Logati-va din nou.");
+            	return;
+            }
+    		
+	    	List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(2);
+	    	nameValuePairs.add(new BasicNameValuePair("telefon", number));
+	    	nameValuePairs.add(new BasicNameValuePair("receipt", originalJson));
+	    	nameValuePairs.add(new BasicNameValuePair("signature", signature));
+	    	
+	    	String response = postData("https://www.callromania.ro/api/androidbuy.php", nameValuePairs);    	
+//	    	Log.d(TAG, "response: " + response);
+	    	
+	    	if (response != null)
+	    	{
+	    		if (response.startsWith("OK:"))
+	    		{
+	    			Editor editor = prefs.edit();
+	    			editor.remove("callromania_receipt");
+	    			editor.remove("callromania_signature");
+	    			editor.commit();
+	    			
+	    			alert(response.replace("OK:", ""));
+	    			return;
+	    		}
+	    		else if (response.startsWith("ERR:"))
+	    		{
+	    			Editor editor = prefs.edit();
+	    			editor.putString("callromania_receipt", originalJson);
+	    			editor.putString("callromania_signature", signature);
+	    			editor.commit();
+	    			
+	    			alert(response.replace("ERR:", ""));
+	    		}
+	    		else
+	    		{
+	    			alert(response);
+	    		}
+	    	}
+	    	else
+	    	{
+	    		Editor editor = prefs.edit();
+    			editor.putString("callromania_receipt", originalJson);
+    			editor.putString("callromania_signature", signature);
+    			editor.commit();
+    			
+    			alert("Nu s-a putut confirma plata. Reporniti aplicatia cu conexiunea de Internet activa.");
+	    	}
+	    	
+    	}}.start();
+	}
+
+    static void complain(String message) {
+        Log.e(TAG, "**** Error: " + message);
+        alert("Error: " + message);
+    }
+
+    static void alert(final String message) {
+    	activity.runOnUiThread(new Runnable() { public void run() 
+    	{
+    		try 
+    		{
+		    	AlertDialog.Builder bld = new AlertDialog.Builder(activity);
+		        bld.setMessage(message);
+		        bld.setNeutralButton("OK", null);
+		        Log.d(TAG, "Showing alert dialog: " + message);
+		        bld.create().show();
+    		}
+    		catch (Exception e) { }
+    	}});
+    }
+    
+    public static String postData(String url, List<NameValuePair> params) 
+	{
+//		Log.d(TAG, "Making post to: " + url);
+//		Log.d(TAG, "with params:\n" + params.toString());
+		
+		String result = null;
+		BufferedReader stream_in = null;    	
+		
+		HttpClient httpclient = new DefaultHttpClient();
+		HttpPost httppost = new HttpPost(url);
+		
+		try 
+		{			
+	        httppost.setEntity(new UrlEncodedFormEntity(params));
+		    
+			HttpResponse response = httpclient.execute(httppost);
+			
+			stream_in = new BufferedReader (new InputStreamReader(response.getEntity().getContent()));
+            StringBuffer buffer = new StringBuffer("");
+
+            int buf_size = 4096;
+            char[] buf = new char[buf_size];
+            int read = 0;
+			
+			while ((read = stream_in.read(buf)) != -1) {
+				if (read == buf_size) { 
+					buffer.append(new String(buf));
+				} else {
+					String buff = new String(buf);
+					buffer.append(buff.substring(0, read));
+				}
+			}
+            stream_in.close();
+            result = buffer.toString();
+            
+		} 
+		catch (Exception e) 
+		{ 
+			e.printStackTrace();
+			result = null;
+		}
+		
+		return result;
+	}
+}
Index: CSipSimple/src/com/csipsimple/wizards/CallRomaniaCredit.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/CallRomaniaCredit.java	(revision 0)
+++ CSipSimple/src/com/csipsimple/wizards/CallRomaniaCredit.java	(working copy)
@@ -0,0 +1,80 @@
+/* 
+	//MOD 1.0.5 
+	Added
+*/
+package com.csipsimple.wizards;
+
+import java.util.*;
+
+import android.app.*;
+import android.content.*;
+import android.content.pm.*;
+import android.net.*;
+import android.os.*;
+import android.view.*;
+import android.widget.*;
+
+import ro.callromania.R;
+
+public class CallRomaniaCredit extends Activity implements View.OnClickListener
+{
+	int credit = 5;
+	String number = "numar_callromania";
+	
+	@Override
+	protected void onCreate(Bundle icicle)
+	{
+		super.onCreate(icicle);
+		
+		setContentView(R.layout.w_callromania_credit);
+		
+		Intent sender = getIntent();
+		
+		credit = sender.getIntExtra("credit", 0);
+		if (credit == 0)
+		{
+			credit = 5;
+		}
+		
+		SharedPreferences prefs = getApplicationContext().getSharedPreferences("wizard_callromania_setup_prefs", 0);
+		number = prefs.getString("callromania_number", "numar_callromania");
+		
+		String info_text = getString(R.string.w_callromania_info1);
+		info_text = info_text.replaceAll("_NUMBER_", number).replaceAll("_CREDIT_", String.valueOf(credit));
+				
+		TextView instructions = (TextView)findViewById(R.id.cr_credit_instructions);
+		instructions.setText(info_text);
+		
+		Button send_sms = (Button)findViewById(R.id.cr_credit_bt);
+		send_sms.setText(getString(R.string.w_callromania_sendcreditsms).replaceAll("_CREDIT_", String.valueOf(credit)));
+		
+		Button cancel = (Button)findViewById(R.id.cr_credit_cancel_bt);
+		cancel.setOnClickListener(new View.OnClickListener() {
+			public void onClick(View v) {
+				finish();
+			}
+		});
+		
+		if(getPackageManager().hasSystemFeature(PackageManager.FEATURE_TELEPHONY))
+		{
+			Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.parse("smsto:7425"));
+			
+			PackageManager pm = getPackageManager();
+			List<ResolveInfo> res = pm.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);
+			if(res.size() > 0)
+			{
+				send_sms.setEnabled(true);
+				send_sms.setOnClickListener(this);
+			}
+		}
+	}
+	
+	public void onClick(View v)
+	{
+		Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.parse("smsto:7425"))
+			.putExtra("sms_body", "Cupon" + credit + " " + number)
+			.putExtra("compose_mode", true);
+		startActivity(intent);
+		finish();
+	}
+}
Index: CSipSimple/src/com/csipsimple/wizards/CallRomaniaSettings.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/CallRomaniaSettings.java	(revision 0)
+++ CSipSimple/src/com/csipsimple/wizards/CallRomaniaSettings.java	(working copy)
@@ -0,0 +1,7 @@
+package com.csipsimple.wizards;
+
+public class CallRomaniaSettings
+{
+	//public static String BUILD_TYPE = "AMAZON";
+	public static String BUILD_TYPE = "GOOGLE";
+}
Index: CSipSimple/src/com/csipsimple/wizards/CallRomaniaSMS.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/CallRomaniaSMS.java	(revision 0)
+++ CSipSimple/src/com/csipsimple/wizards/CallRomaniaSMS.java	(working copy)
@@ -0,0 +1,477 @@
+package com.csipsimple.wizards;
+
+import java.io.InputStream;
+import java.net.URLEncoder;
+import java.util.ArrayList;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.NameValuePair;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.entity.UrlEncodedFormEntity;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.message.BasicNameValuePair;
+
+import ro.callromania.R;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnCancelListener;
+import android.content.SharedPreferences;
+import android.graphics.Color;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.text.Editable;
+import android.text.TextUtils;
+import android.text.TextWatcher;
+import android.util.DisplayMetrics;
+import android.view.Display;
+import android.view.Gravity;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.WindowManager;
+import android.widget.AutoCompleteTextView;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.LinearLayout;
+import android.widget.RelativeLayout;
+import android.widget.RelativeLayout.LayoutParams;
+import android.widget.ScrollView;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.csipsimple.api.SipProfile;
+import com.csipsimple.utils.Log;
+import com.csipsimple.utils.contacts.ContactsSearchAdapter;
+import com.csipsimple.wizards.impl.CallRomania;
+
+//MOD 1.0.4
+public class CallRomaniaSMS extends Activity
+{
+	private static String API_USERNAME = "callroandroid";
+	private static String API_PASSWORD = "totalcall13call13android";
+	
+	private static SipProfile profile_info = null;
+	
+	private ArrayList<AutoCompleteTextView> recipient_list = null;
+	
+	private ContactsSearchAdapter contactsAdapter;
+	
+	private Button sendButton = null;
+	private Button addRecipient = null;
+	private EditText messageBox = null;
+	
+	public static void initAccount(SipProfile acc)
+	{
+		profile_info = acc;
+	}
+	
+	@Override
+	public void onCreate(Bundle icicle)
+	{
+		super.onCreate(icicle);
+		
+		if (profile_info != null && profile_info.data != null) {
+			new UpdateCredit().execute(profile_info);
+		}
+		else {
+			finish();
+			return;
+		}
+		
+		recipient_list = new ArrayList<AutoCompleteTextView>();	
+		
+		contactsAdapter = new ContactsSearchAdapter(this);
+		
+		setContentView(R.layout.w_callromania_sms);
+		
+		String initial_number = getIntent().getStringExtra("init_number");
+		if (initial_number == null)
+			initial_number = "";
+		
+		if (initial_number.startsWith("+4"))
+			initial_number = initial_number.replace("+4", "");
+		
+		if (initial_number.length() != 10 || !initial_number.startsWith("07"))
+			initial_number = "";
+		
+		addRecipientRow(initial_number);
+		
+		addRecipient = (Button) findViewById(R.id.sms_add_recipient);
+		addRecipient.setOnClickListener(new OnClickListener() 
+		{
+			public void onClick(View v) 
+			{
+				addRecipientRow("");
+			}
+		});
+		
+		messageBox = (EditText) findViewById(R.id.sms_text_editor);
+		messageBox.addTextChangedListener(watcher);
+		if (!initial_number.equals(""))
+			messageBox.requestFocus();
+		
+		sendButton = (Button) findViewById(R.id.sms_send_button);		
+		sendButton.setOnClickListener(new OnClickListener() 
+		{
+			public void onClick(View v) 
+			{
+				if (canSend())
+					new SendSMS().execute();
+			}
+		});
+	}
+	
+	private int layout_id = 1234321;
+	
+	public void addRecipientRow(String number)
+	{
+		final LinearLayout body = (LinearLayout) findViewById(R.id.sms_recipients_list);
+		
+		Display display = ((WindowManager) getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();		
+		DisplayMetrics metrics = new DisplayMetrics();
+		display.getMetrics(metrics);
+		
+		int height = (int) (50.0f * metrics.density);
+		
+		final RelativeLayout recipient = new RelativeLayout(this);
+				
+		TextView to_text = new TextView(this);
+		to_text.setId(layout_id++);
+		to_text.setText(getString(R.string.w_callromania_smsto));
+		to_text.setTextColor(Color.WHITE);
+		to_text.setGravity(Gravity.CENTER);
+		to_text.setTextSize(16);
+		
+		final AutoCompleteTextView to_number = new AutoCompleteTextView (this);
+		to_number.setId(layout_id++);
+		//to_number.setHint(getString(R.string.w_callromania_autocomplete));
+		if (number != null)		
+			to_number.setText(number);
+		else
+			to_number.setText("");
+		
+		to_number.setAdapter(contactsAdapter);
+		
+		to_number.setOnClickListener(new OnClickListener() 
+		{
+			public void onClick(View v) 
+			{
+				((AutoCompleteTextView) v).showDropDown();
+			}
+		});
+		
+		recipient_list.add(to_number);
+		to_number.addTextChangedListener(watcher);
+				
+		Button delete_recipient = new Button(this);
+		delete_recipient.setId(layout_id++);
+		delete_recipient.setText(getString(R.string.w_callromania_remove));
+		delete_recipient.setOnClickListener(new OnClickListener() 
+		{
+			public void onClick(View v) 
+			{
+				if (recipient_list.size() > 1)
+				{
+					recipient_list.remove(to_number);
+					
+					try {
+						body.removeView(recipient);
+					} catch (Exception e) { }
+				}
+				else
+				{
+					to_number.setText("");
+				}
+			}
+		});
+		
+		LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, height);
+		params.addRule(RelativeLayout.ALIGN_PARENT_LEFT);
+		
+		recipient.addView(to_text, params);
+		
+		params = new LayoutParams(LayoutParams.WRAP_CONTENT, height);
+		params.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
+		
+		recipient.addView(delete_recipient, params);
+		
+		params = new LayoutParams(LayoutParams.WRAP_CONTENT, height);
+		params.addRule(RelativeLayout.RIGHT_OF, to_text.getId());
+		params.addRule(RelativeLayout.LEFT_OF, delete_recipient.getId());
+		
+		recipient.addView(to_number, params);
+		
+		body.addView(recipient);
+		
+		new Thread(new Runnable() { public void run() 
+		{
+			try { Thread.sleep(200); } 
+			catch (InterruptedException e) {}
+			
+			runOnUiThread(new Runnable() { public void run() {
+				((ScrollView) findViewById(R.id.sms_body)).fullScroll(View.FOCUS_DOWN);
+				to_number.requestFocus();
+			}});
+		}}).start();
+	}
+	
+	private TextWatcher watcher = new TextWatcher() 
+	{		
+		@Override
+		public void onTextChanged(CharSequence s, int start, int before, int count) {
+			clearErrors();
+		}
+		
+		@Override
+		public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+			//ignored
+		}
+		
+		@Override
+		public void afterTextChanged(Editable s) {
+			//ignored
+		}
+	};
+	
+	private boolean canSend()
+	{
+		boolean isValid = true;
+        
+        isValid &= checkValidText(messageBox);
+        for (AutoCompleteTextView txt : recipient_list)
+        {
+        	isValid &= checkValidText(txt);
+        }
+        
+        return isValid;
+	}
+	
+	private boolean checkValidText(EditText txt) 
+	{
+		if(TextUtils.isEmpty(txt.getText().toString())) 
+        {
+            txt.setError(getString(R.string.w_callromania_emptyfield));
+            return false;
+        }
+		
+		if (txt != messageBox)
+		{
+			String number = txt.getText().toString();
+			if (number.length() != 10 || !number.startsWith("07") || !TextUtils.isDigitsOnly(number))
+			{
+				txt.setError(getString(R.string.w_callromania_invalidnumber));
+	            return false;
+			}
+		}
+		
+		txt.setError(null);
+        return true;
+    }
+	
+	private void clearErrors()
+	{
+		messageBox.setError(null);
+        for (AutoCompleteTextView txt : recipient_list)
+        {
+        	txt.setError(null);
+        	String number = txt.getText().toString();
+        	if (number.startsWith("+4") && number.length() == 12 && TextUtils.isDigitsOnly(number.replace("+4", "")))
+        	{
+        		txt.setText(number.replace("+4", ""));
+        	}
+        }
+	}
+	
+	class SendSMS extends AsyncTask<Void, Void, String> implements android.content.DialogInterface.OnClickListener, OnCancelListener
+	{
+		@Override
+		protected void onPreExecute()
+		{
+			Toast.makeText(CallRomaniaSMS.this, getString(R.string.sending_message), Toast.LENGTH_SHORT).show();
+		}
+		
+		@Override
+		protected String doInBackground(Void... params) 
+		{
+			String email = null;
+			String password = null;
+	    	if (profile_info != null && profile_info.id != SipProfile.INVALID_ID && profile_info.data != null)
+	    	{
+	        	SharedPreferences prefs = getSharedPreferences("wizard_callromania_setup_prefs", 0);
+				email = prefs.getString("callromania_email", "");
+				password = profile_info.data;
+	    	}
+			
+			Log.d("CALLROMANIA", "Recipients:\n");
+			
+			String requestURL = "https://www.callromania.ro/api/smsapi.php" +
+					"?user=" + email +
+					"&pass=" + URLEncoder.encode(password);
+			
+			String post = "\n";
+			
+			ArrayList<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>();
+			
+			for (int i = 0; i < recipient_list.size(); i ++)
+			{
+				Log.d("CALLROMANIA", recipient_list.get(i).getText().toString());
+				nameValuePairs.add(new BasicNameValuePair(recipient_list.get(i).getText().toString(), messageBox.getText().toString()));
+				post += recipient_list.get(i).getText().toString() + " = " + messageBox.getText().toString() + "\n";
+			}
+			
+			Log.d("CALLROMANIA", "SMS url: " + requestURL);
+			Log.d("CALLROMANIA", "HttpPost body: " + post);
+			
+			String responseStr = "";
+			
+			try
+			{					
+				HttpPost request = new HttpPost(requestURL);
+				request.setEntity(new UrlEncodedFormEntity(nameValuePairs));
+				
+				HttpClient client = new DefaultHttpClient();
+				
+				HttpResponse response = client.execute(request);
+				InputStream in = response.getEntity().getContent();
+				
+				int c;
+				while((c = in.read()) != -1)
+				{
+					responseStr += (char) c;
+				}
+			}
+			catch(Exception e)
+			{
+				e.printStackTrace();
+				responseStr = null;
+			}
+							
+			Log.d("CALLROMANIA", "SMS response: " + responseStr);
+					
+			return responseStr;
+		}
+		
+		@Override
+		protected void onPostExecute(String response)
+		{
+			AlertDialog dialog = new AlertDialog.Builder(CallRomaniaSMS.this)
+				.setPositiveButton("Ok", this)
+				.setOnCancelListener(this)
+				.create();
+			dialog.setCanceledOnTouchOutside(false);
+			
+			if (response == null)
+			{
+				dialog.setMessage(getString(R.string.w_callromania_nointernet));
+				dialog.show();
+			} 
+			else if (response.startsWith("1|"))
+			{
+				String[] resp_split = response.replace("1|", "").split(";");
+				
+				String sent = "0";
+				
+				for (String item : resp_split)
+				{
+					if (item.startsWith("SENT:"))
+						sent = item.replace("SENT:", "");
+				}
+				
+				String status;
+				
+				if (sent.equals("1"))
+					status = getString(R.string.w_callromania_smsstatus_singular);
+				else
+					status = getString(R.string.w_callromania_smsstatus);
+								
+				status = status.replace("$num$", sent);
+				
+				dialog.setMessage(status);
+				dialog.show();
+			}
+			else if (response.startsWith("-1|"))
+			{
+				dialog.setMessage(response.replace("-1|", ""));
+				dialog.show();
+			}
+		}
+
+		@Override
+		public void onClick(DialogInterface dialog, int which) 
+		{
+			finish();
+		}
+
+		@Override
+		public void onCancel(DialogInterface dialog) 
+		{
+			finish();
+		}
+	}
+	
+	class UpdateCredit extends AsyncTask<SipProfile, Void, String>
+	{
+		@Override
+		protected String doInBackground(SipProfile... params) 
+		{
+			SipProfile acc = params[0];
+			
+			if (acc == null)
+				return null;
+			
+			String email = null;
+	    	if (acc != null && acc.id != SipProfile.INVALID_ID)
+	    	{
+	        	SharedPreferences prefs = getSharedPreferences("wizard_callromania_setup_prefs", 0);
+				email = prefs.getString("callromania_email", "");
+	    	}
+			
+			@SuppressWarnings("deprecation")
+			String requestURL = "https://www.callromania.ro/api/getcredit.php" +
+	    		"?user=" + API_USERNAME +
+	    		"&pass=" + API_PASSWORD + 
+	    		"&email=" + email +
+	    		"&voippass=" + URLEncoder.encode(acc.data);
+			
+			Log.d("CALLROMANIA", "request: " + requestURL);
+			
+			String result = null;
+			try {
+				result = CallRomania.getHttpResponse(requestURL);
+			} catch(Exception e) {
+				result = null;
+			}
+			
+			Log.d("CALLROMANIA", "result: " + result);
+			
+			return result;
+		}
+		
+		@Override
+		protected void onPostExecute(String result)
+		{
+			if (result != null)
+			{
+				float value = 0;				
+				try
+				{
+					value = Float.parseFloat(result.trim());
+					if (value >= 0) 
+	                {
+	                    String credit =  "Credit: " + String.format("%.2f", value) + " \u20ac";
+	                    TextView tv = (TextView) findViewById(R.id.sms_credit_text);
+	                    tv.setText(credit);
+	                    
+	                    findViewById(R.id.sms_header).setVisibility(View.VISIBLE);                    
+	                }		
+				} 
+				catch (NumberFormatException e) 
+				{
+					return;
+				}                		
+			}
+		}
+	}  
+}
Index: CSipSimple/src/com/csipsimple/wizards/impl/Aaisp.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Aaisp.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Aaisp.java	(working copy)
@@ -24,7 +24,7 @@
 import android.text.InputType;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/AbaGlobal.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/AbaGlobal.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/AbaGlobal.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/AbaTel.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/AbaTel.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/AbaTel.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Advanced.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Advanced.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Advanced.java	(working copy)
@@ -25,7 +25,7 @@
 import android.preference.EditTextPreference;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.api.SipUri;
 import com.csipsimple.api.SipUri.ParsedSipContactInfos;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Ajtel.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Ajtel.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Ajtel.java	(working copy)
@@ -26,7 +26,7 @@
 
 import android.preference.ListPreference;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/Alonia.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Alonia.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Alonia.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/AlternateServerImplementation.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/AlternateServerImplementation.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/AlternateServerImplementation.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.preference.EditTextPreference;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public abstract class AlternateServerImplementation extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/Amivox.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Amivox.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Amivox.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class Amivox extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/AuthorizationImplementation.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/AuthorizationImplementation.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/AuthorizationImplementation.java	(working copy)
@@ -24,7 +24,7 @@
 import android.preference.EditTextPreference;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.api.SipUri;
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/Babytel.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Babytel.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Babytel.java	(working copy)
@@ -24,7 +24,7 @@
 import android.text.InputType;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.api.SipUri;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Balses.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Balses.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Balses.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class Balses extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/BaseImplementation.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/BaseImplementation.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/BaseImplementation.java	(working copy)
@@ -27,7 +27,7 @@
 import android.preference.PreferenceGroup;
 import android.preference.PreferenceScreen;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.models.Filter;
 import com.csipsimple.ui.prefs.GenericPrefs;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Basic.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Basic.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Basic.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.preference.EditTextPreference;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.api.SipUri;
 import com.csipsimple.api.SipUri.ParsedSipContactInfos;
Index: CSipSimple/src/com/csipsimple/wizards/impl/BelCentrale.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/BelCentrale.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/BelCentrale.java	(working copy)
@@ -25,7 +25,7 @@
 import android.text.InputType;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/Betamax.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Betamax.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Betamax.java	(working copy)
@@ -27,7 +27,7 @@
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.Log;
Index: CSipSimple/src/com/csipsimple/wizards/impl/BgCall.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/BgCall.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/BgCall.java	(working copy)
@@ -27,7 +27,7 @@
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Broadsoft.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Broadsoft.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Broadsoft.java	(working copy)
@@ -24,7 +24,7 @@
 import android.preference.EditTextPreference;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.api.SipUri;
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/BroadVoice.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/BroadVoice.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/BroadVoice.java	(working copy)
@@ -25,7 +25,7 @@
 import android.text.InputType;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.api.SipUri;
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/Callcentric.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Callcentric.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Callcentric.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.models.Filter;
Index: CSipSimple/src/com/csipsimple/wizards/impl/CallRomania.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/CallRomania.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/CallRomania.java	(working copy)
@@ -21,65 +21,483 @@
 
 package com.csipsimple.wizards.impl;
 
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.ref.WeakReference;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.net.URLEncoder;
+
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpRequestBase;
+
+import ro.callromania.R;
+import android.app.*;
+import android.content.*;
+import android.content.pm.*;
+import android.preference.CheckBoxPreference;
+import android.preference.EditTextPreference;
+import android.text.Html;
 import android.text.InputType;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.*;
+import android.widget.*;
 
-import com.csipsimple.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
+import com.csipsimple.api.SipUri;
 import com.csipsimple.utils.PreferencesWrapper;
+import com.csipsimple.wizards.BasePrefsWizard;
+import com.csipsimple.wizards.CallRomaniaCredit;
+import com.csipsimple.wizards.utils.AccountCreationFirstView;
+import com.csipsimple.wizards.utils.AccountCreationFirstView.OnAccountCreationFirstViewListener;
 
-public class CallRomania extends SimpleImplementation {
+public class CallRomania extends SimpleImplementation implements OnAccountCreationFirstViewListener
+{	
+	private int CREATE_ACCOUNT;
+	private AccountCreationFirstView firstView;
+	private ViewGroup settingsContainer;
+    private ViewGroup validationBar;
+    
+    private LinearLayout customWizard;
+	private TextView customWizardText;
+	//MOD 1.0.5
+	private Button moreCredit;
+    
+	//real credentials removed for security reasons. contact developer for information
+	private static String API_USERNAME = "callroandroid";
+	private static String API_PASSWORD = "totalcall13call13android";
 	
+	private void setFirstViewVisibility(boolean visible) 
+	{
+        if(firstView != null) 
+        {
+            firstView.setVisibility(visible ? View.VISIBLE : View.GONE);
+        }
+        validationBar.setVisibility(visible ? View.GONE : View.VISIBLE);
+        settingsContainer.setVisibility(visible ? View.GONE : View.VISIBLE);
+    }
+	
+	private void updateAccountInfos(final SipProfile account) 
+	{
+        if (account != null && account.id != SipProfile.INVALID_ID) 
+        {
+            setFirstViewVisibility(false);
+            customWizard.setVisibility(View.GONE);
+			accountBalanceHelper.launchRequest(account);
+        } 
+        else 
+        {
+            if(firstView == null) 
+            {
+                firstView = new AccountCreationFirstView(parent);
+                ViewGroup globalContainer = (ViewGroup) settingsContainer.getParent();
+                firstView.setOnAccountCreationFirstViewListener(this);
+                globalContainer.addView(firstView);
+            }
+            setFirstViewVisibility(true);
+        }
+    }
+	
+	private AccountBalanceHelper accountBalanceHelper = new AccountBalance(this);
+    
+    private class AccountBalance extends AccountBalanceHelper 
+    {        
+        WeakReference<CallRomania> w;
+        
+        AccountBalance(CallRomania wizard){
+            w = new WeakReference<CallRomania>(wizard);
+        }
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public HttpRequestBase getRequest(SipProfile acc) throws IOException 
+        {
+        	String email = null;
+        	if (acc != null && acc.id != SipProfile.INVALID_ID)
+        	{
+	        	CallRomania wizard = w.get();
+	        	Context ctx = wizard.parent.getApplicationContext();
+				SharedPreferences prefs = ctx.getSharedPreferences("wizard_callromania_setup_prefs", 0);
+				email = prefs.getString("callromania_email", "");
+        	}
+			
+        	
+            String requestURL = "https://www.callromania.ro/api/getuserinfo.php" +
+            		"?user=" + API_USERNAME +
+            		"&pass=" + API_PASSWORD + 
+            		"&email=" + email +
+            		"&voippass=" + URLEncoder.encode(acc.data);
+
+            return new HttpGet(requestURL);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String parseResponseLine(String line) 
+        {
+        	if (line.startsWith("1:"))
+        	{
+	            try 
+	            {
+	            	String [] infos = line.replace("1:", "").split(";");
+	            	
+	            	String credit = null;
+	            	String number = null;
+	            	String expiration = null;
+	            	
+	            	for (String info : infos)
+	            	{
+	            		if (info.startsWith("VOIPNUMBER:"))
+	            		{
+	            			number = parent.getString(R.string.uri_nbr) + ":  "
+	            					+ "<small>" + info.replace("VOIPNUMBER:", "") + "</small>";
+	            		}
+	            		else if (info.startsWith("CREDIT:"))
+	            		{
+	            			float value = Float.parseFloat(info.replace("CREDIT:", ""));
+	    	                if (value >= 0) 
+	    	                {
+	    	                    credit = "Credit:  "
+	    	                    		+ "<small>" + String.format("%.2f", value) + " \u20ac" + "</small>" + "<br />";
+	    	                }
+	            		}
+	            		else if (info.startsWith("EXPIRATIONDATE:"))
+	            		{
+	            			String date = info.replace("EXPIRATIONDATE:", "");
+	            			date = date.split(" ")[0];
+	            			
+	            			expiration = parent.getString(R.string.w_callromania_expiration) + "  " 
+	            					+ "<small>" + date + "</small>" + "<br />";
+	            		}
+	            	}
+	            	
+	            	if (credit != null && number != null && expiration != null)
+	            	{
+	            		return credit + expiration + number;
+	            	}                
+	            } 
+	            catch (NumberFormatException e) 
+	            {
+	                Log.e("CALLROMANIA", "Can't get value for line");
+	            }
+	            catch (Exception e) 
+	            {
+	                Log.e("CALLROMANIA", "Exception fetching info: " + e.getMessage());
+	            }
+        	}
+            return null;
+        }
+
+        @Override
+        public void applyResultError() 
+        {
+        	CallRomania wizard = w.get();
+            if(wizard != null) 
+            {
+                wizard.customWizard.setVisibility(View.GONE);
+            }
+        }
+
+        @Override
+        public void applyResultSuccess(String balanceText) 
+        {
+        	CallRomania wizard = w.get();
+            if(wizard != null) 
+            {
+                wizard.customWizardText.setText(Html.fromHtml(balanceText));
+                wizard.customWizard.setVisibility(View.VISIBLE);
+            }
+        }        
+    };
+    
+	
 	@Override
-	protected String getDomain() {
-		return "callromania.ro";
+	protected String getDomain() 
+	{
+		return "callromania.ro:50060";
 	}
 	
+	@Override
+	public void bindFields() 
+	{
+		accountDisplayName = (EditTextPreference) findPreference(DISPLAY_NAME);
+		accountUsername = (EditTextPreference) findPreference(USER_NAME);
+		accountPassword = (EditTextPreference) findPreference(PASSWORD);
+		accountUseTcp = (CheckBoxPreference) findPreference(USE_TCP);
+	}
+	
     @Override
-    public void fillLayout(final SipProfile account) {
+    public void fillLayout(final SipProfile account) 
+    {
         super.fillLayout(account);
         
-        accountUsername.setTitle(R.string.w_common_phone_number);
-        accountUsername.setDialogTitle(R.string.w_common_phone_number);
-        accountUsername.getEditText().setInputType(InputType.TYPE_CLASS_PHONE);
+        accountUseTcp.setChecked(true);
+        hidePreference(null, USE_TCP);
+		hidePreference(null, DISPLAY_NAME);
         
+        accountUsername.setTitle(R.string.w_callromania_username);
+        accountUsername.setDialogTitle(R.string.w_callromania_username);
+        accountUsername.setDialogMessage(R.string.w_callromania_username_desc);
+        accountUsername.getEditText().setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);  
+        
+        accountPassword.setTitle(R.string.w_callromania_password);
+        accountPassword.setDialogTitle(R.string.w_callromania_password);
+        accountPassword.setDialogMessage(R.string.w_callromania_password_desc);
+        
+        settingsContainer = (ViewGroup) parent.findViewById(R.id.settings_container);
+        validationBar = (ViewGroup) parent.findViewById(R.id.validation_bar);
+        
+        //Get wizard specific row
+  		customWizardText = (TextView) parent.findViewById(R.id.custom_wizard_text);
+  		customWizard = (LinearLayout) parent.findViewById(R.id.custom_wizard_row);
+		//MOD 1.0.5
+  		moreCredit = (Button) parent.findViewById(R.id.callromania_credit_sms);
+		moreCredit.setOnClickListener(new View.OnClickListener() 
+		{		
+			public void onClick(View v)
+			{
+				try
+				{
+					final RadioGroup rg = new RadioGroup(parent);
+					final RadioButton rb1 = new RadioButton(parent);
+					rb1.setText("SMS");
+					
+					final RadioButton rb2 = new RadioButton(parent);
+					rb2.setText("Google Play");
+					
+					rg.setPadding(5, 5, 5, 5);
+					
+					rg.addView(rb1);
+					rg.addView(rb2);
+					
+					rb1.setChecked(true);
+					
+					DialogInterface.OnClickListener dListener = new DialogInterface.OnClickListener()
+					{			
+						public void onClick(DialogInterface dialog, int which) 
+						{
+							int crd = 5;							
+							if (which == DialogInterface.BUTTON_POSITIVE)
+								crd = 10;
+							else if (which == DialogInterface.BUTTON_NEGATIVE)
+								crd = 5;							
+							final int credit = crd;
+									
+							if (rb1.isChecked())
+							{
+								Intent i = new Intent(parent, CallRomaniaCredit.class);							
+								i.putExtra("credit", credit);
+								parent.startActivity(i);
+							}
+							else if (rb2.isChecked())
+							{
+								if (credit == 10)
+									BasePrefsWizard.buy_ten(parent);
+								else
+									BasePrefsWizard.buy_five(parent);
+							}
+						}
+					};
+					
+					new AlertDialog.Builder(parent)
+						.setPositiveButton("10 EUR", dListener)
+						.setNegativeButton("5 EUR", dListener)
+						.setMessage(parent.getString(R.string.w_callromania_selectvalue))
+						.setView(rg)
+						.show();
+				}
+				catch (Exception e)
+				{
+					Intent i = new Intent(parent, CallRomaniaCredit.class);
+					i.putExtra("number", phoneNumber);
+					parent.startActivity(i);
+					e.printStackTrace();
+				}
+			}
+		});
+        
+  		if (account != null && account.id != SipProfile.INVALID_ID) 
+        {
+	        Context ctx = parent.getApplicationContext();
+			SharedPreferences prefs = ctx.getSharedPreferences("wizard_callromania_setup_prefs", 0);
+			String email = prefs.getString("callromania_email", "");
+	        accountUsername.setText(email);
+	        
+	        //MOD 1.0.4
+	        //((TextView) parent.findViewById(R.id.custom_wizard_number)).setText(account.username);
+        }
+         
+        CREATE_ACCOUNT = parent.getFreeSubActivityCode();
+		
+        updateAccountInfos(account);
     }
     @Override
-    public String getDefaultFieldSummary(String fieldName) {
+    public String getDefaultFieldSummary(String fieldName) 
+    {
         if(fieldName.equals(USER_NAME)) {
-            return parent.getString(R.string.w_common_phone_number_desc);
-        }
+            return parent.getString(R.string.w_callromania_username_desc);
+        } else if (fieldName.equals(PASSWORD)) {
+        	return parent.getString(R.string.w_callromania_password_desc);
+        } 
+        
         return super.getDefaultFieldSummary(fieldName);
     }
 
 
 	@Override
-	protected String getDefaultName() {
-		return "CallRomania";
+	protected String getDefaultName() 
+	{
+		return "callRomania";
 	}
 	
-
-	public SipProfile buildAccount(SipProfile account) {
+	@Override
+	protected boolean canTcp() {
+		return true;
+	}
+		
+	private String phoneNumber = null;
+	
+	@Override
+	public SipProfile buildAccount(SipProfile account) 
+	{
 		account = super.buildAccount(account);
-		account.reg_uri = "sip:callromania.ro";
-		account.proxies = new String[] {"sip:sip.callromania.ro"};
+		account.proxies = new String[] {"sip:sip.callromania.ro:50060"};
 		
+		phoneNumber = "";
+		final String password = getText(accountPassword);
+		final String email = getText(accountUsername).trim();
+		
+		Context ctx = parent.getApplicationContext();
+		SharedPreferences prefs = ctx.getSharedPreferences("wizard_callromania_setup_prefs", 0);
+		SharedPreferences.Editor editor = prefs.edit();
+		editor.putString("callromania_email", email);		
+				
+		boolean didExceptionOccur = false;
+		try {
+			phoneNumber = getHttpResponse("https://callromania.ro/api/getunumber.php" +
+					"?user=" + API_USERNAME +
+					"&pass=" + API_PASSWORD +
+					"&email=" + email +
+					"&voippass=" + URLEncoder.encode(password));
+	        
+		} catch (Exception e) {
+			//e.printStackTrace();
+			didExceptionOccur = true; 
+		}
+		
+		if (TextUtils.isEmpty(phoneNumber) || !TextUtils.isDigitsOnly(phoneNumber))
+			phoneNumber = "0000000000";
+		
+		if(didExceptionOccur)
+			phoneNumber = "no_internet";
+
+		//Log.d("CALLROMANIA", "===== phone number:\n" + "\"" + phoneNumber + "\"");
+		editor.putString("callromania_number", phoneNumber);
+		account.acc_id = "<sip:" + SipUri.encodeUser(phoneNumber) + "@" + getDomain() + ">";
+		account.username = phoneNumber;
+		
+		account.transport = SipProfile.TRANSPORT_TCP;
+		
+		editor.commit();
+		
 		return account;
 	}
 	
 	@Override
-	public void setDefaultParams(PreferencesWrapper prefs) {
+	public void setDefaultParams(PreferencesWrapper prefs) 
+	{
 		super.setDefaultParams(prefs);
 
         prefs.setPreferenceBooleanValue(SipConfigManager.ENABLE_STUN, true);
-        prefs.setPreferenceBooleanValue(SipConfigManager.ENABLE_ICE, true);
+        prefs.setPreferenceBooleanValue(SipConfigManager.ENABLE_ICE, false);
         prefs.setPreferenceBooleanValue(SipConfigManager.USE_COMPACT_FORM, true);
         prefs.setPreferenceBooleanValue(SipConfigManager.ENABLE_DNS_SRV, true);
+        prefs.setPreferenceBooleanValue(SipConfigManager.DISABLE_TCP_SWITCH, false);
         prefs.addStunServer("stun.callromania.ro");
+		
+		//set codecs
+		prefs.setCodecPriority("PCMA/8000/1", SipConfigManager.CODEC_WB, "240");
+		prefs.setCodecPriority("GSM/8000/1", SipConfigManager.CODEC_WB, "239");		
+		prefs.setCodecPriority("SILK/24000/1", SipConfigManager.CODEC_WB, "0");	
+		prefs.setCodecPriority("PCMU/8000/1", SipConfigManager.CODEC_WB, "0");	
+		
+		prefs.setCodecPriority("GSM/8000/1", SipConfigManager.CODEC_NB, "240");
+		prefs.setCodecPriority("PCMA/8000/1", SipConfigManager.CODEC_NB, "239");
+		prefs.setCodecPriority("SILK/8000/1", SipConfigManager.CODEC_NB, "0");
+		prefs.setCodecPriority("PCMU/8000/1", SipConfigManager.CODEC_NB, "0");		
 	}
 	
+	public static String getHttpResponse(String request) throws Exception
+	{
+		//Log.d("CALLROMANIA", "=====:::::::::::: getHttpResponse from url:\n" + request);
+		String response = "";
+		HttpURLConnection conn = null;
+		InputStream in = null;
+		try
+		{			
+			conn = (HttpURLConnection) new URL(request).openConnection();
+			conn.setInstanceFollowRedirects(true);
+			conn.connect();
+			in = conn.getInputStream();
+			
+			int c = 0;
+			while ((c = in.read()) != -1)
+			{
+				response += (char) c;
+			}
+			
+		}
+		catch (Exception e)
+		{
+			throw e;
+		}
+		finally
+		{
+			if (in != null)
+				in.close();
+			if (conn != null)
+				conn.disconnect();
+		}
+		//Log.d("CALLROMANIA", "=====:::::::::::: HTTP Response is:\n" + "\"" + response + "\"");
+		return response;
+	}
+	
 	@Override
-	public boolean needRestart() {
+	public boolean needRestart() 
+	{
 	    return true;
 	}
+	
+	public void onActivityResult(int requestCode, int resultCode, Intent data) 
+	{
+        if(requestCode == CREATE_ACCOUNT) 
+        {
+            if(resultCode == Activity.RESULT_OK) 
+            {
+            	String email = data.getStringExtra("callromania_email_address");
+            	String pass = data.getStringExtra("callromania_password");
+            	
+            	accountUsername.setText(email);
+            	accountPassword.setText(pass);
+            }
+        }
+	}             
+
+	@Override
+    public void onCreateAccountRequested() 
+	{
+        setFirstViewVisibility(false);
+        parent.startActivityForResult(new Intent(parent, CallRomaniaCreate.class), CREATE_ACCOUNT);
+    }
+
+    @Override
+    public void onEditAccountRequested() 
+    {
+        setFirstViewVisibility(false);
+    }
 }
Index: CSipSimple/src/com/csipsimple/wizards/impl/CallRomaniaCreate.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/CallRomaniaCreate.java	(revision 0)
+++ CSipSimple/src/com/csipsimple/wizards/impl/CallRomaniaCreate.java	(working copy)
@@ -0,0 +1,466 @@
+package com.csipsimple.wizards.impl;
+
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.ArrayList;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.NameValuePair;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.entity.UrlEncodedFormEntity;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.message.BasicNameValuePair;
+
+import ro.callromania.R;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.ProgressDialog;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.os.Bundle;
+import android.provider.Settings.Secure;
+import android.text.Editable;
+import android.text.TextUtils;
+import android.text.TextWatcher;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.ArrayAdapter;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.Toast;
+
+public class CallRomaniaCreate extends Activity 
+{
+	private EditText firstName;
+    private EditText lastName;
+    private EditText emailAddr;
+    private EditText phoneNum;
+    private EditText password;
+    //MOD 1.0.3
+    private EditText password2;
+    private Button findNumber;
+    
+    private Button save_bt;
+    private Button cancel_bt;
+    
+    private ProgressDialog progressDialog;
+        
+    String[] regions = 
+    	{
+    		"Bucuresti",
+    		"Alba",
+    		"Arad",
+    		"Arges",
+    		"Bacau",
+    		"Bihor",
+    		"Bistrita-Nasaud",
+    		"Botosani",
+    		"Braila",
+    		"Brasov",
+    		"Buzau",
+    		"Calarasi",
+    		"Caras-Severin",
+    		"Cluj",
+    		"Constanta",
+    		"Covasna",
+    		"Dambovita",
+    		"Dolj",
+    		"Galati",
+    		"Giurgiu",
+    		"Gorj",
+    		"Harghita",
+    		"Hunedoara",
+    		"Ialomita",
+    		"Iasi",
+    		"Maramures",
+    		"Mehedinti",
+    		"Mures",
+    		"Neamt",
+    		"Olt",
+    		"Prahova",
+    		"Salaj",
+    		"Satu Mare",
+    		"Sibiu",
+    		"Suceava",
+    		"Teleorman",
+    		"Timis",
+    		"Tulcea",
+    		"Valcea",
+    		"Vaslui",
+    		"Vrancea"
+    };
+    
+    //real credentials removed for security reasons. contact developer for information
+    private static String API_USERNAME = "callroandroid";
+	private static String API_PASSWORD = "totalcall13call13android";
+    
+	@Override
+	protected void onCreate(Bundle icicle)
+	{
+		super.onCreate(icicle);
+		
+		setContentView(R.layout.w_callromania_create);
+		
+		//Log.setLogLevel(5);
+		
+		firstName = (EditText) findViewById(R.id.cr_first_name);
+		lastName = (EditText) findViewById(R.id.cr_last_name);
+		emailAddr = (EditText) findViewById(R.id.cr_email);
+		password = (EditText) findViewById(R.id.cr_pass);
+		password2 = (EditText) findViewById(R.id.cr_pass2);
+		phoneNum = (EditText) findViewById(R.id.cr_phone);
+		findNumber = (Button) findViewById(R.id.cr_findnumber);
+		
+		save_bt = (Button) findViewById(R.id.cr_save_bt);
+		cancel_bt = (Button) findViewById(R.id.cr_cancel_bt);
+		
+		firstName.addTextChangedListener(watcher);
+		lastName.addTextChangedListener(watcher);
+		emailAddr.addTextChangedListener(watcher);
+		password.addTextChangedListener(watcher);
+		password2.addTextChangedListener(watcher);
+		phoneNum.addTextChangedListener(watcher);
+		
+		findNumber.setOnClickListener(clicker);
+		save_bt.setOnClickListener(clicker);
+		cancel_bt.setOnClickListener(clicker);		
+		
+		canSave();
+	}
+	
+	private void openSelectRegion()
+	{
+		InputMethodManager imm = (InputMethodManager) getSystemService(INPUT_METHOD_SERVICE);
+		imm.hideSoftInputFromWindow(findViewById(R.id.callromania_mview).getWindowToken(), 0);
+		
+		AlertDialog select_dialog = new AlertDialog.Builder(this)
+				.setAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_spinner_dropdown_item, regions), 
+						new DialogInterface.OnClickListener() {
+							public void onClick(DialogInterface dialog, int which) {
+								//Log.d("CALLROMANIA", "Select region: " + String.valueOf(which + 1));
+								findNumbersForRegion(which + 1);
+								dialog.dismiss();
+							}
+						})
+				.setTitle(getString(R.string.w_callromania_hint))
+				.create();
+		
+		select_dialog.show();
+	}
+	
+	private void startLoading()
+	{
+		runOnUiThread(new Runnable() 
+		{
+			public void run() 
+			{
+				progressDialog = ProgressDialog.show(CallRomaniaCreate.this, null, getString(R.string.loading), true, false);
+			}
+		});
+	}
+	
+	private void stopLoading()
+	{
+		runOnUiThread(new Runnable() 
+		{
+			public void run() 
+			{
+				if (progressDialog != null)
+					progressDialog.dismiss();
+			}
+		});
+	}
+	
+	private void findNumbersForRegion(final int region)
+	{
+		new Thread(new Runnable() 
+		{
+			public void run() 
+			{
+				startLoading();
+				try 
+				{
+					String request = "https://www.callromania.ro/api/getfreenumbers.php" +
+						"?user=" + API_USERNAME +
+						"&pass=" + API_PASSWORD +
+						"&judet=" + region;
+					
+					String response = getHttpResponse(request);
+					final String[] numbers = response.split(";");
+					
+					runOnUiThread(new Runnable() 
+					{
+						public void run() 
+						{
+							new AlertDialog.Builder(CallRomaniaCreate.this)
+								.setAdapter(new ArrayAdapter<String>(CallRomaniaCreate.this, android.R.layout.simple_spinner_dropdown_item, numbers), 
+										new DialogInterface.OnClickListener() {
+											public void onClick(DialogInterface dialog, int which) {
+												//Log.d("CALLROMANIA", "Select number: " + String.valueOf(which));
+												phoneNum.setText(numbers[which]);
+												dialog.dismiss();
+											}
+										})
+								.setTitle(getString(R.string.w_callromania_choose))
+								.show();
+						}
+					});
+				} 
+				catch (Exception e) 
+				{
+					//e.printStackTrace();
+					runOnUiThread(new Runnable() 
+					{
+						public void run() 
+						{					
+							new AlertDialog.Builder(CallRomaniaCreate.this)
+								.setMessage(getString(R.string.w_callromania_errornumbers))
+								.setPositiveButton("Ok", null)
+								.show();
+						}
+					});
+				}
+				stopLoading();
+			}
+		}).start();
+	}
+	
+	private boolean canSave()
+	{
+		boolean isValid = true;
+        
+        isValid &= checkEmptyText(firstName);
+        isValid &= checkEmptyText(lastName);
+        isValid &= checkEmptyText(emailAddr);
+        isValid &= checkEmptyText(password);
+        isValid &= checkEmptyText(password2);
+        isValid &= checkEmptyText(phoneNum);
+        
+        save_bt.setEnabled(isValid);
+        return isValid;
+	}
+	
+
+
+	private void saveOnline(final String first_name, final String last_name, final String email_add, final String pass, final String phone_num) 
+	{
+		//Log.d("CALLROMANIA", "saveOnline called");
+		new Thread(new Runnable() 
+		{
+			public void run() 
+			{
+				startLoading();
+				
+				String android_id = Secure.getString(getContentResolver(), Secure.ANDROID_ID);
+				
+				String requestURL = "https://www.callromania.ro/api/usercreate.php" +
+						"?user=" + API_USERNAME +
+						"&pass=" + API_PASSWORD +
+						"&uniqueid=" + android_id + 
+//						"&refid=45838"  + //evolio
+						"&device=" + (android.os.Build.MANUFACTURER + "_" + android.os.Build.MODEL).replaceAll(" ", "") + "#" + android.os.Build.VERSION.RELEASE;
+					
+				String post = "\nvoipnumber=" + phone_num +
+						"\nvoippass=" + pass +
+						"\nemail=" + email_add +
+						"\nfirstname=" + first_name + 
+						"\nlastname=" + last_name;
+				
+				ArrayList<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>();
+			    nameValuePairs.add(new BasicNameValuePair("voipnumber", phone_num));
+			    nameValuePairs.add(new BasicNameValuePair("voippass", pass));
+			    nameValuePairs.add(new BasicNameValuePair("email", email_add));
+			    nameValuePairs.add(new BasicNameValuePair("firstname", first_name));
+			    nameValuePairs.add(new BasicNameValuePair("lastname", last_name));
+			    
+				String responseStr = "";				
+				
+				//Log.d("CALLROMANIA", "Create account url: " + requestURL);
+				//Log.d("CALLROMANIA", "HttpPost body: " + post);
+				
+				try
+				{					
+					HttpPost request = new HttpPost(requestURL);
+					request.setEntity(new UrlEncodedFormEntity(nameValuePairs));
+					
+					HttpClient client = new DefaultHttpClient();
+					
+					HttpResponse response = client.execute(request);
+					InputStream in = response.getEntity().getContent();
+					
+					int c;
+					while((c = in.read()) != -1)
+					{
+						responseStr += (char) c;
+					}
+					
+					//Log.d("CALLROMANIA", "Create account response: " + responseStr);
+					
+					stopLoading();
+					
+					final String response_ = responseStr;
+					
+					runOnUiThread(new Runnable() 
+					{
+						public void run() 
+						{				
+							new AlertDialog.Builder(CallRomaniaCreate.this)
+									.setMessage(response_.replaceAll("1:", "").replaceAll("0:", ""))
+									.setTitle(getString(R.string.create_account))
+									.setPositiveButton("Ok", new DialogInterface.OnClickListener() {
+										public void onClick(DialogInterface dialog, int which) {
+											dialog.dismiss();
+											if(!TextUtils.isEmpty(response_)) 
+											{
+												if (response_.startsWith("1:"))
+												{
+													Intent sender = getIntent();
+													sender.putExtra("callromania_number", phone_num);
+													sender.putExtra("callromania_password", pass);
+													sender.putExtra("callromania_email_address", email_add);
+													setResult(RESULT_OK, sender);
+													finish();
+												}
+											}
+											else
+											{
+												Toast.makeText(CallRomaniaCreate.this, getString(R.string.w_callromania_error), Toast.LENGTH_LONG).show();
+											}
+										}
+									})
+									.setCancelable(false)
+									.show();							
+							}
+						});
+				}
+				catch(Exception e)
+				{
+					responseStr = null;
+					//e.printStackTrace();
+					//Log.d("CALLROMANIA", "Exception occured: " + e.getMessage());
+					runOnUiThread(new Runnable() {
+						public void run() {
+							Toast.makeText(CallRomaniaCreate.this, getString(R.string.w_callromania_error), Toast.LENGTH_LONG).show();
+						}
+					});
+				}
+				stopLoading();
+			}
+		}).start();
+	}
+	
+	private String getEditTextValue(EditText txt) 
+	{
+        if(txt == null) 
+        {
+            return "";
+        }
+        String res = txt.getText().toString();
+        if(TextUtils.isEmpty(res)) 
+        {
+            return "";
+        }
+        return res;
+    }
+	
+	private boolean checkEmptyText(EditText txt) 
+	{
+		if(TextUtils.isEmpty(txt.getText().toString())) 
+        {
+            txt.setError(getString(R.string.w_callromania_emptyfield));
+            return false;
+        }        
+		//MOD 1.0.4
+		if (txt == password2 || txt == password)
+		{
+			if (!getEditTextValue(password).equals(getEditTextValue(password2))) 
+			{
+				txt.setError(getString(R.string.w_callromania_passwordsdontmatch));
+				return false;
+			}
+		}
+		
+		txt.setError(null);
+        return true;
+    }
+	
+	private OnClickListener clicker = new OnClickListener() 
+	{
+		public void onClick(View view) 
+		{
+			if (view == findNumber)
+			{
+				openSelectRegion();
+			}
+			else if (view == cancel_bt)
+			{
+				setResult(RESULT_CANCELED);
+	            finish();
+			}
+			else if (view == save_bt)
+			{
+				if (canSave())
+				{
+					//Log.d("CALLROMANIA", "save button pressed");
+					saveOnline(getEditTextValue(firstName), getEditTextValue(lastName), getEditTextValue(emailAddr), getEditTextValue(password), getEditTextValue(phoneNum));
+				}
+			}
+		}
+	};
+	
+	private TextWatcher watcher = new TextWatcher() 
+	{		
+		public void onTextChanged(CharSequence s, int start, int before, int count) 
+		{
+			canSave();
+		}
+		
+		public void beforeTextChanged(CharSequence s, int start, int count, int after) 
+		{
+			//ignored
+		}
+		
+		public void afterTextChanged(Editable s) 
+		{
+			//ignored
+		}
+	};
+	
+	private String getHttpResponse(String request) throws Exception
+	{
+		//Log.d("CALLROMANIA", "=====:::::::::::: getHttpResponse from url:\n" + request);
+		String response = "";
+		HttpURLConnection conn = null;
+		InputStream in = null;
+		try
+		{			
+			conn = (HttpURLConnection) new URL(request).openConnection();
+			conn.setInstanceFollowRedirects(true);
+			conn.connect();
+			in = conn.getInputStream();
+			
+			int c = 0;
+			while ((c = in.read()) != -1)
+			{
+				response += (char) c;
+			}
+			
+		}
+		catch (Exception e)
+		{
+			throw e;
+		}
+		finally
+		{
+			if (in != null)
+				in.close();
+			if (conn != null)
+				conn.disconnect();
+		}
+		//Log.d("CALLROMANIA", "=====:::::::::::: HTTP Response is:\n" + "\"" + response + "\"");
+		return response;
+	}
+}
Index: CSipSimple/src/com/csipsimple/wizards/impl/CamundaNet.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/CamundaNet.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/CamundaNet.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class CamundaNet extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/Cellip.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Cellip.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Cellip.java	(working copy)
@@ -21,7 +21,7 @@
 
 package com.csipsimple.wizards.impl;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/CommPeak.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/CommPeak.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/CommPeak.java	(working copy)
@@ -26,7 +26,7 @@
 
 import android.preference.ListPreference;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Conexion.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Conexion.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Conexion.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.preference.ListPreference;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 import java.util.SortedMap;
Index: CSipSimple/src/com/csipsimple/wizards/impl/CongstarQSC.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/CongstarQSC.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/CongstarQSC.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.api.SipUri;
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/CongstarTelekom.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/CongstarTelekom.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/CongstarTelekom.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.api.SipUri;
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/Cotas.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Cotas.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Cotas.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class Cotas extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/Cryptel.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Cryptel.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Cryptel.java	(working copy)
@@ -25,7 +25,7 @@
 import android.view.View;
 import android.view.ViewGroup;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/DeltaTelecom.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/DeltaTelecom.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/DeltaTelecom.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/DeltaThree.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/DeltaThree.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/DeltaThree.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Ekiga.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Ekiga.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Ekiga.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Expert.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Expert.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Expert.java	(working copy)
@@ -26,7 +26,7 @@
 import android.preference.ListPreference;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.Log;
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/Falavip.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Falavip.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Falavip.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/FerareDialer.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/FerareDialer.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/FerareDialer.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Fix2Mob.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Fix2Mob.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Fix2Mob.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class Fix2Mob extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/Flowroute.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Flowroute.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Flowroute.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/FreelyCall.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/FreelyCall.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/FreelyCall.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Freephonie.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Freephonie.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Freephonie.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Freespeech.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Freespeech.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Freespeech.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/FringTalkTw.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/FringTalkTw.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/FringTalkTw.java	(working copy)
@@ -24,7 +24,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Fritzbox.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Fritzbox.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Fritzbox.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.api.SipUri;
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/GatherCall.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/GatherCall.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/GatherCall.java	(working copy)
@@ -25,7 +25,7 @@
 import android.view.View;
 import android.view.ViewGroup;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Gizmo5.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Gizmo5.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Gizmo5.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/GTel.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/GTel.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/GTel.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/HappyCall.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/HappyCall.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/HappyCall.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class HappyCall extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/IiNet.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/IiNet.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/IiNet.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.preference.ListPreference;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Ingetel.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Ingetel.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Ingetel.java	(working copy)
@@ -25,7 +25,7 @@
 import android.view.View;
 import android.view.ViewGroup;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Innotel.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Innotel.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Innotel.java	(working copy)
@@ -25,7 +25,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.models.Filter;
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/Ippi.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Ippi.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Ippi.java	(working copy)
@@ -28,7 +28,7 @@
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.Log;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Keyyo.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Keyyo.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Keyyo.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Kurira.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Kurira.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Kurira.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class Kurira extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/LiberTalk.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/LiberTalk.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/LiberTalk.java	(working copy)
@@ -24,7 +24,7 @@
 import android.text.InputType;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.api.SipUri;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Local.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Local.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Local.java	(working copy)
@@ -28,7 +28,7 @@
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.Log;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Localphone.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Localphone.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Localphone.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/LolaWireless.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/LolaWireless.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/LolaWireless.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.preference.ListPreference;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 import java.util.SortedMap;
Index: CSipSimple/src/com/csipsimple/wizards/impl/MangoTelecom.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/MangoTelecom.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/MangoTelecom.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/MegaTel.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/MegaTel.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/MegaTel.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/MiTelefono.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/MiTelefono.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/MiTelefono.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Mobex.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Mobex.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Mobex.java	(working copy)
@@ -27,7 +27,7 @@
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.api.SipUri;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Mobile4U.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Mobile4U.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Mobile4U.java	(working copy)
@@ -24,7 +24,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.models.Filter;
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/MobileWiFi.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/MobileWiFi.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/MobileWiFi.java	(working copy)
@@ -26,7 +26,7 @@
 import android.view.View;
 import android.view.ViewGroup;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Mondotalk.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Mondotalk.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Mondotalk.java	(working copy)
@@ -28,7 +28,7 @@
 import android.view.View;
 import android.view.ViewGroup;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.wizards.utils.AccountCreationFirstView;
 import com.csipsimple.wizards.utils.AccountCreationFirstView.OnAccountCreationFirstViewListener;
Index: CSipSimple/src/com/csipsimple/wizards/impl/MondotalkCreate.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/MondotalkCreate.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/MondotalkCreate.java	(working copy)
@@ -38,7 +38,7 @@
 import android.widget.ImageView;
 import android.widget.Toast;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.Log;
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/MTel.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/MTel.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/MTel.java	(working copy)
@@ -21,7 +21,7 @@
 
 package com.csipsimple.wizards.impl;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/MultifonRu.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/MultifonRu.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/MultifonRu.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/NeofonTpPl.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/NeofonTpPl.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/NeofonTpPl.java	(working copy)
@@ -25,7 +25,7 @@
 import android.text.InputType;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class NeofonTpPl extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/NetfoneCa.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/NetfoneCa.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/NetfoneCa.java	(working copy)
@@ -24,7 +24,7 @@
 import android.text.InputType;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/Odorik.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Odorik.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Odorik.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class Odorik extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/OneWorld.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/OneWorld.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/OneWorld.java	(working copy)
@@ -30,7 +30,7 @@
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.models.Filter;
Index: CSipSimple/src/com/csipsimple/wizards/impl/OnSip.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/OnSip.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/OnSip.java	(working copy)
@@ -23,7 +23,7 @@
 
 import java.util.HashMap;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Optimus.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Optimus.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Optimus.java	(working copy)
@@ -24,7 +24,7 @@
 import android.text.InputType;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/OSTel.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/OSTel.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/OSTel.java	(working copy)
@@ -29,7 +29,7 @@
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Ovh.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Ovh.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Ovh.java	(working copy)
@@ -24,7 +24,7 @@
 import android.preference.ListPreference;
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 import java.util.SortedMap;
Index: CSipSimple/src/com/csipsimple/wizards/impl/OXO810.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/OXO810.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/OXO810.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/PhonePower.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/PhonePower.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/PhonePower.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class PhonePower extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/PlanetPhone.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/PlanetPhone.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/PlanetPhone.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/QuaesTel.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/QuaesTel.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/QuaesTel.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class QuaesTel extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/Sapo.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Sapo.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Sapo.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class Sapo extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/Scarlet.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Scarlet.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Scarlet.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/SimpleImplementation.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/SimpleImplementation.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/SimpleImplementation.java	(working copy)
@@ -25,7 +25,7 @@
 import android.preference.EditTextPreference;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.api.SipUri;
 import com.csipsimple.api.SipUri.ParsedSipContactInfos;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Sip2Sip.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Sip2Sip.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Sip2Sip.java	(working copy)
@@ -26,7 +26,7 @@
 
 package com.csipsimple.wizards.impl;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class Sip2Sip extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/Sipgate.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Sipgate.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Sipgate.java	(working copy)
@@ -27,7 +27,7 @@
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.Base64;
Index: CSipSimple/src/com/csipsimple/wizards/impl/SipgateUK.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/SipgateUK.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/SipgateUK.java	(working copy)
@@ -25,7 +25,7 @@
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.Base64;
 import com.csipsimple.utils.Log;
Index: CSipSimple/src/com/csipsimple/wizards/impl/SipMe.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/SipMe.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/SipMe.java	(working copy)
@@ -24,7 +24,7 @@
 import android.text.InputType;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class SipMe extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/Sonetel.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Sonetel.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Sonetel.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Spirit.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Spirit.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Spirit.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/SuperCel.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/SuperCel.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/SuperCel.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.preference.ListPreference;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 import java.util.SortedMap;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Tanstagi.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Tanstagi.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Tanstagi.java	(working copy)
@@ -25,7 +25,7 @@
 import android.view.View;
 import android.view.ViewGroup;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/TelekomSrbija.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/TelekomSrbija.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/TelekomSrbija.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/Telemega.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Telemega.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Telemega.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/TeleNative.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/TeleNative.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/TeleNative.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class TeleNative extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/TravelTele.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/TravelTele.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/TravelTele.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class TravelTele extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/UkrTelecom.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/UkrTelecom.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/UkrTelecom.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class UkrTelecom extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/Vitelity.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Vitelity.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Vitelity.java	(working copy)
@@ -29,7 +29,7 @@
 
 import android.preference.ListPreference;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.models.Filter;
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/VoipMS.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/VoipMS.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/VoipMS.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.preference.ListPreference;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 import java.util.SortedMap;
Index: CSipSimple/src/com/csipsimple/wizards/impl/VoipTel.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/VoipTel.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/VoipTel.java	(working copy)
@@ -25,7 +25,7 @@
 import android.view.View;
 import android.view.ViewGroup;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/impl/XNet.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/XNet.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/XNet.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 
Index: CSipSimple/src/com/csipsimple/wizards/impl/YouMagic.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/YouMagic.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/YouMagic.java	(working copy)
@@ -23,7 +23,7 @@
 
 import android.text.InputType;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 
 public class YouMagic extends SimpleImplementation {
Index: CSipSimple/src/com/csipsimple/wizards/impl/Zadarma.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/Zadarma.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/Zadarma.java	(working copy)
@@ -27,7 +27,7 @@
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.Log;
 import com.csipsimple.utils.MD5;
Index: CSipSimple/src/com/csipsimple/wizards/impl/ZonPt.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/impl/ZonPt.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/impl/ZonPt.java	(working copy)
@@ -24,7 +24,7 @@
 import android.text.InputType;
 import android.text.TextUtils;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipConfigManager;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.PreferencesWrapper;
Index: CSipSimple/src/com/csipsimple/wizards/utils/AccountCreationFirstView.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/utils/AccountCreationFirstView.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/utils/AccountCreationFirstView.java	(working copy)
@@ -28,7 +28,7 @@
 import android.view.View.OnClickListener;
 import android.widget.RelativeLayout;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 
 public class AccountCreationFirstView extends RelativeLayout implements OnClickListener {
 
Index: CSipSimple/src/com/csipsimple/wizards/utils/AccountCreationWebview.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/utils/AccountCreationWebview.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/utils/AccountCreationWebview.java	(working copy)
@@ -29,7 +29,7 @@
 import android.webkit.WebView;
 import android.widget.ProgressBar;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.wizards.BasePrefsWizard;
 
 public class AccountCreationWebview {
Index: CSipSimple/src/com/csipsimple/wizards/WizardChooser.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/WizardChooser.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/WizardChooser.java	(working copy)
@@ -33,7 +33,7 @@
 import android.widget.TextView;
 
 import com.actionbarsherlock.app.SherlockExpandableListActivity;
-import com.csipsimple.R;
+import ro.callromania.R;
 
 import java.util.ArrayList;
 import java.util.List;
Index: CSipSimple/src/com/csipsimple/wizards/WizardUtils.java
===================================================================
--- CSipSimple/src/com/csipsimple/wizards/WizardUtils.java	(revision 2470)
+++ CSipSimple/src/com/csipsimple/wizards/WizardUtils.java	(working copy)
@@ -27,7 +27,7 @@
 import android.graphics.drawable.BitmapDrawable;
 import android.util.Log;
 
-import com.csipsimple.R;
+import ro.callromania.R;
 import com.csipsimple.api.SipProfile;
 import com.csipsimple.utils.CustomDistribution;
 import com.csipsimple.wizards.impl.*;
@@ -860,9 +860,9 @@
                     R.drawable.ic_wizard_ajtel, 19, 
                     new Locale[]{ new Locale("es") }, false, false, 
                     Ajtel.class));
-            WIZARDS_DICT.put("CALLROMANIA", new WizardInfo("CALLROMANIA", "CallRomania", 
+            WIZARDS_DICT.put("CALLROMANIA", new WizardInfo("CALLROMANIA", "callRomania", 
                     R.drawable.ic_wizard_callromania, 12, 
-                    new Locale[]{ locale("ro_RO"), new Locale("es_ES"), Locale.ITALY, Locale.GERMANY, Locale.FRANCE, Locale.UK, Locale.US  }, false, false, 
+                    new Locale[]{ new Locale("ro_RO"), new Locale("RO", "ro") }, false, false, 
                     CallRomania.class));
             WIZARDS_DICT.put("ANV", new WizardInfo("ANV", "ANV", 
                     R.drawable.ic_wizard_anv, 5, 
Index: CSipSimple/src/org/pjsip/pjsua/Callback.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/Callback.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/Callback.java	(working copy)
@@ -0,0 +1,175 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class Callback {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected Callback(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(Callback obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_Callback(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  protected void swigDirectorDisconnect() {
+    swigCMemOwn = false;
+    delete();
+  }
+
+  public void swigReleaseOwnership() {
+    swigCMemOwn = false;
+    pjsuaJNI.Callback_change_ownership(this, swigCPtr, false);
+  }
+
+  public void swigTakeOwnership() {
+    swigCMemOwn = true;
+    pjsuaJNI.Callback_change_ownership(this, swigCPtr, true);
+  }
+
+  public void on_call_state(int call_id, pjsip_event e) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_state(swigCPtr, this, call_id, pjsip_event.getCPtr(e), e); else pjsuaJNI.Callback_on_call_stateSwigExplicitCallback(swigCPtr, this, call_id, pjsip_event.getCPtr(e), e);
+  }
+
+  public void on_incoming_call(int acc_id, int call_id, SWIGTYPE_p_pjsip_rx_data rdata) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_incoming_call(swigCPtr, this, acc_id, call_id, SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata)); else pjsuaJNI.Callback_on_incoming_callSwigExplicitCallback(swigCPtr, this, acc_id, call_id, SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata));
+  }
+
+  public void on_call_tsx_state(int call_id, SWIGTYPE_p_pjsip_transaction tsx, pjsip_event e) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_tsx_state(swigCPtr, this, call_id, SWIGTYPE_p_pjsip_transaction.getCPtr(tsx), pjsip_event.getCPtr(e), e); else pjsuaJNI.Callback_on_call_tsx_stateSwigExplicitCallback(swigCPtr, this, call_id, SWIGTYPE_p_pjsip_transaction.getCPtr(tsx), pjsip_event.getCPtr(e), e);
+  }
+
+  public void on_call_media_state(int call_id) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_media_state(swigCPtr, this, call_id); else pjsuaJNI.Callback_on_call_media_stateSwigExplicitCallback(swigCPtr, this, call_id);
+  }
+
+  public void on_call_sdp_created(int call_id, SWIGTYPE_p_pjmedia_sdp_session sdp, pj_pool_t pool, SWIGTYPE_p_pjmedia_sdp_session rem_sdp) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_sdp_created(swigCPtr, this, call_id, SWIGTYPE_p_pjmedia_sdp_session.getCPtr(sdp), pj_pool_t.getCPtr(pool), pool, SWIGTYPE_p_pjmedia_sdp_session.getCPtr(rem_sdp)); else pjsuaJNI.Callback_on_call_sdp_createdSwigExplicitCallback(swigCPtr, this, call_id, SWIGTYPE_p_pjmedia_sdp_session.getCPtr(sdp), pj_pool_t.getCPtr(pool), pool, SWIGTYPE_p_pjmedia_sdp_session.getCPtr(rem_sdp));
+  }
+
+  public void on_stream_created(int call_id, SWIGTYPE_p_pjmedia_stream strm, long stream_idx, SWIGTYPE_p_p_pjmedia_port p_port) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_stream_created(swigCPtr, this, call_id, SWIGTYPE_p_pjmedia_stream.getCPtr(strm), stream_idx, SWIGTYPE_p_p_pjmedia_port.getCPtr(p_port)); else pjsuaJNI.Callback_on_stream_createdSwigExplicitCallback(swigCPtr, this, call_id, SWIGTYPE_p_pjmedia_stream.getCPtr(strm), stream_idx, SWIGTYPE_p_p_pjmedia_port.getCPtr(p_port));
+  }
+
+  public void on_stream_destroyed(int call_id, SWIGTYPE_p_pjmedia_stream strm, long stream_idx) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_stream_destroyed(swigCPtr, this, call_id, SWIGTYPE_p_pjmedia_stream.getCPtr(strm), stream_idx); else pjsuaJNI.Callback_on_stream_destroyedSwigExplicitCallback(swigCPtr, this, call_id, SWIGTYPE_p_pjmedia_stream.getCPtr(strm), stream_idx);
+  }
+
+  public void on_dtmf_digit(int call_id, int digit) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_dtmf_digit(swigCPtr, this, call_id, digit); else pjsuaJNI.Callback_on_dtmf_digitSwigExplicitCallback(swigCPtr, this, call_id, digit);
+  }
+
+  public void on_call_transfer_request(int call_id, pj_str_t dst, SWIGTYPE_p_pjsip_status_code code) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_transfer_request(swigCPtr, this, call_id, pj_str_t.getCPtr(dst), dst, SWIGTYPE_p_pjsip_status_code.getCPtr(code)); else pjsuaJNI.Callback_on_call_transfer_requestSwigExplicitCallback(swigCPtr, this, call_id, pj_str_t.getCPtr(dst), dst, SWIGTYPE_p_pjsip_status_code.getCPtr(code));
+  }
+
+  public void on_call_transfer_status(int call_id, int st_code, pj_str_t st_text, int final_, SWIGTYPE_p_int p_cont) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_transfer_status(swigCPtr, this, call_id, st_code, pj_str_t.getCPtr(st_text), st_text, final_, SWIGTYPE_p_int.getCPtr(p_cont)); else pjsuaJNI.Callback_on_call_transfer_statusSwigExplicitCallback(swigCPtr, this, call_id, st_code, pj_str_t.getCPtr(st_text), st_text, final_, SWIGTYPE_p_int.getCPtr(p_cont));
+  }
+
+  public void on_call_replace_request(int call_id, SWIGTYPE_p_pjsip_rx_data rdata, SWIGTYPE_p_int st_code, pj_str_t st_text) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_replace_request(swigCPtr, this, call_id, SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata), SWIGTYPE_p_int.getCPtr(st_code), pj_str_t.getCPtr(st_text), st_text); else pjsuaJNI.Callback_on_call_replace_requestSwigExplicitCallback(swigCPtr, this, call_id, SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata), SWIGTYPE_p_int.getCPtr(st_code), pj_str_t.getCPtr(st_text), st_text);
+  }
+
+  public void on_call_replaced(int old_call_id, int new_call_id) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_replaced(swigCPtr, this, old_call_id, new_call_id); else pjsuaJNI.Callback_on_call_replacedSwigExplicitCallback(swigCPtr, this, old_call_id, new_call_id);
+  }
+
+  public void on_reg_state(int acc_id) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_reg_state(swigCPtr, this, acc_id); else pjsuaJNI.Callback_on_reg_stateSwigExplicitCallback(swigCPtr, this, acc_id);
+  }
+
+  public void on_buddy_state(int buddy_id) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_buddy_state(swigCPtr, this, buddy_id); else pjsuaJNI.Callback_on_buddy_stateSwigExplicitCallback(swigCPtr, this, buddy_id);
+  }
+
+  public void on_pager(int call_id, pj_str_t from, pj_str_t to, pj_str_t contact, pj_str_t mime_type, pj_str_t body) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_pager(swigCPtr, this, call_id, pj_str_t.getCPtr(from), from, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(contact), contact, pj_str_t.getCPtr(mime_type), mime_type, pj_str_t.getCPtr(body), body); else pjsuaJNI.Callback_on_pagerSwigExplicitCallback(swigCPtr, this, call_id, pj_str_t.getCPtr(from), from, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(contact), contact, pj_str_t.getCPtr(mime_type), mime_type, pj_str_t.getCPtr(body), body);
+  }
+
+  public void on_pager2(int call_id, pj_str_t from, pj_str_t to, pj_str_t contact, pj_str_t mime_type, pj_str_t body, SWIGTYPE_p_pjsip_rx_data rdata) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_pager2(swigCPtr, this, call_id, pj_str_t.getCPtr(from), from, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(contact), contact, pj_str_t.getCPtr(mime_type), mime_type, pj_str_t.getCPtr(body), body, SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata)); else pjsuaJNI.Callback_on_pager2SwigExplicitCallback(swigCPtr, this, call_id, pj_str_t.getCPtr(from), from, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(contact), contact, pj_str_t.getCPtr(mime_type), mime_type, pj_str_t.getCPtr(body), body, SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata));
+  }
+
+  public void on_pager_status(int call_id, pj_str_t to, pj_str_t body, pjsip_status_code status, pj_str_t reason) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_pager_status(swigCPtr, this, call_id, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(body), body, status.swigValue(), pj_str_t.getCPtr(reason), reason); else pjsuaJNI.Callback_on_pager_statusSwigExplicitCallback(swigCPtr, this, call_id, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(body), body, status.swigValue(), pj_str_t.getCPtr(reason), reason);
+  }
+
+  public void on_pager_status2(int call_id, pj_str_t to, pj_str_t body, pjsip_status_code status, pj_str_t reason, SWIGTYPE_p_pjsip_tx_data tdata, SWIGTYPE_p_pjsip_rx_data rdata) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_pager_status2(swigCPtr, this, call_id, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(body), body, status.swigValue(), pj_str_t.getCPtr(reason), reason, SWIGTYPE_p_pjsip_tx_data.getCPtr(tdata), SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata)); else pjsuaJNI.Callback_on_pager_status2SwigExplicitCallback(swigCPtr, this, call_id, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(body), body, status.swigValue(), pj_str_t.getCPtr(reason), reason, SWIGTYPE_p_pjsip_tx_data.getCPtr(tdata), SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata));
+  }
+
+  public void on_typing(int call_id, pj_str_t from, pj_str_t to, pj_str_t contact, int is_typing) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_typing(swigCPtr, this, call_id, pj_str_t.getCPtr(from), from, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(contact), contact, is_typing); else pjsuaJNI.Callback_on_typingSwigExplicitCallback(swigCPtr, this, call_id, pj_str_t.getCPtr(from), from, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(contact), contact, is_typing);
+  }
+
+  public void on_nat_detect(pj_stun_nat_detect_result res) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_nat_detect(swigCPtr, this, pj_stun_nat_detect_result.getCPtr(res), res); else pjsuaJNI.Callback_on_nat_detectSwigExplicitCallback(swigCPtr, this, pj_stun_nat_detect_result.getCPtr(res), res);
+  }
+
+  public pjsip_redirect_op on_call_redirected(int call_id, pj_str_t target) {
+    return pjsip_redirect_op.swigToEnum((getClass() == Callback.class) ? pjsuaJNI.Callback_on_call_redirected(swigCPtr, this, call_id, pj_str_t.getCPtr(target), target) : pjsuaJNI.Callback_on_call_redirectedSwigExplicitCallback(swigCPtr, this, call_id, pj_str_t.getCPtr(target), target));
+  }
+
+  public void on_mwi_info(int acc_id, pj_str_t mime_type, pj_str_t body) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_mwi_info(swigCPtr, this, acc_id, pj_str_t.getCPtr(mime_type), mime_type, pj_str_t.getCPtr(body), body); else pjsuaJNI.Callback_on_mwi_infoSwigExplicitCallback(swigCPtr, this, acc_id, pj_str_t.getCPtr(mime_type), mime_type, pj_str_t.getCPtr(body), body);
+  }
+
+  public void on_call_media_transport_state(int call_id, pjsua_med_tp_state_info info) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_media_transport_state(swigCPtr, this, call_id, pjsua_med_tp_state_info.getCPtr(info), info); else pjsuaJNI.Callback_on_call_media_transport_stateSwigExplicitCallback(swigCPtr, this, call_id, pjsua_med_tp_state_info.getCPtr(info), info);
+  }
+
+  public int on_validate_audio_clock_rate(int clock_rate) {
+    return (getClass() == Callback.class) ? pjsuaJNI.Callback_on_validate_audio_clock_rate(swigCPtr, this, clock_rate) : pjsuaJNI.Callback_on_validate_audio_clock_rateSwigExplicitCallback(swigCPtr, this, clock_rate);
+  }
+
+  public void on_setup_audio(int before_init) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_setup_audio(swigCPtr, this, before_init); else pjsuaJNI.Callback_on_setup_audioSwigExplicitCallback(swigCPtr, this, before_init);
+  }
+
+  public void on_teardown_audio() {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_teardown_audio(swigCPtr, this); else pjsuaJNI.Callback_on_teardown_audioSwigExplicitCallback(swigCPtr, this);
+  }
+
+  public int on_set_micro_source() {
+    return (getClass() == Callback.class) ? pjsuaJNI.Callback_on_set_micro_source(swigCPtr, this) : pjsuaJNI.Callback_on_set_micro_sourceSwigExplicitCallback(swigCPtr, this);
+  }
+
+  public int timer_schedule(int entry, int entryId, int time) {
+    return (getClass() == Callback.class) ? pjsuaJNI.Callback_timer_schedule(swigCPtr, this, entry, entryId, time) : pjsuaJNI.Callback_timer_scheduleSwigExplicitCallback(swigCPtr, this, entry, entryId, time);
+  }
+
+  public int timer_cancel(int entry, int entryId) {
+    return (getClass() == Callback.class) ? pjsuaJNI.Callback_timer_cancel(swigCPtr, this, entry, entryId) : pjsuaJNI.Callback_timer_cancelSwigExplicitCallback(swigCPtr, this, entry, entryId);
+  }
+
+  public Callback() {
+    this(pjsuaJNI.new_Callback(), true);
+    pjsuaJNI.Callback_director_connect(this, swigCPtr, swigCMemOwn, false);
+  }
+
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/EarlyLockCallback.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/EarlyLockCallback.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/EarlyLockCallback.java	(working copy)
@@ -0,0 +1,63 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class EarlyLockCallback {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected EarlyLockCallback(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(EarlyLockCallback obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_EarlyLockCallback(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  protected void swigDirectorDisconnect() {
+    swigCMemOwn = false;
+    delete();
+  }
+
+  public void swigReleaseOwnership() {
+    swigCMemOwn = false;
+    pjsuaJNI.EarlyLockCallback_change_ownership(this, swigCPtr, false);
+  }
+
+  public void swigTakeOwnership() {
+    swigCMemOwn = true;
+    pjsuaJNI.EarlyLockCallback_change_ownership(this, swigCPtr, true);
+  }
+
+  public void on_create_early_lock() {
+    if (getClass() == EarlyLockCallback.class) pjsuaJNI.EarlyLockCallback_on_create_early_lock(swigCPtr, this); else pjsuaJNI.EarlyLockCallback_on_create_early_lockSwigExplicitEarlyLockCallback(swigCPtr, this);
+  }
+
+  public EarlyLockCallback() {
+    this(pjsuaJNI.new_EarlyLockCallback(), true);
+    pjsuaJNI.EarlyLockCallback_director_connect(this, swigCPtr, swigCMemOwn, false);
+  }
+
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/MobileRegHandlerCallback.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/MobileRegHandlerCallback.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/MobileRegHandlerCallback.java	(working copy)
@@ -0,0 +1,67 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class MobileRegHandlerCallback {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected MobileRegHandlerCallback(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(MobileRegHandlerCallback obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_MobileRegHandlerCallback(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  protected void swigDirectorDisconnect() {
+    swigCMemOwn = false;
+    delete();
+  }
+
+  public void swigReleaseOwnership() {
+    swigCMemOwn = false;
+    pjsuaJNI.MobileRegHandlerCallback_change_ownership(this, swigCPtr, false);
+  }
+
+  public void swigTakeOwnership() {
+    swigCMemOwn = true;
+    pjsuaJNI.MobileRegHandlerCallback_change_ownership(this, swigCPtr, true);
+  }
+
+  public void on_save_contact(int acc_id, pj_str_t contact, int expires) {
+    if (getClass() == MobileRegHandlerCallback.class) pjsuaJNI.MobileRegHandlerCallback_on_save_contact(swigCPtr, this, acc_id, pj_str_t.getCPtr(contact), contact, expires); else pjsuaJNI.MobileRegHandlerCallback_on_save_contactSwigExplicitMobileRegHandlerCallback(swigCPtr, this, acc_id, pj_str_t.getCPtr(contact), contact, expires);
+  }
+
+  public pj_str_t on_restore_contact(int acc_id) {
+    return new pj_str_t((getClass() == MobileRegHandlerCallback.class) ? pjsuaJNI.MobileRegHandlerCallback_on_restore_contact(swigCPtr, this, acc_id) : pjsuaJNI.MobileRegHandlerCallback_on_restore_contactSwigExplicitMobileRegHandlerCallback(swigCPtr, this, acc_id), true);
+  }
+
+  public MobileRegHandlerCallback() {
+    this(pjsuaJNI.new_MobileRegHandlerCallback(), true);
+    pjsuaJNI.MobileRegHandlerCallback_director_connect(this, swigCPtr, swigCMemOwn, false);
+  }
+
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int__int.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int__int.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int__int.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int__int {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int__int(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int__int() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int__int obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_event__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_event__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_event__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsip_event__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsip_event__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsip_event__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsip_event__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_evsub__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_evsub__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_evsub__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsip_evsub__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsip_evsub__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsip_evsub__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsip_evsub__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_mwi_info__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_mwi_info__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_mwi_info__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsua_mwi_info__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsua_mwi_info__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsua_mwi_info__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsua_mwi_info__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_reg_info__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_reg_info__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_reg_info__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsua_reg_info__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsua_reg_info__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsua_reg_info__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsua_reg_info__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__char_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__char_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__char_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__char_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__char_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__char_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__char_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port__int.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port__int.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port__int.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_p_pjmedia_port__int {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_p_pjmedia_port__int(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_p_pjmedia_port__int() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_p_pjmedia_port__int obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_void__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_void__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_void__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_p_void__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_p_void__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_p_void__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_p_void__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_int.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_int.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_int.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_int {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_int(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_int() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_int obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_p_pjmedia_port.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_p_pjmedia_port.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_p_pjmedia_port.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_p_pjmedia_port {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_p_pjmedia_port(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_p_pjmedia_port() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_p_pjmedia_port obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_p_pjsip_tx_data.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_p_pjsip_tx_data.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_p_pjsip_tx_data.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_p_pjsip_tx_data {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_p_pjsip_tx_data(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_p_pjsip_tx_data() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_p_pjsip_tx_data obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_block.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_block.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_block.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_pool_block {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_pool_block(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_pool_block() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_pool_block obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_callback.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_callback.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_callback.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_pool_callback {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_pool_callback(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_pool_callback() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_pool_callback obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_factory.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_factory.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_factory.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_pool_factory {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_pool_factory(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_pool_factory() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_pool_factory obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_qos_wmm_prio.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_qos_wmm_prio.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_qos_wmm_prio.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_qos_wmm_prio {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_qos_wmm_prio(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_qos_wmm_prio() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_qos_wmm_prio obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_sockaddr.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_sockaddr.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_sockaddr.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_sockaddr {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_sockaddr(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_sockaddr() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_sockaddr obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_sockopt_params.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_sockopt_params.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_sockopt_params.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_sockopt_params {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_sockopt_params(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_sockopt_params() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_sockopt_params obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_ssl_cipher.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_ssl_cipher.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_ssl_cipher.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_ssl_cipher {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_ssl_cipher(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_ssl_cipher() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_ssl_cipher obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_stun_auth_cred.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_stun_auth_cred.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_stun_auth_cred.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_stun_auth_cred {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_stun_auth_cred(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_stun_auth_cred() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_stun_auth_cred obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_timer_entry.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_timer_entry.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_timer_entry.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_timer_entry {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_timer_entry(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_timer_entry() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_timer_entry obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_aud_dev_cap.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_aud_dev_cap.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_aud_dev_cap.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_aud_dev_cap {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_aud_dev_cap(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_aud_dev_cap() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_aud_dev_cap obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_aud_dev_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_aud_dev_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_aud_dev_info.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_aud_dev_info {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_aud_dev_info(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_aud_dev_info() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_aud_dev_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_codec_param.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_codec_param.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_codec_param.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_codec_param {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_codec_param(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_codec_param() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_codec_param obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_coord.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_coord.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_coord.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_coord {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_coord(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_coord() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_coord obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_endpt.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_endpt.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_endpt.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_endpt {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_endpt(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_endpt() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_endpt obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_format.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_format.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_format.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_format {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_format(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_format() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_format obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_jb_state.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_jb_state.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_jb_state.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_jb_state {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_jb_state(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_jb_state() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_jb_state obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_rect_size.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_rect_size.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_rect_size.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_rect_size {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_rect_size(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_rect_size() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_rect_size obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_rtcp_stat.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_rtcp_stat.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_rtcp_stat.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_rtcp_stat {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_rtcp_stat(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_rtcp_stat() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_rtcp_stat obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_sdp_session.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_sdp_session.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_sdp_session.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_sdp_session {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_sdp_session(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_sdp_session() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_sdp_session obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_sock_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_sock_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_sock_info.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_sock_info {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_sock_info(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_sock_info() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_sock_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_stream.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_stream.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_stream.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_stream {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_stream(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_stream() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_stream obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_transport.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_transport.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_transport.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_transport {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_transport(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_transport() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_transport obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_transport_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_transport_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_transport_info.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_transport_info {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_transport_info(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_transport_info() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_transport_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_type.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_type.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_type.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_type {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_type(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_type() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_type obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_codec_param.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_codec_param.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_codec_param.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_vid_codec_param {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_vid_codec_param(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_vid_codec_param() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_vid_codec_param obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_hwnd.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_hwnd.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_hwnd.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_vid_dev_hwnd {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_vid_dev_hwnd(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_vid_dev_hwnd() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_vid_dev_hwnd obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_index.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_index.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_index.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_vid_dev_index {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_vid_dev_index(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_vid_dev_index() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_vid_dev_index obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_info.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_vid_dev_info {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_vid_dev_info(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_vid_dev_info() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_vid_dev_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_stream_rc_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_stream_rc_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_stream_rc_config.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_vid_stream_rc_config {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_vid_stream_rc_config(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_vid_stream_rc_config() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_vid_stream_rc_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_wav_player_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_wav_player_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_wav_player_info.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_wav_player_info {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_wav_player_info(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_wav_player_info() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_wav_player_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjrpid_element_type.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjrpid_element_type.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjrpid_element_type.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjrpid_element_type {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjrpid_element_type(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjrpid_element_type() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjrpid_element_type obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_dialog_cap_status.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_dialog_cap_status.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_dialog_cap_status.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_dialog_cap_status {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_dialog_cap_status(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_dialog_cap_status() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_dialog_cap_status obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_endpoint.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_endpoint.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_endpoint.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_endpoint {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_endpoint(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_endpoint() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_endpoint obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_evsub.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_evsub.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_evsub.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_evsub {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_evsub(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_evsub() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_evsub obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_evsub_state.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_evsub_state.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_evsub_state.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_evsub_state {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_evsub_state(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_evsub_state() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_evsub_state obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_hdr.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_hdr.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_hdr.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_hdr {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_hdr(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_hdr() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_hdr obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_host_port.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_host_port.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_host_port.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_host_port {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_host_port(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_host_port() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_host_port obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_media_type.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_media_type.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_media_type.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_media_type {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_media_type(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_media_type() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_media_type obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_method.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_method.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_method.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_method {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_method(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_method() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_method obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_multipart_part.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_multipart_part.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_multipart_part.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_multipart_part {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_multipart_part(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_multipart_part() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_multipart_part obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_pres_status.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_pres_status.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_pres_status.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_pres_status {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_pres_status(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_pres_status() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_pres_status obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_publishc_opt.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_publishc_opt.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_publishc_opt.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_publishc_opt {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_publishc_opt(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_publishc_opt() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_publishc_opt obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_regc_cbparam.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_regc_cbparam.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_regc_cbparam.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_regc_cbparam {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_regc_cbparam(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_regc_cbparam() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_regc_cbparam obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_role_e.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_role_e.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_role_e.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_role_e {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_role_e(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_role_e() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_role_e obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_rx_data.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_rx_data.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_rx_data.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_rx_data {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_rx_data(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_rx_data() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_rx_data obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_status_code.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_status_code.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_status_code.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_status_code {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_status_code(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_status_code() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_status_code obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_tp_state_callback.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_tp_state_callback.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_tp_state_callback.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_tp_state_callback {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_tp_state_callback(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_tp_state_callback() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_tp_state_callback obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_transaction.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_transaction.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_transaction.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_transaction {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_transaction(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_transaction() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_transaction obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_transport.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_transport.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_transport.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_transport {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_transport(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_transport() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_transport obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_tx_data.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_tx_data.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_tx_data.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_tx_data {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_tx_data(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_tx_data() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_tx_data obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsua_srv_pres.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsua_srv_pres.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsua_srv_pres.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsua_srv_pres {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsua_srv_pres(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsua_srv_pres() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsua_srv_pres obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_unsigned_int.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_unsigned_int.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_unsigned_int.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_unsigned_int {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_unsigned_int(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_unsigned_int() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_unsigned_int obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/ZrtpCallback.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/ZrtpCallback.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/ZrtpCallback.java	(working copy)
@@ -0,0 +1,67 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class ZrtpCallback {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected ZrtpCallback(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(ZrtpCallback obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_ZrtpCallback(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  protected void swigDirectorDisconnect() {
+    swigCMemOwn = false;
+    delete();
+  }
+
+  public void swigReleaseOwnership() {
+    swigCMemOwn = false;
+    pjsuaJNI.ZrtpCallback_change_ownership(this, swigCPtr, false);
+  }
+
+  public void swigTakeOwnership() {
+    swigCMemOwn = true;
+    pjsuaJNI.ZrtpCallback_change_ownership(this, swigCPtr, true);
+  }
+
+  public void on_zrtp_show_sas(int call_id, pj_str_t sas, int verified) {
+    if (getClass() == ZrtpCallback.class) pjsuaJNI.ZrtpCallback_on_zrtp_show_sas(swigCPtr, this, call_id, pj_str_t.getCPtr(sas), sas, verified); else pjsuaJNI.ZrtpCallback_on_zrtp_show_sasSwigExplicitZrtpCallback(swigCPtr, this, call_id, pj_str_t.getCPtr(sas), sas, verified);
+  }
+
+  public void on_zrtp_update_transport(int call_id) {
+    if (getClass() == ZrtpCallback.class) pjsuaJNI.ZrtpCallback_on_zrtp_update_transport(swigCPtr, this, call_id); else pjsuaJNI.ZrtpCallback_on_zrtp_update_transportSwigExplicitZrtpCallback(swigCPtr, this, call_id);
+  }
+
+  public ZrtpCallback() {
+    this(pjsuaJNI.new_ZrtpCallback(), true);
+    pjsuaJNI.ZrtpCallback_director_connect(this, swigCPtr, swigCMemOwn, false);
+  }
+
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/csipsimple_acc_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/csipsimple_acc_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/csipsimple_acc_config.java	(working copy)
@@ -0,0 +1,59 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class csipsimple_acc_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected csipsimple_acc_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(csipsimple_acc_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_csipsimple_acc_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setUse_zrtp(int value) {
+    pjsuaJNI.csipsimple_acc_config_use_zrtp_set(swigCPtr, this, value);
+  }
+
+  public int getUse_zrtp() {
+    return pjsuaJNI.csipsimple_acc_config_use_zrtp_get(swigCPtr, this);
+  }
+
+  public void setP_preferred_identity(pj_str_t value) {
+    pjsuaJNI.csipsimple_acc_config_p_preferred_identity_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getP_preferred_identity() {
+    long cPtr = pjsuaJNI.csipsimple_acc_config_p_preferred_identity_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public csipsimple_acc_config() {
+    this(pjsuaJNI.new_csipsimple_acc_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/csipsimple_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/csipsimple_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/csipsimple_config.java	(working copy)
@@ -0,0 +1,239 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class csipsimple_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected csipsimple_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(csipsimple_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_csipsimple_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setUse_compact_form_sdp(int value) {
+    pjsuaJNI.csipsimple_config_use_compact_form_sdp_set(swigCPtr, this, value);
+  }
+
+  public int getUse_compact_form_sdp() {
+    return pjsuaJNI.csipsimple_config_use_compact_form_sdp_get(swigCPtr, this);
+  }
+
+  public void setUse_compact_form_headers(int value) {
+    pjsuaJNI.csipsimple_config_use_compact_form_headers_set(swigCPtr, this, value);
+  }
+
+  public int getUse_compact_form_headers() {
+    return pjsuaJNI.csipsimple_config_use_compact_form_headers_get(swigCPtr, this);
+  }
+
+  public void setAdd_bandwidth_tias_in_sdp(int value) {
+    pjsuaJNI.csipsimple_config_add_bandwidth_tias_in_sdp_set(swigCPtr, this, value);
+  }
+
+  public int getAdd_bandwidth_tias_in_sdp() {
+    return pjsuaJNI.csipsimple_config_add_bandwidth_tias_in_sdp_get(swigCPtr, this);
+  }
+
+  public void setUse_no_update(int value) {
+    pjsuaJNI.csipsimple_config_use_no_update_set(swigCPtr, this, value);
+  }
+
+  public int getUse_no_update() {
+    return pjsuaJNI.csipsimple_config_use_no_update_get(swigCPtr, this);
+  }
+
+  public void setUse_zrtp(int value) {
+    pjsuaJNI.csipsimple_config_use_zrtp_set(swigCPtr, this, value);
+  }
+
+  public int getUse_zrtp() {
+    return pjsuaJNI.csipsimple_config_use_zrtp_get(swigCPtr, this);
+  }
+
+  public void setExtra_aud_codecs_cnt(long value) {
+    pjsuaJNI.csipsimple_config_extra_aud_codecs_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getExtra_aud_codecs_cnt() {
+    return pjsuaJNI.csipsimple_config_extra_aud_codecs_cnt_get(swigCPtr, this);
+  }
+
+  public void setExtra_aud_codecs(dynamic_factory[] value) {
+    pjsuaJNI.csipsimple_config_extra_aud_codecs_set(swigCPtr, this, dynamic_factory.cArrayUnwrap(value));
+  }
+
+  public dynamic_factory[] getExtra_aud_codecs() {
+    return dynamic_factory.cArrayWrap(pjsuaJNI.csipsimple_config_extra_aud_codecs_get(swigCPtr, this), false);
+  }
+
+  public void setExtra_vid_codecs_cnt(long value) {
+    pjsuaJNI.csipsimple_config_extra_vid_codecs_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getExtra_vid_codecs_cnt() {
+    return pjsuaJNI.csipsimple_config_extra_vid_codecs_cnt_get(swigCPtr, this);
+  }
+
+  public void setExtra_vid_codecs(dynamic_factory[] value) {
+    pjsuaJNI.csipsimple_config_extra_vid_codecs_set(swigCPtr, this, dynamic_factory.cArrayUnwrap(value));
+  }
+
+  public dynamic_factory[] getExtra_vid_codecs() {
+    return dynamic_factory.cArrayWrap(pjsuaJNI.csipsimple_config_extra_vid_codecs_get(swigCPtr, this), false);
+  }
+
+  public void setExtra_vid_codecs_destroy(dynamic_factory[] value) {
+    pjsuaJNI.csipsimple_config_extra_vid_codecs_destroy_set(swigCPtr, this, dynamic_factory.cArrayUnwrap(value));
+  }
+
+  public dynamic_factory[] getExtra_vid_codecs_destroy() {
+    return dynamic_factory.cArrayWrap(pjsuaJNI.csipsimple_config_extra_vid_codecs_destroy_get(swigCPtr, this), false);
+  }
+
+  public void setVid_converter(dynamic_factory value) {
+    pjsuaJNI.csipsimple_config_vid_converter_set(swigCPtr, this, dynamic_factory.getCPtr(value), value);
+  }
+
+  public dynamic_factory getVid_converter() {
+    long cPtr = pjsuaJNI.csipsimple_config_vid_converter_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new dynamic_factory(cPtr, false);
+  }
+
+  public void setStorage_folder(pj_str_t value) {
+    pjsuaJNI.csipsimple_config_storage_folder_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getStorage_folder() {
+    long cPtr = pjsuaJNI.csipsimple_config_storage_folder_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setAudio_implementation(dynamic_factory value) {
+    pjsuaJNI.csipsimple_config_audio_implementation_set(swigCPtr, this, dynamic_factory.getCPtr(value), value);
+  }
+
+  public dynamic_factory getAudio_implementation() {
+    long cPtr = pjsuaJNI.csipsimple_config_audio_implementation_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new dynamic_factory(cPtr, false);
+  }
+
+  public void setVideo_render_implementation(dynamic_factory value) {
+    pjsuaJNI.csipsimple_config_video_render_implementation_set(swigCPtr, this, dynamic_factory.getCPtr(value), value);
+  }
+
+  public dynamic_factory getVideo_render_implementation() {
+    long cPtr = pjsuaJNI.csipsimple_config_video_render_implementation_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new dynamic_factory(cPtr, false);
+  }
+
+  public void setVideo_capture_implementation(dynamic_factory value) {
+    pjsuaJNI.csipsimple_config_video_capture_implementation_set(swigCPtr, this, dynamic_factory.getCPtr(value), value);
+  }
+
+  public dynamic_factory getVideo_capture_implementation() {
+    long cPtr = pjsuaJNI.csipsimple_config_video_capture_implementation_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new dynamic_factory(cPtr, false);
+  }
+
+  public void setTcp_keep_alive_interval(int value) {
+    pjsuaJNI.csipsimple_config_tcp_keep_alive_interval_set(swigCPtr, this, value);
+  }
+
+  public int getTcp_keep_alive_interval() {
+    return pjsuaJNI.csipsimple_config_tcp_keep_alive_interval_get(swigCPtr, this);
+  }
+
+  public void setTls_keep_alive_interval(int value) {
+    pjsuaJNI.csipsimple_config_tls_keep_alive_interval_set(swigCPtr, this, value);
+  }
+
+  public int getTls_keep_alive_interval() {
+    return pjsuaJNI.csipsimple_config_tls_keep_alive_interval_get(swigCPtr, this);
+  }
+
+  public void setTsx_t1_timeout(int value) {
+    pjsuaJNI.csipsimple_config_tsx_t1_timeout_set(swigCPtr, this, value);
+  }
+
+  public int getTsx_t1_timeout() {
+    return pjsuaJNI.csipsimple_config_tsx_t1_timeout_get(swigCPtr, this);
+  }
+
+  public void setTsx_t2_timeout(int value) {
+    pjsuaJNI.csipsimple_config_tsx_t2_timeout_set(swigCPtr, this, value);
+  }
+
+  public int getTsx_t2_timeout() {
+    return pjsuaJNI.csipsimple_config_tsx_t2_timeout_get(swigCPtr, this);
+  }
+
+  public void setTsx_t4_timeout(int value) {
+    pjsuaJNI.csipsimple_config_tsx_t4_timeout_set(swigCPtr, this, value);
+  }
+
+  public int getTsx_t4_timeout() {
+    return pjsuaJNI.csipsimple_config_tsx_t4_timeout_get(swigCPtr, this);
+  }
+
+  public void setTsx_td_timeout(int value) {
+    pjsuaJNI.csipsimple_config_tsx_td_timeout_set(swigCPtr, this, value);
+  }
+
+  public int getTsx_td_timeout() {
+    return pjsuaJNI.csipsimple_config_tsx_td_timeout_get(swigCPtr, this);
+  }
+
+  public void setDisable_tcp_switch(int value) {
+    pjsuaJNI.csipsimple_config_disable_tcp_switch_set(swigCPtr, this, value);
+  }
+
+  public int getDisable_tcp_switch() {
+    return pjsuaJNI.csipsimple_config_disable_tcp_switch_get(swigCPtr, this);
+  }
+
+  public void setDisable_rport(int value) {
+    pjsuaJNI.csipsimple_config_disable_rport_set(swigCPtr, this, value);
+  }
+
+  public int getDisable_rport() {
+    return pjsuaJNI.csipsimple_config_disable_rport_get(swigCPtr, this);
+  }
+
+  public void setUse_noise_suppressor(int value) {
+    pjsuaJNI.csipsimple_config_use_noise_suppressor_set(swigCPtr, this, value);
+  }
+
+  public int getUse_noise_suppressor() {
+    return pjsuaJNI.csipsimple_config_use_noise_suppressor_get(swigCPtr, this);
+  }
+
+  public csipsimple_config() {
+    this(pjsuaJNI.new_csipsimple_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/dynamic_factory.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/dynamic_factory.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/dynamic_factory.java	(working copy)
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class dynamic_factory {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected dynamic_factory(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(dynamic_factory obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_dynamic_factory(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  protected static long[] cArrayUnwrap(dynamic_factory[] arrayWrapper) {
+      long[] cArray = new long[arrayWrapper.length];
+      for (int i=0; i<arrayWrapper.length; i++)
+        cArray[i] = dynamic_factory.getCPtr(arrayWrapper[i]);
+      return cArray;
+  }
+
+  protected static dynamic_factory[] cArrayWrap(long[] cArray, boolean cMemoryOwn) {
+    dynamic_factory[] arrayWrapper = new dynamic_factory[cArray.length];
+    for (int i=0; i<cArray.length; i++)
+      arrayWrapper[i] = new dynamic_factory(cArray[i], cMemoryOwn);
+    return arrayWrapper;
+  }
+
+  public void setShared_lib_path(pj_str_t value) {
+    pjsuaJNI.dynamic_factory_shared_lib_path_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getShared_lib_path() {
+    long cPtr = pjsuaJNI.dynamic_factory_shared_lib_path_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setInit_factory_name(pj_str_t value) {
+    pjsuaJNI.dynamic_factory_init_factory_name_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getInit_factory_name() {
+    long cPtr = pjsuaJNI.dynamic_factory_init_factory_name_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public dynamic_factory() {
+    this(pjsuaJNI.new_dynamic_factory(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pj_ice_sess_options.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_ice_sess_options.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_ice_sess_options.java	(working copy)
@@ -0,0 +1,66 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pj_ice_sess_options {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pj_ice_sess_options(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pj_ice_sess_options obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pj_ice_sess_options(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setAggressive(int value) {
+    pjsuaJNI.pj_ice_sess_options_aggressive_set(swigCPtr, this, value);
+  }
+
+  public int getAggressive() {
+    return pjsuaJNI.pj_ice_sess_options_aggressive_get(swigCPtr, this);
+  }
+
+  public void setNominated_check_delay(long value) {
+    pjsuaJNI.pj_ice_sess_options_nominated_check_delay_set(swigCPtr, this, value);
+  }
+
+  public long getNominated_check_delay() {
+    return pjsuaJNI.pj_ice_sess_options_nominated_check_delay_get(swigCPtr, this);
+  }
+
+  public void setControlled_agent_want_nom_timeout(int value) {
+    pjsuaJNI.pj_ice_sess_options_controlled_agent_want_nom_timeout_set(swigCPtr, this, value);
+  }
+
+  public int getControlled_agent_want_nom_timeout() {
+    return pjsuaJNI.pj_ice_sess_options_controlled_agent_want_nom_timeout_get(swigCPtr, this);
+  }
+
+  public pj_ice_sess_options() {
+    this(pjsuaJNI.new_pj_ice_sess_options(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pj_pool_t.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_pool_t.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_pool_t.java	(working copy)
@@ -0,0 +1,100 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pj_pool_t {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pj_pool_t(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pj_pool_t obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pj_pool_t(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setObj_name(String value) {
+    pjsuaJNI.pj_pool_t_obj_name_set(swigCPtr, this, value);
+  }
+
+  public String getObj_name() {
+    return pjsuaJNI.pj_pool_t_obj_name_get(swigCPtr, this);
+  }
+
+  public void setFactory(SWIGTYPE_p_pj_pool_factory value) {
+    pjsuaJNI.pj_pool_t_factory_set(swigCPtr, this, SWIGTYPE_p_pj_pool_factory.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_pool_factory getFactory() {
+    long cPtr = pjsuaJNI.pj_pool_t_factory_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pj_pool_factory(cPtr, false);
+  }
+
+  public void setFactory_data(byte[] value) {
+    pjsuaJNI.pj_pool_t_factory_data_set(swigCPtr, this, value);
+  }
+
+  public byte[] getFactory_data() {
+	return pjsuaJNI.pj_pool_t_factory_data_get(swigCPtr, this);
+}
+
+  public void setCapacity(long value) {
+    pjsuaJNI.pj_pool_t_capacity_set(swigCPtr, this, value);
+  }
+
+  public long getCapacity() {
+    return pjsuaJNI.pj_pool_t_capacity_get(swigCPtr, this);
+  }
+
+  public void setIncrement_size(long value) {
+    pjsuaJNI.pj_pool_t_increment_size_set(swigCPtr, this, value);
+  }
+
+  public long getIncrement_size() {
+    return pjsuaJNI.pj_pool_t_increment_size_get(swigCPtr, this);
+  }
+
+  public void setBlock_list(SWIGTYPE_p_pj_pool_block value) {
+    pjsuaJNI.pj_pool_t_block_list_set(swigCPtr, this, SWIGTYPE_p_pj_pool_block.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_pool_block getBlock_list() {
+    return new SWIGTYPE_p_pj_pool_block(pjsuaJNI.pj_pool_t_block_list_get(swigCPtr, this), true);
+  }
+
+  public void setCallback(SWIGTYPE_p_pj_pool_callback value) {
+    pjsuaJNI.pj_pool_t_callback_set(swigCPtr, this, SWIGTYPE_p_pj_pool_callback.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_pool_callback getCallback() {
+    long cPtr = pjsuaJNI.pj_pool_t_callback_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pj_pool_callback(cPtr, false);
+  }
+
+  public pj_pool_t() {
+    this(pjsuaJNI.new_pj_pool_t(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pj_qos_params.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_qos_params.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_qos_params.java	(working copy)
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pj_qos_params {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pj_qos_params(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pj_qos_params obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pj_qos_params(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setFlags(short value) {
+    pjsuaJNI.pj_qos_params_flags_set(swigCPtr, this, value);
+  }
+
+  public short getFlags() {
+    return pjsuaJNI.pj_qos_params_flags_get(swigCPtr, this);
+  }
+
+  public void setDscp_val(short value) {
+    pjsuaJNI.pj_qos_params_dscp_val_set(swigCPtr, this, value);
+  }
+
+  public short getDscp_val() {
+    return pjsuaJNI.pj_qos_params_dscp_val_get(swigCPtr, this);
+  }
+
+  public void setSo_prio(short value) {
+    pjsuaJNI.pj_qos_params_so_prio_set(swigCPtr, this, value);
+  }
+
+  public short getSo_prio() {
+    return pjsuaJNI.pj_qos_params_so_prio_get(swigCPtr, this);
+  }
+
+  public void setWmm_prio(SWIGTYPE_p_pj_qos_wmm_prio value) {
+    pjsuaJNI.pj_qos_params_wmm_prio_set(swigCPtr, this, SWIGTYPE_p_pj_qos_wmm_prio.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_qos_wmm_prio getWmm_prio() {
+    return new SWIGTYPE_p_pj_qos_wmm_prio(pjsuaJNI.pj_qos_params_wmm_prio_get(swigCPtr, this), true);
+  }
+
+  public pj_qos_params() {
+    this(pjsuaJNI.new_pj_qos_params(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pj_qos_type.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_qos_type.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_qos_type.java	(working copy)
@@ -0,0 +1,55 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pj_qos_type {
+  PJ_QOS_TYPE_BEST_EFFORT,
+  PJ_QOS_TYPE_BACKGROUND,
+  PJ_QOS_TYPE_VIDEO,
+  PJ_QOS_TYPE_VOICE,
+  PJ_QOS_TYPE_CONTROL;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pj_qos_type swigToEnum(int swigValue) {
+    pj_qos_type[] swigValues = pj_qos_type.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pj_qos_type swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pj_qos_type.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pj_qos_type() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pj_qos_type(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pj_qos_type(pj_qos_type swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pj_str_t.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_str_t.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_str_t.java	(working copy)
@@ -0,0 +1,72 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pj_str_t {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pj_str_t(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pj_str_t obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pj_str_t(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  protected static long[] cArrayUnwrap(pj_str_t[] arrayWrapper) {
+      long[] cArray = new long[arrayWrapper.length];
+      for (int i=0; i<arrayWrapper.length; i++)
+        cArray[i] = pj_str_t.getCPtr(arrayWrapper[i]);
+      return cArray;
+  }
+
+  protected static pj_str_t[] cArrayWrap(long[] cArray, boolean cMemoryOwn) {
+    pj_str_t[] arrayWrapper = new pj_str_t[cArray.length];
+    for (int i=0; i<cArray.length; i++)
+      arrayWrapper[i] = new pj_str_t(cArray[i], cMemoryOwn);
+    return arrayWrapper;
+  }
+
+  public void setPtr(String value) {
+    pjsuaJNI.pj_str_t_ptr_set(swigCPtr, this, value);
+  }
+
+  public String getPtr() {
+    return pjsuaJNI.pj_str_t_ptr_get(swigCPtr, this);
+  }
+
+  public void setSlen(int value) {
+    pjsuaJNI.pj_str_t_slen_set(swigCPtr, this, value);
+  }
+
+  public int getSlen() {
+    return pjsuaJNI.pj_str_t_slen_get(swigCPtr, this);
+  }
+
+  public pj_str_t() {
+    this(pjsuaJNI.new_pj_str_t(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pj_stun_nat_detect_result.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_stun_nat_detect_result.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_stun_nat_detect_result.java	(working copy)
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pj_stun_nat_detect_result {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pj_stun_nat_detect_result(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pj_stun_nat_detect_result obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pj_stun_nat_detect_result(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setStatus(int value) {
+    pjsuaJNI.pj_stun_nat_detect_result_status_set(swigCPtr, this, value);
+  }
+
+  public int getStatus() {
+    return pjsuaJNI.pj_stun_nat_detect_result_status_get(swigCPtr, this);
+  }
+
+  public void setStatus_text(String value) {
+    pjsuaJNI.pj_stun_nat_detect_result_status_text_set(swigCPtr, this, value);
+  }
+
+  public String getStatus_text() {
+    return pjsuaJNI.pj_stun_nat_detect_result_status_text_get(swigCPtr, this);
+  }
+
+  public void setNat_type(pj_stun_nat_type value) {
+    pjsuaJNI.pj_stun_nat_detect_result_nat_type_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pj_stun_nat_type getNat_type() {
+    return pj_stun_nat_type.swigToEnum(pjsuaJNI.pj_stun_nat_detect_result_nat_type_get(swigCPtr, this));
+  }
+
+  public void setNat_type_name(String value) {
+    pjsuaJNI.pj_stun_nat_detect_result_nat_type_name_set(swigCPtr, this, value);
+  }
+
+  public String getNat_type_name() {
+    return pjsuaJNI.pj_stun_nat_detect_result_nat_type_name_get(swigCPtr, this);
+  }
+
+  public pj_stun_nat_detect_result() {
+    this(pjsuaJNI.new_pj_stun_nat_detect_result(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pj_stun_nat_type.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_stun_nat_type.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_stun_nat_type.java	(working copy)
@@ -0,0 +1,59 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pj_stun_nat_type {
+  PJ_STUN_NAT_TYPE_UNKNOWN,
+  PJ_STUN_NAT_TYPE_ERR_UNKNOWN,
+  PJ_STUN_NAT_TYPE_OPEN,
+  PJ_STUN_NAT_TYPE_BLOCKED,
+  PJ_STUN_NAT_TYPE_SYMMETRIC_UDP,
+  PJ_STUN_NAT_TYPE_FULL_CONE,
+  PJ_STUN_NAT_TYPE_SYMMETRIC,
+  PJ_STUN_NAT_TYPE_RESTRICTED,
+  PJ_STUN_NAT_TYPE_PORT_RESTRICTED;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pj_stun_nat_type swigToEnum(int swigValue) {
+    pj_stun_nat_type[] swigValues = pj_stun_nat_type.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pj_stun_nat_type swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pj_stun_nat_type.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pj_stun_nat_type() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pj_stun_nat_type(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pj_stun_nat_type(pj_stun_nat_type swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pj_stun_resolve_result.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_stun_resolve_result.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_stun_resolve_result.java	(working copy)
@@ -0,0 +1,75 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pj_stun_resolve_result {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pj_stun_resolve_result(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pj_stun_resolve_result obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pj_stun_resolve_result(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setToken(byte[] value) {
+    pjsuaJNI.pj_stun_resolve_result_token_set(swigCPtr, this, value);
+  }
+
+  public byte[] getToken() {
+	return pjsuaJNI.pj_stun_resolve_result_token_get(swigCPtr, this);
+}
+
+  public void setStatus(int value) {
+    pjsuaJNI.pj_stun_resolve_result_status_set(swigCPtr, this, value);
+  }
+
+  public int getStatus() {
+    return pjsuaJNI.pj_stun_resolve_result_status_get(swigCPtr, this);
+  }
+
+  public void setName(pj_str_t value) {
+    pjsuaJNI.pj_stun_resolve_result_name_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getName() {
+    long cPtr = pjsuaJNI.pj_stun_resolve_result_name_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setAddr(SWIGTYPE_p_pj_sockaddr value) {
+    pjsuaJNI.pj_stun_resolve_result_addr_set(swigCPtr, this, SWIGTYPE_p_pj_sockaddr.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_sockaddr getAddr() {
+    return new SWIGTYPE_p_pj_sockaddr(pjsuaJNI.pj_stun_resolve_result_addr_get(swigCPtr, this), true);
+  }
+
+  public pj_stun_resolve_result() {
+    this(pjsuaJNI.new_pj_stun_resolve_result(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pj_time_val.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_time_val.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_time_val.java	(working copy)
@@ -0,0 +1,58 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pj_time_val {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pj_time_val(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pj_time_val obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pj_time_val(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setSec(int value) {
+    pjsuaJNI.pj_time_val_sec_set(swigCPtr, this, value);
+  }
+
+  public int getSec() {
+    return pjsuaJNI.pj_time_val_sec_get(swigCPtr, this);
+  }
+
+  public void setMsec(int value) {
+    pjsuaJNI.pj_time_val_msec_set(swigCPtr, this, value);
+  }
+
+  public int getMsec() {
+    return pjsuaJNI.pj_time_val_msec_get(swigCPtr, this);
+  }
+
+  public pj_time_val() {
+    this(pjsuaJNI.new_pj_time_val(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pj_turn_tp_type.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_turn_tp_type.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_turn_tp_type.java	(working copy)
@@ -0,0 +1,53 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pj_turn_tp_type {
+  PJ_TURN_TP_UDP(pjsuaJNI.PJ_TURN_TP_UDP_get()),
+  PJ_TURN_TP_TCP(pjsuaJNI.PJ_TURN_TP_TCP_get()),
+  PJ_TURN_TP_TLS(pjsuaJNI.PJ_TURN_TP_TLS_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pj_turn_tp_type swigToEnum(int swigValue) {
+    pj_turn_tp_type[] swigValues = pj_turn_tp_type.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pj_turn_tp_type swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pj_turn_tp_type.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pj_turn_tp_type() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pj_turn_tp_type(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pj_turn_tp_type(pj_turn_tp_type swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjmedia_dir.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjmedia_dir.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjmedia_dir.java	(working copy)
@@ -0,0 +1,59 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjmedia_dir {
+  PJMEDIA_DIR_NONE(pjsuaJNI.PJMEDIA_DIR_NONE_get()),
+  PJMEDIA_DIR_ENCODING(pjsuaJNI.PJMEDIA_DIR_ENCODING_get()),
+  PJMEDIA_DIR_CAPTURE(pjsuaJNI.PJMEDIA_DIR_CAPTURE_get()),
+  PJMEDIA_DIR_DECODING(pjsuaJNI.PJMEDIA_DIR_DECODING_get()),
+  PJMEDIA_DIR_PLAYBACK(pjsuaJNI.PJMEDIA_DIR_PLAYBACK_get()),
+  PJMEDIA_DIR_RENDER(pjsuaJNI.PJMEDIA_DIR_RENDER_get()),
+  PJMEDIA_DIR_ENCODING_DECODING(pjsuaJNI.PJMEDIA_DIR_ENCODING_DECODING_get()),
+  PJMEDIA_DIR_CAPTURE_PLAYBACK(pjsuaJNI.PJMEDIA_DIR_CAPTURE_PLAYBACK_get()),
+  PJMEDIA_DIR_CAPTURE_RENDER(pjsuaJNI.PJMEDIA_DIR_CAPTURE_RENDER_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjmedia_dir swigToEnum(int swigValue) {
+    pjmedia_dir[] swigValues = pjmedia_dir.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjmedia_dir swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjmedia_dir.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjmedia_dir() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjmedia_dir(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjmedia_dir(pjmedia_dir swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjmedia_port.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjmedia_port.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjmedia_port.java	(working copy)
@@ -0,0 +1,84 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjmedia_port {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjmedia_port(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjmedia_port obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        throw new UnsupportedOperationException("C++ destructor does not have public access");
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  /** This constructor creates the proxy which initially does not create nor own any C memory */
+  public pjmedia_port() {
+    this(0, false);
+  }
+
+  public void setInfo(pjmedia_port_info value) {
+    pjsuaJNI.pjmedia_port_info_set(swigCPtr, this, pjmedia_port_info.getCPtr(value), value);
+  }
+
+  public pjmedia_port_info getInfo() {
+    long cPtr = pjsuaJNI.pjmedia_port_info_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjmedia_port_info(cPtr, false);
+  }
+
+  public void setGet_clock_src(SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src value) {
+    pjsuaJNI.pjmedia_port_get_clock_src_set(swigCPtr, this, SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src getGet_clock_src() {
+    long cPtr = pjsuaJNI.pjmedia_port_get_clock_src_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src(cPtr, false);
+  }
+
+  public void setPut_frame(SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int value) {
+    pjsuaJNI.pjmedia_port_put_frame_set(swigCPtr, this, SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int getPut_frame() {
+    long cPtr = pjsuaJNI.pjmedia_port_put_frame_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int(cPtr, false);
+  }
+
+  public void setGet_frame(SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int value) {
+    pjsuaJNI.pjmedia_port_get_frame_set(swigCPtr, this, SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int getGet_frame() {
+    long cPtr = pjsuaJNI.pjmedia_port_get_frame_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int(cPtr, false);
+  }
+
+  public void setOn_destroy(SWIGTYPE_p_f_p_pjmedia_port__int value) {
+    pjsuaJNI.pjmedia_port_on_destroy_set(swigCPtr, this, SWIGTYPE_p_f_p_pjmedia_port__int.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_p_pjmedia_port__int getOn_destroy() {
+    long cPtr = pjsuaJNI.pjmedia_port_on_destroy_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_p_pjmedia_port__int(cPtr, false);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjmedia_port_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjmedia_port_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjmedia_port_info.java	(working copy)
@@ -0,0 +1,75 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjmedia_port_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjmedia_port_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjmedia_port_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjmedia_port_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setName(pj_str_t value) {
+    pjsuaJNI.pjmedia_port_info_name_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getName() {
+    long cPtr = pjsuaJNI.pjmedia_port_info_name_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setSignature(long value) {
+    pjsuaJNI.pjmedia_port_info_signature_set(swigCPtr, this, value);
+  }
+
+  public long getSignature() {
+    return pjsuaJNI.pjmedia_port_info_signature_get(swigCPtr, this);
+  }
+
+  public void setDir(pjmedia_dir value) {
+    pjsuaJNI.pjmedia_port_info_dir_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjmedia_dir getDir() {
+    return pjmedia_dir.swigToEnum(pjsuaJNI.pjmedia_port_info_dir_get(swigCPtr, this));
+  }
+
+  public void setFmt(SWIGTYPE_p_pjmedia_format value) {
+    pjsuaJNI.pjmedia_port_info_fmt_set(swigCPtr, this, SWIGTYPE_p_pjmedia_format.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_format getFmt() {
+    return new SWIGTYPE_p_pjmedia_format(pjsuaJNI.pjmedia_port_info_fmt_get(swigCPtr, this), true);
+  }
+
+  public pjmedia_port_info() {
+    this(pjsuaJNI.new_pjmedia_port_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjmedia_snd_dev_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjmedia_snd_dev_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjmedia_snd_dev_info.java	(working copy)
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjmedia_snd_dev_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjmedia_snd_dev_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjmedia_snd_dev_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjmedia_snd_dev_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setName(String value) {
+    pjsuaJNI.pjmedia_snd_dev_info_name_set(swigCPtr, this, value);
+  }
+
+  public String getName() {
+    return pjsuaJNI.pjmedia_snd_dev_info_name_get(swigCPtr, this);
+  }
+
+  public void setInput_count(long value) {
+    pjsuaJNI.pjmedia_snd_dev_info_input_count_set(swigCPtr, this, value);
+  }
+
+  public long getInput_count() {
+    return pjsuaJNI.pjmedia_snd_dev_info_input_count_get(swigCPtr, this);
+  }
+
+  public void setOutput_count(long value) {
+    pjsuaJNI.pjmedia_snd_dev_info_output_count_set(swigCPtr, this, value);
+  }
+
+  public long getOutput_count() {
+    return pjsuaJNI.pjmedia_snd_dev_info_output_count_get(swigCPtr, this);
+  }
+
+  public void setDefault_samples_per_sec(long value) {
+    pjsuaJNI.pjmedia_snd_dev_info_default_samples_per_sec_set(swigCPtr, this, value);
+  }
+
+  public long getDefault_samples_per_sec() {
+    return pjsuaJNI.pjmedia_snd_dev_info_default_samples_per_sec_get(swigCPtr, this);
+  }
+
+  public pjmedia_snd_dev_info() {
+    this(pjsuaJNI.new_pjmedia_snd_dev_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjmedia_srtp_use.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjmedia_srtp_use.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjmedia_srtp_use.java	(working copy)
@@ -0,0 +1,53 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjmedia_srtp_use {
+  PJMEDIA_SRTP_DISABLED,
+  PJMEDIA_SRTP_OPTIONAL,
+  PJMEDIA_SRTP_MANDATORY;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjmedia_srtp_use swigToEnum(int swigValue) {
+    pjmedia_srtp_use[] swigValues = pjmedia_srtp_use.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjmedia_srtp_use swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjmedia_srtp_use.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjmedia_srtp_use() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjmedia_srtp_use(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjmedia_srtp_use(pjmedia_srtp_use swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjmedia_tone_desc.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjmedia_tone_desc.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjmedia_tone_desc.java	(working copy)
@@ -0,0 +1,104 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjmedia_tone_desc {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjmedia_tone_desc(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjmedia_tone_desc obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjmedia_tone_desc(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  protected static long[] cArrayUnwrap(pjmedia_tone_desc[] arrayWrapper) {
+      long[] cArray = new long[arrayWrapper.length];
+      for (int i=0; i<arrayWrapper.length; i++)
+        cArray[i] = pjmedia_tone_desc.getCPtr(arrayWrapper[i]);
+      return cArray;
+  }
+
+  protected static pjmedia_tone_desc[] cArrayWrap(long[] cArray, boolean cMemoryOwn) {
+    pjmedia_tone_desc[] arrayWrapper = new pjmedia_tone_desc[cArray.length];
+    for (int i=0; i<cArray.length; i++)
+      arrayWrapper[i] = new pjmedia_tone_desc(cArray[i], cMemoryOwn);
+    return arrayWrapper;
+  }
+
+  public void setFreq1(short value) {
+    pjsuaJNI.pjmedia_tone_desc_freq1_set(swigCPtr, this, value);
+  }
+
+  public short getFreq1() {
+    return pjsuaJNI.pjmedia_tone_desc_freq1_get(swigCPtr, this);
+  }
+
+  public void setFreq2(short value) {
+    pjsuaJNI.pjmedia_tone_desc_freq2_set(swigCPtr, this, value);
+  }
+
+  public short getFreq2() {
+    return pjsuaJNI.pjmedia_tone_desc_freq2_get(swigCPtr, this);
+  }
+
+  public void setOn_msec(short value) {
+    pjsuaJNI.pjmedia_tone_desc_on_msec_set(swigCPtr, this, value);
+  }
+
+  public short getOn_msec() {
+    return pjsuaJNI.pjmedia_tone_desc_on_msec_get(swigCPtr, this);
+  }
+
+  public void setOff_msec(short value) {
+    pjsuaJNI.pjmedia_tone_desc_off_msec_set(swigCPtr, this, value);
+  }
+
+  public short getOff_msec() {
+    return pjsuaJNI.pjmedia_tone_desc_off_msec_get(swigCPtr, this);
+  }
+
+  public void setVolume(short value) {
+    pjsuaJNI.pjmedia_tone_desc_volume_set(swigCPtr, this, value);
+  }
+
+  public short getVolume() {
+    return pjsuaJNI.pjmedia_tone_desc_volume_get(swigCPtr, this);
+  }
+
+  public void setFlags(short value) {
+    pjsuaJNI.pjmedia_tone_desc_flags_set(swigCPtr, this, value);
+  }
+
+  public short getFlags() {
+    return pjsuaJNI.pjmedia_tone_desc_flags_get(swigCPtr, this);
+  }
+
+  public pjmedia_tone_desc() {
+    this(pjsuaJNI.new_pjmedia_tone_desc(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjmedia_tone_digit.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjmedia_tone_digit.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjmedia_tone_digit.java	(working copy)
@@ -0,0 +1,88 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjmedia_tone_digit {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjmedia_tone_digit(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjmedia_tone_digit obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjmedia_tone_digit(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  protected static long[] cArrayUnwrap(pjmedia_tone_digit[] arrayWrapper) {
+      long[] cArray = new long[arrayWrapper.length];
+      for (int i=0; i<arrayWrapper.length; i++)
+        cArray[i] = pjmedia_tone_digit.getCPtr(arrayWrapper[i]);
+      return cArray;
+  }
+
+  protected static pjmedia_tone_digit[] cArrayWrap(long[] cArray, boolean cMemoryOwn) {
+    pjmedia_tone_digit[] arrayWrapper = new pjmedia_tone_digit[cArray.length];
+    for (int i=0; i<cArray.length; i++)
+      arrayWrapper[i] = new pjmedia_tone_digit(cArray[i], cMemoryOwn);
+    return arrayWrapper;
+  }
+
+  public void setDigit(char value) {
+    pjsuaJNI.pjmedia_tone_digit_digit_set(swigCPtr, this, value);
+  }
+
+  public char getDigit() {
+    return pjsuaJNI.pjmedia_tone_digit_digit_get(swigCPtr, this);
+  }
+
+  public void setOn_msec(short value) {
+    pjsuaJNI.pjmedia_tone_digit_on_msec_set(swigCPtr, this, value);
+  }
+
+  public short getOn_msec() {
+    return pjsuaJNI.pjmedia_tone_digit_on_msec_get(swigCPtr, this);
+  }
+
+  public void setOff_msec(short value) {
+    pjsuaJNI.pjmedia_tone_digit_off_msec_set(swigCPtr, this, value);
+  }
+
+  public short getOff_msec() {
+    return pjsuaJNI.pjmedia_tone_digit_off_msec_get(swigCPtr, this);
+  }
+
+  public void setVolume(short value) {
+    pjsuaJNI.pjmedia_tone_digit_volume_set(swigCPtr, this, value);
+  }
+
+  public short getVolume() {
+    return pjsuaJNI.pjmedia_tone_digit_volume_get(swigCPtr, this);
+  }
+
+  public pjmedia_tone_digit() {
+    this(pjsuaJNI.new_pjmedia_tone_digit(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjrpid_activity.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjrpid_activity.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjrpid_activity.java	(working copy)
@@ -0,0 +1,53 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjrpid_activity {
+  PJRPID_ACTIVITY_UNKNOWN,
+  PJRPID_ACTIVITY_AWAY,
+  PJRPID_ACTIVITY_BUSY;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjrpid_activity swigToEnum(int swigValue) {
+    pjrpid_activity[] swigValues = pjrpid_activity.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjrpid_activity swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjrpid_activity.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjrpid_activity() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjrpid_activity(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjrpid_activity(pjrpid_activity swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjrpid_element.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjrpid_element.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjrpid_element.java	(working copy)
@@ -0,0 +1,76 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjrpid_element {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjrpid_element(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjrpid_element obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjrpid_element(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setType(SWIGTYPE_p_pjrpid_element_type value) {
+    pjsuaJNI.pjrpid_element_type_set(swigCPtr, this, SWIGTYPE_p_pjrpid_element_type.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjrpid_element_type getType() {
+    return new SWIGTYPE_p_pjrpid_element_type(pjsuaJNI.pjrpid_element_type_get(swigCPtr, this), true);
+  }
+
+  public void setId(pj_str_t value) {
+    pjsuaJNI.pjrpid_element_id_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getId() {
+    long cPtr = pjsuaJNI.pjrpid_element_id_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setActivity(pjrpid_activity value) {
+    pjsuaJNI.pjrpid_element_activity_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjrpid_activity getActivity() {
+    return pjrpid_activity.swigToEnum(pjsuaJNI.pjrpid_element_activity_get(swigCPtr, this));
+  }
+
+  public void setNote(pj_str_t value) {
+    pjsuaJNI.pjrpid_element_note_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getNote() {
+    long cPtr = pjsuaJNI.pjrpid_element_note_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public pjrpid_element() {
+    this(pjsuaJNI.new_pjrpid_element(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_auth_clt_pref.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_auth_clt_pref.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_auth_clt_pref.java	(working copy)
@@ -0,0 +1,59 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsip_auth_clt_pref {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsip_auth_clt_pref(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsip_auth_clt_pref obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsip_auth_clt_pref(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setInitial_auth(int value) {
+    pjsuaJNI.pjsip_auth_clt_pref_initial_auth_set(swigCPtr, this, value);
+  }
+
+  public int getInitial_auth() {
+    return pjsuaJNI.pjsip_auth_clt_pref_initial_auth_get(swigCPtr, this);
+  }
+
+  public void setAlgorithm(pj_str_t value) {
+    pjsuaJNI.pjsip_auth_clt_pref_algorithm_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getAlgorithm() {
+    long cPtr = pjsuaJNI.pjsip_auth_clt_pref_algorithm_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public pjsip_auth_clt_pref() {
+    this(pjsuaJNI.new_pjsip_auth_clt_pref(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_cred_data_type.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_cred_data_type.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_cred_data_type.java	(working copy)
@@ -0,0 +1,53 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsip_cred_data_type {
+  PJSIP_CRED_DATA_PLAIN_PASSWD(pjsuaJNI.PJSIP_CRED_DATA_PLAIN_PASSWD_get()),
+  PJSIP_CRED_DATA_DIGEST(pjsuaJNI.PJSIP_CRED_DATA_DIGEST_get()),
+  PJSIP_CRED_DATA_EXT_AKA(pjsuaJNI.PJSIP_CRED_DATA_EXT_AKA_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsip_cred_data_type swigToEnum(int swigValue) {
+    pjsip_cred_data_type[] swigValues = pjsip_cred_data_type.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsip_cred_data_type swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsip_cred_data_type.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_cred_data_type() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_cred_data_type(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_cred_data_type(pjsip_cred_data_type swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_cred_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_cred_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_cred_info.java	(working copy)
@@ -0,0 +1,86 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsip_cred_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsip_cred_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsip_cred_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsip_cred_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setRealm(pj_str_t value) {
+    pjsuaJNI.pjsip_cred_info_realm_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getRealm() {
+    long cPtr = pjsuaJNI.pjsip_cred_info_realm_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setScheme(pj_str_t value) {
+    pjsuaJNI.pjsip_cred_info_scheme_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getScheme() {
+    long cPtr = pjsuaJNI.pjsip_cred_info_scheme_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setUsername(pj_str_t value) {
+    pjsuaJNI.pjsip_cred_info_username_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getUsername() {
+    long cPtr = pjsuaJNI.pjsip_cred_info_username_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setData_type(int value) {
+    pjsuaJNI.pjsip_cred_info_data_type_set(swigCPtr, this, value);
+  }
+
+  public int getData_type() {
+    return pjsuaJNI.pjsip_cred_info_data_type_get(swigCPtr, this);
+  }
+
+  public void setData(pj_str_t value) {
+    pjsuaJNI.pjsip_cred_info_data_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getData() {
+    long cPtr = pjsuaJNI.pjsip_cred_info_data_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public pjsip_cred_info() {
+    this(pjsuaJNI.new_pjsip_cred_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_event.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_event.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_event.java	(working copy)
@@ -0,0 +1,50 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsip_event {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsip_event(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsip_event obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsip_event(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setType(pjsip_event_id_e value) {
+    pjsuaJNI.pjsip_event_type_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsip_event_id_e getType() {
+    return pjsip_event_id_e.swigToEnum(pjsuaJNI.pjsip_event_type_get(swigCPtr, this));
+  }
+
+  public pjsip_event() {
+    this(pjsuaJNI.new_pjsip_event(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_event_id_e.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_event_id_e.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_event_id_e.java	(working copy)
@@ -0,0 +1,57 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsip_event_id_e {
+  PJSIP_EVENT_UNKNOWN,
+  PJSIP_EVENT_TIMER,
+  PJSIP_EVENT_TX_MSG,
+  PJSIP_EVENT_RX_MSG,
+  PJSIP_EVENT_TRANSPORT_ERROR,
+  PJSIP_EVENT_TSX_STATE,
+  PJSIP_EVENT_USER;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsip_event_id_e swigToEnum(int swigValue) {
+    pjsip_event_id_e[] swigValues = pjsip_event_id_e.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsip_event_id_e swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsip_event_id_e.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_event_id_e() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_event_id_e(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_event_id_e(pjsip_event_id_e swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_inv_state.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_inv_state.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_inv_state.java	(working copy)
@@ -0,0 +1,57 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsip_inv_state {
+  PJSIP_INV_STATE_NULL,
+  PJSIP_INV_STATE_CALLING,
+  PJSIP_INV_STATE_INCOMING,
+  PJSIP_INV_STATE_EARLY,
+  PJSIP_INV_STATE_CONNECTING,
+  PJSIP_INV_STATE_CONFIRMED,
+  PJSIP_INV_STATE_DISCONNECTED;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsip_inv_state swigToEnum(int swigValue) {
+    pjsip_inv_state[] swigValues = pjsip_inv_state.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsip_inv_state swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsip_inv_state.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_inv_state() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_inv_state(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_inv_state(pjsip_inv_state swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_redirect_op.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_redirect_op.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_redirect_op.java	(working copy)
@@ -0,0 +1,55 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsip_redirect_op {
+  PJSIP_REDIRECT_REJECT,
+  PJSIP_REDIRECT_ACCEPT_REPLACE,
+  PJSIP_REDIRECT_ACCEPT,
+  PJSIP_REDIRECT_PENDING,
+  PJSIP_REDIRECT_STOP;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsip_redirect_op swigToEnum(int swigValue) {
+    pjsip_redirect_op[] swigValues = pjsip_redirect_op.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsip_redirect_op swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsip_redirect_op.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_redirect_op() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_redirect_op(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_redirect_op(pjsip_redirect_op swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_ssl_method.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_ssl_method.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_ssl_method.java	(working copy)
@@ -0,0 +1,57 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsip_ssl_method {
+  PJSIP_SSL_UNSPECIFIED_METHOD(pjsuaJNI.PJSIP_SSL_UNSPECIFIED_METHOD_get()),
+  PJSIP_SSLV2_METHOD(pjsuaJNI.PJSIP_SSLV2_METHOD_get()),
+  PJSIP_SSLV3_METHOD(pjsuaJNI.PJSIP_SSLV3_METHOD_get()),
+  PJSIP_TLSV1_METHOD(pjsuaJNI.PJSIP_TLSV1_METHOD_get()),
+  PJSIP_TLSV1_1_METHOD(pjsuaJNI.PJSIP_TLSV1_1_METHOD_get()),
+  PJSIP_TLSV1_2_METHOD(pjsuaJNI.PJSIP_TLSV1_2_METHOD_get()),
+  PJSIP_SSLV23_METHOD(pjsuaJNI.PJSIP_SSLV23_METHOD_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsip_ssl_method swigToEnum(int swigValue) {
+    pjsip_ssl_method[] swigValues = pjsip_ssl_method.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsip_ssl_method swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsip_ssl_method.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_ssl_method() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_ssl_method(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_ssl_method(pjsip_ssl_method swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_status_code.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_status_code.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_status_code.java	(working copy)
@@ -0,0 +1,107 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsip_status_code {
+  PJSIP_SC_TRYING(pjsuaJNI.PJSIP_SC_TRYING_get()),
+  PJSIP_SC_RINGING(pjsuaJNI.PJSIP_SC_RINGING_get()),
+  PJSIP_SC_CALL_BEING_FORWARDED(pjsuaJNI.PJSIP_SC_CALL_BEING_FORWARDED_get()),
+  PJSIP_SC_QUEUED(pjsuaJNI.PJSIP_SC_QUEUED_get()),
+  PJSIP_SC_PROGRESS(pjsuaJNI.PJSIP_SC_PROGRESS_get()),
+  PJSIP_SC_OK(pjsuaJNI.PJSIP_SC_OK_get()),
+  PJSIP_SC_ACCEPTED(pjsuaJNI.PJSIP_SC_ACCEPTED_get()),
+  PJSIP_SC_MULTIPLE_CHOICES(pjsuaJNI.PJSIP_SC_MULTIPLE_CHOICES_get()),
+  PJSIP_SC_MOVED_PERMANENTLY(pjsuaJNI.PJSIP_SC_MOVED_PERMANENTLY_get()),
+  PJSIP_SC_MOVED_TEMPORARILY(pjsuaJNI.PJSIP_SC_MOVED_TEMPORARILY_get()),
+  PJSIP_SC_USE_PROXY(pjsuaJNI.PJSIP_SC_USE_PROXY_get()),
+  PJSIP_SC_ALTERNATIVE_SERVICE(pjsuaJNI.PJSIP_SC_ALTERNATIVE_SERVICE_get()),
+  PJSIP_SC_BAD_REQUEST(pjsuaJNI.PJSIP_SC_BAD_REQUEST_get()),
+  PJSIP_SC_UNAUTHORIZED(pjsuaJNI.PJSIP_SC_UNAUTHORIZED_get()),
+  PJSIP_SC_PAYMENT_REQUIRED(pjsuaJNI.PJSIP_SC_PAYMENT_REQUIRED_get()),
+  PJSIP_SC_FORBIDDEN(pjsuaJNI.PJSIP_SC_FORBIDDEN_get()),
+  PJSIP_SC_NOT_FOUND(pjsuaJNI.PJSIP_SC_NOT_FOUND_get()),
+  PJSIP_SC_METHOD_NOT_ALLOWED(pjsuaJNI.PJSIP_SC_METHOD_NOT_ALLOWED_get()),
+  PJSIP_SC_NOT_ACCEPTABLE(pjsuaJNI.PJSIP_SC_NOT_ACCEPTABLE_get()),
+  PJSIP_SC_PROXY_AUTHENTICATION_REQUIRED(pjsuaJNI.PJSIP_SC_PROXY_AUTHENTICATION_REQUIRED_get()),
+  PJSIP_SC_REQUEST_TIMEOUT(pjsuaJNI.PJSIP_SC_REQUEST_TIMEOUT_get()),
+  PJSIP_SC_GONE(pjsuaJNI.PJSIP_SC_GONE_get()),
+  PJSIP_SC_REQUEST_ENTITY_TOO_LARGE(pjsuaJNI.PJSIP_SC_REQUEST_ENTITY_TOO_LARGE_get()),
+  PJSIP_SC_REQUEST_URI_TOO_LONG(pjsuaJNI.PJSIP_SC_REQUEST_URI_TOO_LONG_get()),
+  PJSIP_SC_UNSUPPORTED_MEDIA_TYPE(pjsuaJNI.PJSIP_SC_UNSUPPORTED_MEDIA_TYPE_get()),
+  PJSIP_SC_UNSUPPORTED_URI_SCHEME(pjsuaJNI.PJSIP_SC_UNSUPPORTED_URI_SCHEME_get()),
+  PJSIP_SC_BAD_EXTENSION(pjsuaJNI.PJSIP_SC_BAD_EXTENSION_get()),
+  PJSIP_SC_EXTENSION_REQUIRED(pjsuaJNI.PJSIP_SC_EXTENSION_REQUIRED_get()),
+  PJSIP_SC_SESSION_TIMER_TOO_SMALL(pjsuaJNI.PJSIP_SC_SESSION_TIMER_TOO_SMALL_get()),
+  PJSIP_SC_INTERVAL_TOO_BRIEF(pjsuaJNI.PJSIP_SC_INTERVAL_TOO_BRIEF_get()),
+  PJSIP_SC_TEMPORARILY_UNAVAILABLE(pjsuaJNI.PJSIP_SC_TEMPORARILY_UNAVAILABLE_get()),
+  PJSIP_SC_CALL_TSX_DOES_NOT_EXIST(pjsuaJNI.PJSIP_SC_CALL_TSX_DOES_NOT_EXIST_get()),
+  PJSIP_SC_LOOP_DETECTED(pjsuaJNI.PJSIP_SC_LOOP_DETECTED_get()),
+  PJSIP_SC_TOO_MANY_HOPS(pjsuaJNI.PJSIP_SC_TOO_MANY_HOPS_get()),
+  PJSIP_SC_ADDRESS_INCOMPLETE(pjsuaJNI.PJSIP_SC_ADDRESS_INCOMPLETE_get()),
+  PJSIP_AC_AMBIGUOUS(pjsuaJNI.PJSIP_AC_AMBIGUOUS_get()),
+  PJSIP_SC_BUSY_HERE(pjsuaJNI.PJSIP_SC_BUSY_HERE_get()),
+  PJSIP_SC_REQUEST_TERMINATED(pjsuaJNI.PJSIP_SC_REQUEST_TERMINATED_get()),
+  PJSIP_SC_NOT_ACCEPTABLE_HERE(pjsuaJNI.PJSIP_SC_NOT_ACCEPTABLE_HERE_get()),
+  PJSIP_SC_BAD_EVENT(pjsuaJNI.PJSIP_SC_BAD_EVENT_get()),
+  PJSIP_SC_REQUEST_UPDATED(pjsuaJNI.PJSIP_SC_REQUEST_UPDATED_get()),
+  PJSIP_SC_REQUEST_PENDING(pjsuaJNI.PJSIP_SC_REQUEST_PENDING_get()),
+  PJSIP_SC_UNDECIPHERABLE(pjsuaJNI.PJSIP_SC_UNDECIPHERABLE_get()),
+  PJSIP_SC_INTERNAL_SERVER_ERROR(pjsuaJNI.PJSIP_SC_INTERNAL_SERVER_ERROR_get()),
+  PJSIP_SC_NOT_IMPLEMENTED(pjsuaJNI.PJSIP_SC_NOT_IMPLEMENTED_get()),
+  PJSIP_SC_BAD_GATEWAY(pjsuaJNI.PJSIP_SC_BAD_GATEWAY_get()),
+  PJSIP_SC_SERVICE_UNAVAILABLE(pjsuaJNI.PJSIP_SC_SERVICE_UNAVAILABLE_get()),
+  PJSIP_SC_SERVER_TIMEOUT(pjsuaJNI.PJSIP_SC_SERVER_TIMEOUT_get()),
+  PJSIP_SC_VERSION_NOT_SUPPORTED(pjsuaJNI.PJSIP_SC_VERSION_NOT_SUPPORTED_get()),
+  PJSIP_SC_MESSAGE_TOO_LARGE(pjsuaJNI.PJSIP_SC_MESSAGE_TOO_LARGE_get()),
+  PJSIP_SC_PRECONDITION_FAILURE(pjsuaJNI.PJSIP_SC_PRECONDITION_FAILURE_get()),
+  PJSIP_SC_BUSY_EVERYWHERE(pjsuaJNI.PJSIP_SC_BUSY_EVERYWHERE_get()),
+  PJSIP_SC_DECLINE(pjsuaJNI.PJSIP_SC_DECLINE_get()),
+  PJSIP_SC_DOES_NOT_EXIST_ANYWHERE(pjsuaJNI.PJSIP_SC_DOES_NOT_EXIST_ANYWHERE_get()),
+  PJSIP_SC_NOT_ACCEPTABLE_ANYWHERE(pjsuaJNI.PJSIP_SC_NOT_ACCEPTABLE_ANYWHERE_get()),
+  PJSIP_SC_TSX_TIMEOUT(pjsuaJNI.PJSIP_SC_TSX_TIMEOUT_get()),
+  PJSIP_SC_TSX_TRANSPORT_ERROR(pjsuaJNI.PJSIP_SC_TSX_TRANSPORT_ERROR_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsip_status_code swigToEnum(int swigValue) {
+    pjsip_status_code[] swigValues = pjsip_status_code.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsip_status_code swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsip_status_code.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_status_code() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_status_code(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_status_code(pjsip_status_code swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_timer_setting.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_timer_setting.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_timer_setting.java	(working copy)
@@ -0,0 +1,58 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsip_timer_setting {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsip_timer_setting(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsip_timer_setting obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsip_timer_setting(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setMin_se(long value) {
+    pjsuaJNI.pjsip_timer_setting_min_se_set(swigCPtr, this, value);
+  }
+
+  public long getMin_se() {
+    return pjsuaJNI.pjsip_timer_setting_min_se_get(swigCPtr, this);
+  }
+
+  public void setSess_expires(long value) {
+    pjsuaJNI.pjsip_timer_setting_sess_expires_set(swigCPtr, this, value);
+  }
+
+  public long getSess_expires() {
+    return pjsuaJNI.pjsip_timer_setting_sess_expires_get(swigCPtr, this);
+  }
+
+  public pjsip_timer_setting() {
+    this(pjsuaJNI.new_pjsip_timer_setting(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_tls_setting.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_tls_setting.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_tls_setting.java	(working copy)
@@ -0,0 +1,202 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsip_tls_setting {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsip_tls_setting(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsip_tls_setting obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsip_tls_setting(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setCa_list_file(pj_str_t value) {
+    pjsuaJNI.pjsip_tls_setting_ca_list_file_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getCa_list_file() {
+    long cPtr = pjsuaJNI.pjsip_tls_setting_ca_list_file_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setCa_list_path(pj_str_t value) {
+    pjsuaJNI.pjsip_tls_setting_ca_list_path_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getCa_list_path() {
+    long cPtr = pjsuaJNI.pjsip_tls_setting_ca_list_path_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setCert_file(pj_str_t value) {
+    pjsuaJNI.pjsip_tls_setting_cert_file_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getCert_file() {
+    long cPtr = pjsuaJNI.pjsip_tls_setting_cert_file_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setPrivkey_file(pj_str_t value) {
+    pjsuaJNI.pjsip_tls_setting_privkey_file_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getPrivkey_file() {
+    long cPtr = pjsuaJNI.pjsip_tls_setting_privkey_file_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setPassword(pj_str_t value) {
+    pjsuaJNI.pjsip_tls_setting_password_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getPassword() {
+    long cPtr = pjsuaJNI.pjsip_tls_setting_password_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setMethod(pjsip_ssl_method value) {
+    pjsuaJNI.pjsip_tls_setting_method_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsip_ssl_method getMethod() {
+    return pjsip_ssl_method.swigToEnum(pjsuaJNI.pjsip_tls_setting_method_get(swigCPtr, this));
+  }
+
+  public void setProto(long value) {
+    pjsuaJNI.pjsip_tls_setting_proto_set(swigCPtr, this, value);
+  }
+
+  public long getProto() {
+    return pjsuaJNI.pjsip_tls_setting_proto_get(swigCPtr, this);
+  }
+
+  public void setCiphers_num(long value) {
+    pjsuaJNI.pjsip_tls_setting_ciphers_num_set(swigCPtr, this, value);
+  }
+
+  public long getCiphers_num() {
+    return pjsuaJNI.pjsip_tls_setting_ciphers_num_get(swigCPtr, this);
+  }
+
+  public void setCiphers(SWIGTYPE_p_pj_ssl_cipher value) {
+    pjsuaJNI.pjsip_tls_setting_ciphers_set(swigCPtr, this, SWIGTYPE_p_pj_ssl_cipher.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_ssl_cipher getCiphers() {
+    long cPtr = pjsuaJNI.pjsip_tls_setting_ciphers_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pj_ssl_cipher(cPtr, false);
+  }
+
+  public void setVerify_server(int value) {
+    pjsuaJNI.pjsip_tls_setting_verify_server_set(swigCPtr, this, value);
+  }
+
+  public int getVerify_server() {
+    return pjsuaJNI.pjsip_tls_setting_verify_server_get(swigCPtr, this);
+  }
+
+  public void setVerify_client(int value) {
+    pjsuaJNI.pjsip_tls_setting_verify_client_set(swigCPtr, this, value);
+  }
+
+  public int getVerify_client() {
+    return pjsuaJNI.pjsip_tls_setting_verify_client_get(swigCPtr, this);
+  }
+
+  public void setRequire_client_cert(int value) {
+    pjsuaJNI.pjsip_tls_setting_require_client_cert_set(swigCPtr, this, value);
+  }
+
+  public int getRequire_client_cert() {
+    return pjsuaJNI.pjsip_tls_setting_require_client_cert_get(swigCPtr, this);
+  }
+
+  public void setTimeout(pj_time_val value) {
+    pjsuaJNI.pjsip_tls_setting_timeout_set(swigCPtr, this, pj_time_val.getCPtr(value), value);
+  }
+
+  public pj_time_val getTimeout() {
+    long cPtr = pjsuaJNI.pjsip_tls_setting_timeout_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_time_val(cPtr, false);
+  }
+
+  public void setReuse_addr(int value) {
+    pjsuaJNI.pjsip_tls_setting_reuse_addr_set(swigCPtr, this, value);
+  }
+
+  public int getReuse_addr() {
+    return pjsuaJNI.pjsip_tls_setting_reuse_addr_get(swigCPtr, this);
+  }
+
+  public void setQos_type(pj_qos_type value) {
+    pjsuaJNI.pjsip_tls_setting_qos_type_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pj_qos_type getQos_type() {
+    return pj_qos_type.swigToEnum(pjsuaJNI.pjsip_tls_setting_qos_type_get(swigCPtr, this));
+  }
+
+  public void setQos_params(pj_qos_params value) {
+    pjsuaJNI.pjsip_tls_setting_qos_params_set(swigCPtr, this, pj_qos_params.getCPtr(value), value);
+  }
+
+  public pj_qos_params getQos_params() {
+    long cPtr = pjsuaJNI.pjsip_tls_setting_qos_params_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_qos_params(cPtr, false);
+  }
+
+  public void setQos_ignore_error(int value) {
+    pjsuaJNI.pjsip_tls_setting_qos_ignore_error_set(swigCPtr, this, value);
+  }
+
+  public int getQos_ignore_error() {
+    return pjsuaJNI.pjsip_tls_setting_qos_ignore_error_get(swigCPtr, this);
+  }
+
+  public void setSockopt_params(SWIGTYPE_p_pj_sockopt_params value) {
+    pjsuaJNI.pjsip_tls_setting_sockopt_params_set(swigCPtr, this, SWIGTYPE_p_pj_sockopt_params.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_sockopt_params getSockopt_params() {
+    return new SWIGTYPE_p_pj_sockopt_params(pjsuaJNI.pjsip_tls_setting_sockopt_params_get(swigCPtr, this), true);
+  }
+
+  public void setSockopt_ignore_error(int value) {
+    pjsuaJNI.pjsip_tls_setting_sockopt_ignore_error_set(swigCPtr, this, value);
+  }
+
+  public int getSockopt_ignore_error() {
+    return pjsuaJNI.pjsip_tls_setting_sockopt_ignore_error_get(swigCPtr, this);
+  }
+
+  public pjsip_tls_setting() {
+    this(pjsuaJNI.new_pjsip_tls_setting(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_transport_type_e.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_transport_type_e.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_transport_type_e.java	(working copy)
@@ -0,0 +1,62 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsip_transport_type_e {
+  PJSIP_TRANSPORT_UNSPECIFIED,
+  PJSIP_TRANSPORT_UDP,
+  PJSIP_TRANSPORT_TCP,
+  PJSIP_TRANSPORT_TLS,
+  PJSIP_TRANSPORT_SCTP,
+  PJSIP_TRANSPORT_LOOP,
+  PJSIP_TRANSPORT_LOOP_DGRAM,
+  PJSIP_TRANSPORT_START_OTHER,
+  PJSIP_TRANSPORT_IPV6(pjsuaJNI.PJSIP_TRANSPORT_IPV6_get()),
+  PJSIP_TRANSPORT_UDP6(pjsuaJNI.PJSIP_TRANSPORT_UDP6_get()),
+  PJSIP_TRANSPORT_TCP6(pjsuaJNI.PJSIP_TRANSPORT_TCP6_get()),
+  PJSIP_TRANSPORT_TLS6(pjsuaJNI.PJSIP_TRANSPORT_TLS6_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsip_transport_type_e swigToEnum(int swigValue) {
+    pjsip_transport_type_e[] swigValues = pjsip_transport_type_e.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsip_transport_type_e swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsip_transport_type_e.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_transport_type_e() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_transport_type_e(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_transport_type_e(pjsip_transport_type_e swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua.java	(working copy)
@@ -0,0 +1,915 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua implements pjsuaConstants {
+  public static pj_str_t pj_str_copy(String str) {
+    return new pj_str_t(pjsuaJNI.pj_str_copy(str), true);
+  }
+
+  public static void setCallbackObject(Callback callback) {
+    pjsuaJNI.setCallbackObject(Callback.getCPtr(callback), callback);
+  }
+
+  public static pj_pool_t pjsua_pool_create(String name, long init_size, long increment) {
+    long cPtr = pjsuaJNI.pjsua_pool_create(name, init_size, increment);
+    return (cPtr == 0) ? null : new pj_pool_t(cPtr, false);
+  }
+
+  public static void pj_pool_release(pj_pool_t pool) {
+    pjsuaJNI.pj_pool_release(pj_pool_t.getCPtr(pool), pool);
+  }
+
+  public static int pjmedia_tonegen_create2(pj_pool_t pool, pj_str_t name, long clock_rate, long channel_count, long samples_per_frame, long bits_per_sample, long options, pjmedia_port pp_port) {
+    return pjsuaJNI.pjmedia_tonegen_create2(pj_pool_t.getCPtr(pool), pool, pj_str_t.getCPtr(name), name, clock_rate, channel_count, samples_per_frame, bits_per_sample, options, pp_port);
+  }
+
+  public static int pjmedia_tonegen_play(pjmedia_port tonegen, long count, pjmedia_tone_desc[] tones, long options) {
+    return pjsuaJNI.pjmedia_tonegen_play(pjmedia_port.getCPtr(tonegen), tonegen, count, pjmedia_tone_desc.cArrayUnwrap(tones), options);
+  }
+
+  public static int pjmedia_tonegen_play_digits(pjmedia_port tonegen, long count, pjmedia_tone_digit[] digits, long options) {
+    return pjsuaJNI.pjmedia_tonegen_play_digits(pjmedia_port.getCPtr(tonegen), tonegen, count, pjmedia_tone_digit.cArrayUnwrap(digits), options);
+  }
+
+  public static int pjmedia_tonegen_rewind(pjmedia_port tonegen) {
+    return pjsuaJNI.pjmedia_tonegen_rewind(pjmedia_port.getCPtr(tonegen), tonegen);
+  }
+
+  public static int pjmedia_tonegen_stop(pjmedia_port tonegen) {
+    return pjsuaJNI.pjmedia_tonegen_stop(pjmedia_port.getCPtr(tonegen), tonegen);
+  }
+
+  public static int pjmedia_port_destroy(pjmedia_port port) {
+    return pjsuaJNI.pjmedia_port_destroy(pjmedia_port.getCPtr(port), port);
+  }
+
+  public static void setZrtpCallbackObject(ZrtpCallback callback) {
+    pjsuaJNI.setZrtpCallbackObject(ZrtpCallback.getCPtr(callback), callback);
+  }
+
+  public static int mobile_reg_handler_init() {
+    return pjsuaJNI.mobile_reg_handler_init();
+  }
+
+  public static void mobile_reg_handler_set_callback(MobileRegHandlerCallback callback) {
+    pjsuaJNI.mobile_reg_handler_set_callback(MobileRegHandlerCallback.getCPtr(callback), callback);
+  }
+
+  public static int sipclf_mod_init() {
+    return pjsuaJNI.sipclf_mod_init();
+  }
+
+  public static int mod_earlylock_init() {
+    return pjsuaJNI.mod_earlylock_init();
+  }
+
+  public static void mod_earlylock_set_callback(EarlyLockCallback callback) {
+    pjsuaJNI.mod_earlylock_set_callback(EarlyLockCallback.getCPtr(callback), callback);
+  }
+
+  public synchronized static void logging_config_default(pjsua_logging_config cfg) {
+    pjsuaJNI.logging_config_default(pjsua_logging_config.getCPtr(cfg), cfg);
+  }
+
+  public synchronized static void logging_config_dup(pj_pool_t pool, pjsua_logging_config dst, pjsua_logging_config src) {
+    pjsuaJNI.logging_config_dup(pj_pool_t.getCPtr(pool), pool, pjsua_logging_config.getCPtr(dst), dst, pjsua_logging_config.getCPtr(src), src);
+  }
+
+  public synchronized static void config_default(pjsua_config cfg) {
+    pjsuaJNI.config_default(pjsua_config.getCPtr(cfg), cfg);
+  }
+
+  public synchronized static void config_dup(pj_pool_t pool, pjsua_config dst, pjsua_config src) {
+    pjsuaJNI.config_dup(pj_pool_t.getCPtr(pool), pool, pjsua_config.getCPtr(dst), dst, pjsua_config.getCPtr(src), src);
+  }
+
+  public synchronized static void msg_data_init(pjsua_msg_data msg_data) {
+    pjsuaJNI.msg_data_init(pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static pjsua_msg_data msg_data_clone(pj_pool_t pool, pjsua_msg_data rhs) {
+    long cPtr = pjsuaJNI.msg_data_clone(pj_pool_t.getCPtr(pool), pool, pjsua_msg_data.getCPtr(rhs), rhs);
+    return (cPtr == 0) ? null : new pjsua_msg_data(cPtr, false);
+  }
+
+  public synchronized static int create() {
+    return pjsuaJNI.create();
+  }
+
+  public synchronized static int start() {
+    return pjsuaJNI.start();
+  }
+
+  public synchronized static pjsua_state get_state() {
+    return pjsua_state.swigToEnum(pjsuaJNI.get_state());
+  }
+
+  public synchronized static int handle_events(long msec_timeout) {
+    return pjsuaJNI.handle_events(msec_timeout);
+  }
+
+  public synchronized static void stop_worker_threads() {
+    pjsuaJNI.stop_worker_threads();
+  }
+
+  public synchronized static pj_pool_t pool_create(String name, long init_size, long increment) {
+    long cPtr = pjsuaJNI.pool_create(name, init_size, increment);
+    return (cPtr == 0) ? null : new pj_pool_t(cPtr, false);
+  }
+
+  public synchronized static int reconfigure_logging(pjsua_logging_config c) {
+    return pjsuaJNI.reconfigure_logging(pjsua_logging_config.getCPtr(c), c);
+  }
+
+  public synchronized static SWIGTYPE_p_pjsip_endpoint get_pjsip_endpt() {
+    long cPtr = pjsuaJNI.get_pjsip_endpt();
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pjsip_endpoint(cPtr, false);
+  }
+
+  public synchronized static SWIGTYPE_p_pjmedia_endpt get_pjmedia_endpt() {
+    long cPtr = pjsuaJNI.get_pjmedia_endpt();
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pjmedia_endpt(cPtr, false);
+  }
+
+  public synchronized static SWIGTYPE_p_pj_pool_factory get_pool_factory() {
+    long cPtr = pjsuaJNI.get_pool_factory();
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pj_pool_factory(cPtr, false);
+  }
+
+  public synchronized static int detect_nat_type() {
+    return pjsuaJNI.detect_nat_type();
+  }
+
+  public synchronized static int get_nat_type(int[] type) {
+    return pjsuaJNI.get_nat_type(type);
+  }
+
+  public synchronized static int resolve_stun_servers(long count, pj_str_t[] srv, int wait, byte[] token, SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void cb) {
+    return pjsuaJNI.resolve_stun_servers(count, pj_str_t.cArrayUnwrap(srv), wait, token, SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void.getCPtr(cb));
+  }
+
+  public synchronized static int cancel_stun_resolution(byte[] token, int notify_cb) {
+    return pjsuaJNI.cancel_stun_resolution(token, notify_cb);
+  }
+
+  public synchronized static int verify_sip_url(String url) {
+    return pjsuaJNI.verify_sip_url(url);
+  }
+
+  public synchronized static int verify_url(String url) {
+    return pjsuaJNI.verify_url(url);
+  }
+
+  public synchronized static int schedule_timer(SWIGTYPE_p_pj_timer_entry entry, pj_time_val delay) {
+    return pjsuaJNI.schedule_timer(SWIGTYPE_p_pj_timer_entry.getCPtr(entry), pj_time_val.getCPtr(delay), delay);
+  }
+
+  public static int pjsua_schedule_timer2(SWIGTYPE_p_f_p_void__void cb, byte[] user_data, long msec_delay) {
+    return pjsuaJNI.pjsua_schedule_timer2(SWIGTYPE_p_f_p_void__void.getCPtr(cb), user_data, msec_delay);
+  }
+
+  public synchronized static void cancel_timer(SWIGTYPE_p_pj_timer_entry entry) {
+    pjsuaJNI.cancel_timer(SWIGTYPE_p_pj_timer_entry.getCPtr(entry));
+  }
+
+  public synchronized static void perror(String sender, String title, int status) {
+    pjsuaJNI.perror(sender, title, status);
+  }
+
+  public synchronized static void dump(int detail) {
+    pjsuaJNI.dump(detail);
+  }
+
+  public synchronized static void transport_config_default(pjsua_transport_config cfg) {
+    pjsuaJNI.transport_config_default(pjsua_transport_config.getCPtr(cfg), cfg);
+  }
+
+  public synchronized static void transport_config_dup(pj_pool_t pool, pjsua_transport_config dst, pjsua_transport_config src) {
+    pjsuaJNI.transport_config_dup(pj_pool_t.getCPtr(pool), pool, pjsua_transport_config.getCPtr(dst), dst, pjsua_transport_config.getCPtr(src), src);
+  }
+
+  public synchronized static int transport_create(pjsip_transport_type_e type, pjsua_transport_config cfg, int[] p_id) {
+    return pjsuaJNI.transport_create(type.swigValue(), pjsua_transport_config.getCPtr(cfg), cfg, p_id);
+  }
+
+  public synchronized static int transport_register(SWIGTYPE_p_pjsip_transport tp, int[] p_id) {
+    return pjsuaJNI.transport_register(SWIGTYPE_p_pjsip_transport.getCPtr(tp), p_id);
+  }
+
+  public synchronized static int enum_transports(int[] id, long[] count) {
+    return pjsuaJNI.enum_transports(id, count);
+  }
+
+  public synchronized static int transport_get_info(int id, pjsua_transport_info info) {
+    return pjsuaJNI.transport_get_info(id, pjsua_transport_info.getCPtr(info), info);
+  }
+
+  public synchronized static int transport_set_enable(int id, int enabled) {
+    return pjsuaJNI.transport_set_enable(id, enabled);
+  }
+
+  public synchronized static int transport_close(int id, int force) {
+    return pjsuaJNI.transport_close(id, force);
+  }
+
+  public synchronized static void ice_config_from_media_config(pj_pool_t pool, pjsua_ice_config dst, pjsua_media_config src) {
+    pjsuaJNI.ice_config_from_media_config(pj_pool_t.getCPtr(pool), pool, pjsua_ice_config.getCPtr(dst), dst, pjsua_media_config.getCPtr(src), src);
+  }
+
+  public synchronized static void ice_config_dup(pj_pool_t pool, pjsua_ice_config dst, pjsua_ice_config src) {
+    pjsuaJNI.ice_config_dup(pj_pool_t.getCPtr(pool), pool, pjsua_ice_config.getCPtr(dst), dst, pjsua_ice_config.getCPtr(src), src);
+  }
+
+  public synchronized static void turn_config_from_media_config(pj_pool_t pool, pjsua_turn_config dst, pjsua_media_config src) {
+    pjsuaJNI.turn_config_from_media_config(pj_pool_t.getCPtr(pool), pool, pjsua_turn_config.getCPtr(dst), dst, pjsua_media_config.getCPtr(src), src);
+  }
+
+  public synchronized static void turn_config_dup(pj_pool_t pool, pjsua_turn_config dst, pjsua_turn_config src) {
+    pjsuaJNI.turn_config_dup(pj_pool_t.getCPtr(pool), pool, pjsua_turn_config.getCPtr(dst), dst, pjsua_turn_config.getCPtr(src), src);
+  }
+
+  public synchronized static void acc_config_default(pjsua_acc_config cfg) {
+    pjsuaJNI.acc_config_default(pjsua_acc_config.getCPtr(cfg), cfg);
+  }
+
+  public synchronized static void acc_config_dup(pj_pool_t pool, pjsua_acc_config dst, pjsua_acc_config src) {
+    pjsuaJNI.acc_config_dup(pj_pool_t.getCPtr(pool), pool, pjsua_acc_config.getCPtr(dst), dst, pjsua_acc_config.getCPtr(src), src);
+  }
+
+  public synchronized static long acc_get_count() {
+    return pjsuaJNI.acc_get_count();
+  }
+
+  public synchronized static int acc_is_valid(int acc_id) {
+    return pjsuaJNI.acc_is_valid(acc_id);
+  }
+
+  public synchronized static int acc_set_default(int acc_id) {
+    return pjsuaJNI.acc_set_default(acc_id);
+  }
+
+  public synchronized static int acc_get_default() {
+    return pjsuaJNI.acc_get_default();
+  }
+
+  public synchronized static int acc_add(pjsua_acc_config acc_cfg, int is_default, int[] p_acc_id) {
+    return pjsuaJNI.acc_add(pjsua_acc_config.getCPtr(acc_cfg), acc_cfg, is_default, p_acc_id);
+  }
+
+  public synchronized static int acc_add_local(int tid, int is_default, int[] p_acc_id) {
+    return pjsuaJNI.acc_add_local(tid, is_default, p_acc_id);
+  }
+
+  public synchronized static int acc_set_user_data(int acc_id, byte[] user_data) {
+    return pjsuaJNI.acc_set_user_data(acc_id, user_data);
+  }
+
+  public synchronized static byte[] acc_get_user_data(int acc_id) {
+	return pjsuaJNI.acc_get_user_data(acc_id);
+}
+
+  public synchronized static int acc_del(int acc_id) {
+    return pjsuaJNI.acc_del(acc_id);
+  }
+
+  public synchronized static int acc_get_config(int acc_id, pj_pool_t pool, pjsua_acc_config acc_cfg) {
+    return pjsuaJNI.acc_get_config(acc_id, pj_pool_t.getCPtr(pool), pool, pjsua_acc_config.getCPtr(acc_cfg), acc_cfg);
+  }
+
+  public synchronized static int acc_modify(int acc_id, pjsua_acc_config acc_cfg) {
+    return pjsuaJNI.acc_modify(acc_id, pjsua_acc_config.getCPtr(acc_cfg), acc_cfg);
+  }
+
+  public synchronized static int acc_set_online_status(int acc_id, int is_online) {
+    return pjsuaJNI.acc_set_online_status(acc_id, is_online);
+  }
+
+  public synchronized static int acc_set_online_status2(int acc_id, int is_online, pjrpid_element pr) {
+    return pjsuaJNI.acc_set_online_status2(acc_id, is_online, pjrpid_element.getCPtr(pr), pr);
+  }
+
+  public synchronized static int acc_set_registration(int acc_id, int renew) {
+    return pjsuaJNI.acc_set_registration(acc_id, renew);
+  }
+
+  public synchronized static int acc_get_info(int acc_id, pjsua_acc_info info) {
+    return pjsuaJNI.acc_get_info(acc_id, pjsua_acc_info.getCPtr(info), info);
+  }
+
+  public synchronized static int enum_accs(int[] ids, long[] count) {
+    return pjsuaJNI.enum_accs(ids, count);
+  }
+
+  public synchronized static int acc_enum_info(pjsua_acc_info info, long[] count) {
+    return pjsuaJNI.acc_enum_info(pjsua_acc_info.getCPtr(info), info, count);
+  }
+
+  public synchronized static int acc_find_for_outgoing(pj_str_t url) {
+    return pjsuaJNI.acc_find_for_outgoing(pj_str_t.getCPtr(url), url);
+  }
+
+  public synchronized static int acc_find_for_incoming(SWIGTYPE_p_pjsip_rx_data rdata) {
+    return pjsuaJNI.acc_find_for_incoming(SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata));
+  }
+
+  public synchronized static int acc_create_request(int acc_id, SWIGTYPE_p_pjsip_method method, pj_str_t target, SWIGTYPE_p_p_pjsip_tx_data p_tdata) {
+    return pjsuaJNI.acc_create_request(acc_id, SWIGTYPE_p_pjsip_method.getCPtr(method), pj_str_t.getCPtr(target), target, SWIGTYPE_p_p_pjsip_tx_data.getCPtr(p_tdata));
+  }
+
+  public synchronized static int acc_create_uac_contact(pj_pool_t pool, pj_str_t contact, int acc_id, pj_str_t uri) {
+    return pjsuaJNI.acc_create_uac_contact(pj_pool_t.getCPtr(pool), pool, pj_str_t.getCPtr(contact), contact, acc_id, pj_str_t.getCPtr(uri), uri);
+  }
+
+  public synchronized static int acc_create_uas_contact(pj_pool_t pool, pj_str_t contact, int acc_id, SWIGTYPE_p_pjsip_rx_data rdata) {
+    return pjsuaJNI.acc_create_uas_contact(pj_pool_t.getCPtr(pool), pool, pj_str_t.getCPtr(contact), contact, acc_id, SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata));
+  }
+
+  public synchronized static int acc_set_transport(int acc_id, int tp_id) {
+    return pjsuaJNI.acc_set_transport(acc_id, tp_id);
+  }
+
+  public synchronized static void call_setting_default(pjsua_call_setting opt) {
+    pjsuaJNI.call_setting_default(pjsua_call_setting.getCPtr(opt), opt);
+  }
+
+  public synchronized static void call_vid_strm_op_param_default(pjsua_call_vid_strm_op_param param) {
+    pjsuaJNI.call_vid_strm_op_param_default(pjsua_call_vid_strm_op_param.getCPtr(param), param);
+  }
+
+  public synchronized static long call_get_max_count() {
+    return pjsuaJNI.call_get_max_count();
+  }
+
+  public synchronized static long call_get_count() {
+    return pjsuaJNI.call_get_count();
+  }
+
+  public synchronized static int enum_calls(int[] ids, long[] count) {
+    return pjsuaJNI.enum_calls(ids, count);
+  }
+
+  public synchronized static int call_make_call(int acc_id, pj_str_t dst_uri, pjsua_call_setting opt, byte[] user_data, pjsua_msg_data msg_data, int[] p_call_id) {
+    return pjsuaJNI.call_make_call(acc_id, pj_str_t.getCPtr(dst_uri), dst_uri, pjsua_call_setting.getCPtr(opt), opt, user_data, pjsua_msg_data.getCPtr(msg_data), msg_data, p_call_id);
+  }
+
+  public synchronized static int call_is_active(int call_id) {
+    return pjsuaJNI.call_is_active(call_id);
+  }
+
+  public synchronized static int call_has_media(int call_id) {
+    return pjsuaJNI.call_has_media(call_id);
+  }
+
+  public synchronized static int call_get_conf_port(int call_id) {
+    return pjsuaJNI.call_get_conf_port(call_id);
+  }
+
+  public synchronized static int call_get_info(int call_id, pjsua_call_info info) {
+    return pjsuaJNI.call_get_info(call_id, pjsua_call_info.getCPtr(info), info);
+  }
+
+  public synchronized static SWIGTYPE_p_pjsip_dialog_cap_status call_remote_has_cap(int call_id, int htype, pj_str_t hname, pj_str_t token) {
+    return new SWIGTYPE_p_pjsip_dialog_cap_status(pjsuaJNI.call_remote_has_cap(call_id, htype, pj_str_t.getCPtr(hname), hname, pj_str_t.getCPtr(token), token), true);
+  }
+
+  public synchronized static int call_set_user_data(int call_id, byte[] user_data) {
+    return pjsuaJNI.call_set_user_data(call_id, user_data);
+  }
+
+  public synchronized static byte[] call_get_user_data(int call_id) {
+	return pjsuaJNI.call_get_user_data(call_id);
+}
+
+  public synchronized static int call_get_rem_nat_type(int call_id, int[] p_type) {
+    return pjsuaJNI.call_get_rem_nat_type(call_id, p_type);
+  }
+
+  public synchronized static int call_answer(int call_id, long code, pj_str_t reason, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_answer(call_id, code, pj_str_t.getCPtr(reason), reason, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_answer2(int call_id, pjsua_call_setting opt, long code, pj_str_t reason, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_answer2(call_id, pjsua_call_setting.getCPtr(opt), opt, code, pj_str_t.getCPtr(reason), reason, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_hangup(int call_id, long code, pj_str_t reason, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_hangup(call_id, code, pj_str_t.getCPtr(reason), reason, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_process_redirect(int call_id, pjsip_redirect_op cmd) {
+    return pjsuaJNI.call_process_redirect(call_id, cmd.swigValue());
+  }
+
+  public synchronized static int call_set_hold(int call_id, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_set_hold(call_id, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_set_hold2(int call_id, long options, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_set_hold2(call_id, options, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_reinvite(int call_id, long options, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_reinvite(call_id, options, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_reinvite2(int call_id, pjsua_call_setting opt, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_reinvite2(call_id, pjsua_call_setting.getCPtr(opt), opt, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_update(int call_id, long options, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_update(call_id, options, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_update2(int call_id, pjsua_call_setting opt, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_update2(call_id, pjsua_call_setting.getCPtr(opt), opt, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_xfer(int call_id, pj_str_t dest, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_xfer(call_id, pj_str_t.getCPtr(dest), dest, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_xfer_replaces(int call_id, int dest_call_id, long options, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_xfer_replaces(call_id, dest_call_id, options, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_dial_dtmf(int call_id, pj_str_t digits) {
+    return pjsuaJNI.call_dial_dtmf(call_id, pj_str_t.getCPtr(digits), digits);
+  }
+
+  public synchronized static int call_send_im(int call_id, pj_str_t mime_type, pj_str_t content, pjsua_msg_data msg_data, byte[] user_data) {
+    return pjsuaJNI.call_send_im(call_id, pj_str_t.getCPtr(mime_type), mime_type, pj_str_t.getCPtr(content), content, pjsua_msg_data.getCPtr(msg_data), msg_data, user_data);
+  }
+
+  public synchronized static int call_send_typing_ind(int call_id, int is_typing, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_send_typing_ind(call_id, is_typing, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_send_request(int call_id, pj_str_t method, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_send_request(call_id, pj_str_t.getCPtr(method), method, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static void call_hangup_all() {
+    pjsuaJNI.call_hangup_all();
+  }
+
+  public synchronized static int call_dump(int call_id, int with_media, String buffer, long maxlen, String indent) {
+    return pjsuaJNI.call_dump__SWIG_0(call_id, with_media, buffer, maxlen, indent);
+  }
+
+  public synchronized static int call_get_vid_stream_idx(int call_id) {
+    return pjsuaJNI.call_get_vid_stream_idx(call_id);
+  }
+
+  public synchronized static int call_vid_stream_is_running(int call_id, int med_idx, pjmedia_dir dir) {
+    return pjsuaJNI.call_vid_stream_is_running(call_id, med_idx, dir.swigValue());
+  }
+
+  public synchronized static int call_set_vid_strm(int call_id, pjsua_call_vid_strm_op op, pjsua_call_vid_strm_op_param param) {
+    return pjsuaJNI.call_set_vid_strm(call_id, op.swigValue(), pjsua_call_vid_strm_op_param.getCPtr(param), param);
+  }
+
+  public synchronized static int call_get_stream_info(int call_id, long med_idx, pjsua_stream_info psi) {
+    return pjsuaJNI.call_get_stream_info(call_id, med_idx, pjsua_stream_info.getCPtr(psi), psi);
+  }
+
+  public synchronized static int call_get_stream_stat(int call_id, long med_idx, pjsua_stream_stat stat) {
+    return pjsuaJNI.call_get_stream_stat(call_id, med_idx, pjsua_stream_stat.getCPtr(stat), stat);
+  }
+
+  public synchronized static int call_get_med_transport_info(int call_id, long med_idx, SWIGTYPE_p_pjmedia_transport_info t) {
+    return pjsuaJNI.call_get_med_transport_info(call_id, med_idx, SWIGTYPE_p_pjmedia_transport_info.getCPtr(t));
+  }
+
+  public synchronized static void buddy_config_default(pjsua_buddy_config cfg) {
+    pjsuaJNI.buddy_config_default(pjsua_buddy_config.getCPtr(cfg), cfg);
+  }
+
+  public synchronized static long get_buddy_count() {
+    return pjsuaJNI.get_buddy_count();
+  }
+
+  public synchronized static int buddy_is_valid(int buddy_id) {
+    return pjsuaJNI.buddy_is_valid(buddy_id);
+  }
+
+  public synchronized static int enum_buddies(int[] ids, long[] count) {
+    return pjsuaJNI.enum_buddies(ids, count);
+  }
+
+  public synchronized static int buddy_find(pj_str_t uri) {
+    return pjsuaJNI.buddy_find(pj_str_t.getCPtr(uri), uri);
+  }
+
+  public synchronized static int buddy_get_info(int buddy_id, pjsua_buddy_info info) {
+    return pjsuaJNI.buddy_get_info(buddy_id, pjsua_buddy_info.getCPtr(info), info);
+  }
+
+  public synchronized static int buddy_set_user_data(int buddy_id, byte[] user_data) {
+    return pjsuaJNI.buddy_set_user_data(buddy_id, user_data);
+  }
+
+  public synchronized static byte[] buddy_get_user_data(int buddy_id) {
+	return pjsuaJNI.buddy_get_user_data(buddy_id);
+}
+
+  public synchronized static int buddy_add(pjsua_buddy_config buddy_cfg, int[] p_buddy_id) {
+    return pjsuaJNI.buddy_add(pjsua_buddy_config.getCPtr(buddy_cfg), buddy_cfg, p_buddy_id);
+  }
+
+  public synchronized static int buddy_del(int buddy_id) {
+    return pjsuaJNI.buddy_del(buddy_id);
+  }
+
+  public synchronized static int buddy_subscribe_pres(int buddy_id, int subscribe) {
+    return pjsuaJNI.buddy_subscribe_pres(buddy_id, subscribe);
+  }
+
+  public synchronized static int buddy_update_pres(int buddy_id) {
+    return pjsuaJNI.buddy_update_pres(buddy_id);
+  }
+
+  public synchronized static int pres_notify(int acc_id, SWIGTYPE_p_pjsua_srv_pres srv_pres, SWIGTYPE_p_pjsip_evsub_state state, pj_str_t state_str, pj_str_t reason, int with_body, pjsua_msg_data msg_data) {
+    return pjsuaJNI.pres_notify(acc_id, SWIGTYPE_p_pjsua_srv_pres.getCPtr(srv_pres), SWIGTYPE_p_pjsip_evsub_state.getCPtr(state), pj_str_t.getCPtr(state_str), state_str, pj_str_t.getCPtr(reason), reason, with_body, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static void pres_dump(int verbose) {
+    pjsuaJNI.pres_dump(verbose);
+  }
+
+  public static SWIGTYPE_p_pjsip_method getPjsip_message_method() {
+    return new SWIGTYPE_p_pjsip_method(pjsuaJNI.pjsip_message_method_get(), true);
+  }
+
+  public static SWIGTYPE_p_pjsip_method getPjsip_info_method() {
+    return new SWIGTYPE_p_pjsip_method(pjsuaJNI.pjsip_info_method_get(), true);
+  }
+
+  public synchronized static int im_send(int acc_id, pj_str_t to, pj_str_t mime_type, pj_str_t content, pjsua_msg_data msg_data, byte[] user_data) {
+    return pjsuaJNI.im_send(acc_id, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(mime_type), mime_type, pj_str_t.getCPtr(content), content, pjsua_msg_data.getCPtr(msg_data), msg_data, user_data);
+  }
+
+  public synchronized static int im_typing(int acc_id, pj_str_t to, int is_typing, pjsua_msg_data msg_data) {
+    return pjsuaJNI.im_typing(acc_id, pj_str_t.getCPtr(to), to, is_typing, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static void media_config_default(pjsua_media_config cfg) {
+    pjsuaJNI.media_config_default(pjsua_media_config.getCPtr(cfg), cfg);
+  }
+
+  public synchronized static long conf_get_max_ports() {
+    return pjsuaJNI.conf_get_max_ports();
+  }
+
+  public synchronized static long conf_get_active_ports() {
+    return pjsuaJNI.conf_get_active_ports();
+  }
+
+  public synchronized static int enum_conf_ports(int[] id, long[] count) {
+    return pjsuaJNI.enum_conf_ports(id, count);
+  }
+
+  public synchronized static int conf_get_port_info(int port_id, pjsua_conf_port_info info) {
+    return pjsuaJNI.conf_get_port_info(port_id, pjsua_conf_port_info.getCPtr(info), info);
+  }
+
+  public synchronized static int conf_add_port(pj_pool_t pool, pjmedia_port port, int[] p_id) {
+    return pjsuaJNI.conf_add_port(pj_pool_t.getCPtr(pool), pool, pjmedia_port.getCPtr(port), port, p_id);
+  }
+
+  public synchronized static int conf_remove_port(int port_id) {
+    return pjsuaJNI.conf_remove_port(port_id);
+  }
+
+  public synchronized static int conf_connect(int source, int sink) {
+    return pjsuaJNI.conf_connect(source, sink);
+  }
+
+  public synchronized static int conf_disconnect(int source, int sink) {
+    return pjsuaJNI.conf_disconnect(source, sink);
+  }
+
+  public synchronized static int conf_adjust_tx_level(int slot, float level) {
+    return pjsuaJNI.conf_adjust_tx_level(slot, level);
+  }
+
+  public synchronized static int conf_adjust_rx_level(int slot, float level) {
+    return pjsuaJNI.conf_adjust_rx_level(slot, level);
+  }
+
+  public synchronized static int conf_get_signal_level(int slot, long[] tx_level, long[] rx_level) {
+    return pjsuaJNI.conf_get_signal_level(slot, tx_level, rx_level);
+  }
+
+  public synchronized static int player_create(pj_str_t filename, long options, int[] p_id) {
+    return pjsuaJNI.player_create(pj_str_t.getCPtr(filename), filename, options, p_id);
+  }
+
+  public synchronized static int playlist_create(pj_str_t[] file_names, long file_count, pj_str_t label, long options, int[] p_id) {
+    return pjsuaJNI.playlist_create(pj_str_t.cArrayUnwrap(file_names), file_count, pj_str_t.getCPtr(label), label, options, p_id);
+  }
+
+  public synchronized static int player_get_conf_port(int id) {
+    return pjsuaJNI.player_get_conf_port(id);
+  }
+
+  public synchronized static int player_get_port(int id, SWIGTYPE_p_p_pjmedia_port p_port) {
+    return pjsuaJNI.player_get_port(id, SWIGTYPE_p_p_pjmedia_port.getCPtr(p_port));
+  }
+
+  public synchronized static int player_get_info(int id, SWIGTYPE_p_pjmedia_wav_player_info info) {
+    return pjsuaJNI.player_get_info(id, SWIGTYPE_p_pjmedia_wav_player_info.getCPtr(info));
+  }
+
+  public synchronized static int player_get_pos(int id) {
+    return pjsuaJNI.player_get_pos(id);
+  }
+
+  public synchronized static int player_set_pos(int id, long samples) {
+    return pjsuaJNI.player_set_pos(id, samples);
+  }
+
+  public synchronized static int player_destroy(int id) {
+    return pjsuaJNI.player_destroy(id);
+  }
+
+  public synchronized static int recorder_create(pj_str_t filename, long enc_type, byte[] enc_param, int max_size, long options, int[] p_id) {
+    return pjsuaJNI.recorder_create(pj_str_t.getCPtr(filename), filename, enc_type, enc_param, max_size, options, p_id);
+  }
+
+  public synchronized static int recorder_get_conf_port(int id) {
+    return pjsuaJNI.recorder_get_conf_port(id);
+  }
+
+  public synchronized static int recorder_get_port(int id, SWIGTYPE_p_p_pjmedia_port p_port) {
+    return pjsuaJNI.recorder_get_port(id, SWIGTYPE_p_p_pjmedia_port.getCPtr(p_port));
+  }
+
+  public synchronized static int recorder_destroy(int id) {
+    return pjsuaJNI.recorder_destroy(id);
+  }
+
+  public synchronized static int enum_aud_devs(SWIGTYPE_p_pjmedia_aud_dev_info info, long[] count) {
+    return pjsuaJNI.enum_aud_devs(SWIGTYPE_p_pjmedia_aud_dev_info.getCPtr(info), count);
+  }
+
+  public synchronized static int enum_snd_devs(pjmedia_snd_dev_info info, long[] count) {
+    return pjsuaJNI.enum_snd_devs(pjmedia_snd_dev_info.getCPtr(info), info, count);
+  }
+
+  public synchronized static int get_snd_dev(int[] capture_dev, int[] playback_dev) {
+    return pjsuaJNI.get_snd_dev(capture_dev, playback_dev);
+  }
+
+  public synchronized static int set_snd_dev(int capture_dev, int playback_dev) {
+    return pjsuaJNI.set_snd_dev(capture_dev, playback_dev);
+  }
+
+  public synchronized static int set_null_snd_dev() {
+    return pjsuaJNI.set_null_snd_dev();
+  }
+
+  public synchronized static pjmedia_port set_no_snd_dev() {
+    long cPtr = pjsuaJNI.set_no_snd_dev();
+    return (cPtr == 0) ? null : new pjmedia_port(cPtr, false);
+  }
+
+  public synchronized static int set_ec(long tail_ms, long options) {
+    return pjsuaJNI.set_ec(tail_ms, options);
+  }
+
+  public synchronized static int get_ec_tail(SWIGTYPE_p_unsigned_int p_tail_ms) {
+    return pjsuaJNI.get_ec_tail(SWIGTYPE_p_unsigned_int.getCPtr(p_tail_ms));
+  }
+
+  public synchronized static int snd_is_active() {
+    return pjsuaJNI.snd_is_active();
+  }
+
+  public synchronized static int snd_set_setting(SWIGTYPE_p_pjmedia_aud_dev_cap cap, byte[] pval, int keep) {
+    return pjsuaJNI.snd_set_setting(SWIGTYPE_p_pjmedia_aud_dev_cap.getCPtr(cap), pval, keep);
+  }
+
+  public synchronized static int snd_get_setting(SWIGTYPE_p_pjmedia_aud_dev_cap cap, byte[] pval) {
+    return pjsuaJNI.snd_get_setting(SWIGTYPE_p_pjmedia_aud_dev_cap.getCPtr(cap), pval);
+  }
+
+  public synchronized static int enum_codecs(pjsua_codec_info id, long[] count) {
+    return pjsuaJNI.enum_codecs(pjsua_codec_info.getCPtr(id), id, count);
+  }
+
+  public synchronized static int codec_set_priority(pj_str_t codec_id, short priority) {
+    return pjsuaJNI.codec_set_priority(pj_str_t.getCPtr(codec_id), codec_id, priority);
+  }
+
+  public synchronized static int codec_get_param(pj_str_t codec_id, SWIGTYPE_p_pjmedia_codec_param param) {
+    return pjsuaJNI.codec_get_param(pj_str_t.getCPtr(codec_id), codec_id, SWIGTYPE_p_pjmedia_codec_param.getCPtr(param));
+  }
+
+  public synchronized static int codec_set_param(pj_str_t codec_id, SWIGTYPE_p_pjmedia_codec_param param) {
+    return pjsuaJNI.codec_set_param(pj_str_t.getCPtr(codec_id), codec_id, SWIGTYPE_p_pjmedia_codec_param.getCPtr(param));
+  }
+
+  public synchronized static long vid_dev_count() {
+    return pjsuaJNI.vid_dev_count();
+  }
+
+  public synchronized static int vid_dev_get_info(SWIGTYPE_p_pjmedia_vid_dev_index id, SWIGTYPE_p_pjmedia_vid_dev_info vdi) {
+    return pjsuaJNI.vid_dev_get_info(SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(id), SWIGTYPE_p_pjmedia_vid_dev_info.getCPtr(vdi));
+  }
+
+  public synchronized static int vid_enum_devs(SWIGTYPE_p_pjmedia_vid_dev_info info, long[] count) {
+    return pjsuaJNI.vid_enum_devs(SWIGTYPE_p_pjmedia_vid_dev_info.getCPtr(info), count);
+  }
+
+  public synchronized static void vid_preview_param_default(pjsua_vid_preview_param p) {
+    pjsuaJNI.vid_preview_param_default(pjsua_vid_preview_param.getCPtr(p), p);
+  }
+
+  public synchronized static int vid_preview_has_native(SWIGTYPE_p_pjmedia_vid_dev_index id) {
+    return pjsuaJNI.vid_preview_has_native(SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(id));
+  }
+
+  public synchronized static int vid_preview_start(SWIGTYPE_p_pjmedia_vid_dev_index id, pjsua_vid_preview_param p) {
+    return pjsuaJNI.vid_preview_start(SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(id), pjsua_vid_preview_param.getCPtr(p), p);
+  }
+
+  public synchronized static int vid_preview_get_win(SWIGTYPE_p_pjmedia_vid_dev_index id) {
+    return pjsuaJNI.vid_preview_get_win(SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(id));
+  }
+
+  public synchronized static int vid_preview_stop(SWIGTYPE_p_pjmedia_vid_dev_index id) {
+    return pjsuaJNI.vid_preview_stop(SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(id));
+  }
+
+  public synchronized static int vid_enum_wins(int[] wids, long[] count) {
+    return pjsuaJNI.vid_enum_wins(wids, count);
+  }
+
+  public synchronized static int vid_win_get_info(int wid, pjsua_vid_win_info wi) {
+    return pjsuaJNI.vid_win_get_info(wid, pjsua_vid_win_info.getCPtr(wi), wi);
+  }
+
+  public synchronized static int vid_win_set_show(int wid, int show) {
+    return pjsuaJNI.vid_win_set_show(wid, show);
+  }
+
+  public synchronized static int vid_win_set_pos(int wid, SWIGTYPE_p_pjmedia_coord pos) {
+    return pjsuaJNI.vid_win_set_pos(wid, SWIGTYPE_p_pjmedia_coord.getCPtr(pos));
+  }
+
+  public synchronized static int vid_win_set_size(int wid, SWIGTYPE_p_pjmedia_rect_size size) {
+    return pjsuaJNI.vid_win_set_size(wid, SWIGTYPE_p_pjmedia_rect_size.getCPtr(size));
+  }
+
+  public synchronized static int vid_win_rotate(int wid, int angle) {
+    return pjsuaJNI.vid_win_rotate(wid, angle);
+  }
+
+  public synchronized static int vid_enum_codecs(pjsua_codec_info id, long[] count) {
+    return pjsuaJNI.vid_enum_codecs(pjsua_codec_info.getCPtr(id), id, count);
+  }
+
+  public synchronized static int vid_codec_set_priority(pj_str_t codec_id, short priority) {
+    return pjsuaJNI.vid_codec_set_priority(pj_str_t.getCPtr(codec_id), codec_id, priority);
+  }
+
+  public synchronized static int vid_codec_get_param(pj_str_t codec_id, SWIGTYPE_p_pjmedia_vid_codec_param param) {
+    return pjsuaJNI.vid_codec_get_param(pj_str_t.getCPtr(codec_id), codec_id, SWIGTYPE_p_pjmedia_vid_codec_param.getCPtr(param));
+  }
+
+  public synchronized static int vid_codec_set_param(pj_str_t codec_id, SWIGTYPE_p_pjmedia_vid_codec_param param) {
+    return pjsuaJNI.vid_codec_set_param(pj_str_t.getCPtr(codec_id), codec_id, SWIGTYPE_p_pjmedia_vid_codec_param.getCPtr(param));
+  }
+
+  public static int send_dtmf_info(int current_call, pj_str_t digits) {
+    return pjsuaJNI.send_dtmf_info(current_call, pj_str_t.getCPtr(digits), digits);
+  }
+
+  public static pj_str_t call_dump(int call_id, int with_media, String indent) {
+    return new pj_str_t(pjsuaJNI.call_dump__SWIG_1(call_id, with_media, indent), true);
+  }
+
+  public static pj_str_t call_secure_media_info(int call_id) {
+    return new pj_str_t(pjsuaJNI.call_secure_media_info(call_id), true);
+  }
+
+  public static int call_secure_sig_level(int call_id) {
+    return pjsuaJNI.call_secure_sig_level(call_id);
+  }
+
+  public static pj_str_t get_error_message(int status) {
+    return new pj_str_t(pjsuaJNI.get_error_message(status), true);
+  }
+
+  public static int get_event_status_code(pjsip_event e) {
+    return pjsuaJNI.get_event_status_code(pjsip_event.getCPtr(e), e);
+  }
+
+  public static int get_event_reason_code(pjsip_event e) {
+    return pjsuaJNI.get_event_reason_code(pjsip_event.getCPtr(e), e);
+  }
+
+  public static void csipsimple_config_default(csipsimple_config css_cfg) {
+    pjsuaJNI.csipsimple_config_default(csipsimple_config.getCPtr(css_cfg), css_cfg);
+  }
+
+  public static void csipsimple_acc_config_default(csipsimple_acc_config css_acc_cfg) {
+    pjsuaJNI.csipsimple_acc_config_default(csipsimple_acc_config.getCPtr(css_acc_cfg), css_acc_cfg);
+  }
+
+  public static int csipsimple_init(pjsua_config ua_cfg, pjsua_logging_config log_cfg, pjsua_media_config media_cfg, csipsimple_config css_cfg, Object context) {
+    return pjsuaJNI.csipsimple_init(pjsua_config.getCPtr(ua_cfg), ua_cfg, pjsua_logging_config.getCPtr(log_cfg), log_cfg, pjsua_media_config.getCPtr(media_cfg), media_cfg, csipsimple_config.getCPtr(css_cfg), css_cfg, context);
+  }
+
+  public static int csipsimple_destroy(long flags) {
+    return pjsuaJNI.csipsimple_destroy(flags);
+  }
+
+  public static int csipsimple_set_acc_user_data(int acc_id, csipsimple_acc_config css_acc_cfg) {
+    return pjsuaJNI.csipsimple_set_acc_user_data(acc_id, csipsimple_acc_config.getCPtr(css_acc_cfg), css_acc_cfg);
+  }
+
+  public static int csipsimple_init_acc_msg_data(pj_pool_t pool, int acc_id, pjsua_msg_data msg_data) {
+    return pjsuaJNI.csipsimple_init_acc_msg_data(pj_pool_t.getCPtr(pool), pool, acc_id, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public static int csipsimple_msg_data_add_string_hdr(pj_pool_t pool, pjsua_msg_data msg_data, pj_str_t hdr_name, pj_str_t hdr_value) {
+    return pjsuaJNI.csipsimple_msg_data_add_string_hdr(pj_pool_t.getCPtr(pool), pool, pjsua_msg_data.getCPtr(msg_data), msg_data, pj_str_t.getCPtr(hdr_name), hdr_name, pj_str_t.getCPtr(hdr_value), hdr_value);
+  }
+
+  public static int pj_timer_fire(int entry_id) {
+    return pjsuaJNI.pj_timer_fire(entry_id);
+  }
+
+  public static int update_transport(pj_str_t new_ip_addr) {
+    return pjsuaJNI.update_transport(pj_str_t.getCPtr(new_ip_addr), new_ip_addr);
+  }
+
+  public static int vid_set_android_renderer(int call_id, Object window) {
+    return pjsuaJNI.vid_set_android_renderer(call_id, window);
+  }
+
+  public static int vid_set_android_capturer(Object window) {
+    return pjsuaJNI.vid_set_android_capturer(window);
+  }
+
+  public static int set_turn_credentials(pj_str_t username, pj_str_t password, pj_str_t realm, SWIGTYPE_p_pj_stun_auth_cred turn_auth_cred) {
+    return pjsuaJNI.set_turn_credentials(pj_str_t.getCPtr(username), username, pj_str_t.getCPtr(password), password, pj_str_t.getCPtr(realm), realm, SWIGTYPE_p_pj_stun_auth_cred.getCPtr(turn_auth_cred));
+  }
+
+  public static pj_str_t get_rx_data_header(pj_str_t name, SWIGTYPE_p_pjsip_rx_data data) {
+    return new pj_str_t(pjsuaJNI.get_rx_data_header(pj_str_t.getCPtr(name), name, SWIGTYPE_p_pjsip_rx_data.getCPtr(data)), true);
+  }
+
+  public static void css_on_call_state(int call_id, pjsip_event e) {
+    pjsuaJNI.css_on_call_state(call_id, pjsip_event.getCPtr(e), e);
+  }
+
+  public static void css_on_call_media_state(int call_id) {
+    pjsuaJNI.css_on_call_media_state(call_id);
+  }
+
+  public static void jzrtp_SASVerified(int call_id) {
+    pjsuaJNI.jzrtp_SASVerified(call_id);
+  }
+
+  public static void jzrtp_SASRevoked(int call_id) {
+    pjsuaJNI.jzrtp_SASRevoked(call_id);
+  }
+
+  public static zrtp_state_info jzrtp_getInfoFromCall(int call_id) {
+    return new zrtp_state_info(pjsuaJNI.jzrtp_getInfoFromCall(call_id), true);
+  }
+
+  public static int codecs_get_nbr() {
+    return pjsuaJNI.codecs_get_nbr();
+  }
+
+  public static pj_str_t codecs_get_id(int codec_id) {
+    return new pj_str_t(pjsuaJNI.codecs_get_id(codec_id), true);
+  }
+
+  public static int codecs_vid_get_nbr() {
+    return pjsuaJNI.codecs_vid_get_nbr();
+  }
+
+  public static pj_str_t codecs_vid_get_id(int codec_id) {
+    return new pj_str_t(pjsuaJNI.codecs_vid_get_id(codec_id), true);
+  }
+
+  public static int codec_set_frames_per_packet(pj_str_t codec_id, int frames_per_packet) {
+    return pjsuaJNI.codec_set_frames_per_packet(pj_str_t.getCPtr(codec_id), codec_id, frames_per_packet);
+  }
+
+  public static int codec_h264_set_profile(long profile_id, long level_id, long width, long height, long fps, long avg_kbps, long max_kbps) {
+    return pjsuaJNI.codec_h264_set_profile(profile_id, level_id, width, height, fps, avg_kbps, max_kbps);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsuaConstants.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsuaConstants.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsuaConstants.java	(working copy)
@@ -0,0 +1,50 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public interface pjsuaConstants {
+  public final static pjsua_callback WRAPPER_CALLBACK_STRUCT = new pjsua_callback(pjsuaJNI.WRAPPER_CALLBACK_STRUCT_get(), false);
+  public final static int PJ_SUCCESS = pjsuaJNI.PJ_SUCCESS_get();
+  public final static int PJ_TRUE = pjsuaJNI.PJ_TRUE_get();
+  public final static int PJ_FALSE = pjsuaJNI.PJ_FALSE_get();
+  public final static int PJMEDIA_TONEGEN_LOOP = pjsuaJNI.PJMEDIA_TONEGEN_LOOP_get();
+  public final static int PJMEDIA_TONEGEN_NO_LOCK = pjsuaJNI.PJMEDIA_TONEGEN_NO_LOCK_get();
+
+  public final static int DISABLED_FOR_TICKET_1185 = pjsuaJNI.DISABLED_FOR_TICKET_1185_get();
+  public final static int PJSUA_ACC_MAX_PROXIES = pjsuaJNI.PJSUA_ACC_MAX_PROXIES_get();
+  public final static int PJSUA_DEFAULT_SRTP_SECURE_SIGNALING = pjsuaJNI.PJSUA_DEFAULT_SRTP_SECURE_SIGNALING_get();
+  public final static int PJSUA_ADD_ICE_TAGS = pjsuaJNI.PJSUA_ADD_ICE_TAGS_get();
+  public final static int PJSUA_ACQUIRE_CALL_TIMEOUT = pjsuaJNI.PJSUA_ACQUIRE_CALL_TIMEOUT_get();
+  public final static int PJSUA_HAS_VIDEO = pjsuaJNI.PJSUA_HAS_VIDEO_get();
+  public final static int PJSUA_VID_REQ_KEYFRAME_INTERVAL = pjsuaJNI.PJSUA_VID_REQ_KEYFRAME_INTERVAL_get();
+  public final static int PJSUA_MAX_ACC = pjsuaJNI.PJSUA_MAX_ACC_get();
+  public final static int PJSUA_REG_INTERVAL = pjsuaJNI.PJSUA_REG_INTERVAL_get();
+  public final static int PJSUA_UNREG_TIMEOUT = pjsuaJNI.PJSUA_UNREG_TIMEOUT_get();
+  public final static int PJSUA_DEFAULT_ACC_PRIORITY = pjsuaJNI.PJSUA_DEFAULT_ACC_PRIORITY_get();
+  public final static int PJSUA_UNPUBLISH_MAX_WAIT_TIME_MSEC = pjsuaJNI.PJSUA_UNPUBLISH_MAX_WAIT_TIME_MSEC_get();
+  public final static int PJSUA_REG_RETRY_INTERVAL = pjsuaJNI.PJSUA_REG_RETRY_INTERVAL_get();
+  public final static int PJSUA_REG_USE_OUTBOUND_PROXY = pjsuaJNI.PJSUA_REG_USE_OUTBOUND_PROXY_get();
+  public final static int PJSUA_REG_USE_ACC_PROXY = pjsuaJNI.PJSUA_REG_USE_ACC_PROXY_get();
+  public final static int PJSUA_MAX_CALLS = pjsuaJNI.PJSUA_MAX_CALLS_get();
+  public final static int PJSUA_MAX_VID_WINS = pjsuaJNI.PJSUA_MAX_VID_WINS_get();
+  public final static int PJSUA_XFER_NO_REQUIRE_REPLACES = pjsuaJNI.PJSUA_XFER_NO_REQUIRE_REPLACES_get();
+  public final static int PJSUA_MAX_BUDDIES = pjsuaJNI.PJSUA_MAX_BUDDIES_get();
+  public final static int PJSUA_PRES_TIMER = pjsuaJNI.PJSUA_PRES_TIMER_get();
+  public final static int PJSUA_MEDIA_HAS_PJMEDIA = pjsuaJNI.PJSUA_MEDIA_HAS_PJMEDIA_get();
+  public final static int PJSUA_THIRD_PARTY_STREAM_HAS_GET_INFO = pjsuaJNI.PJSUA_THIRD_PARTY_STREAM_HAS_GET_INFO_get();
+  public final static int PJSUA_THIRD_PARTY_STREAM_HAS_GET_STAT = pjsuaJNI.PJSUA_THIRD_PARTY_STREAM_HAS_GET_STAT_get();
+  public final static int PJSUA_MAX_CONF_PORTS = pjsuaJNI.PJSUA_MAX_CONF_PORTS_get();
+  public final static int PJSUA_DEFAULT_CLOCK_RATE = pjsuaJNI.PJSUA_DEFAULT_CLOCK_RATE_get();
+  public final static int PJSUA_DEFAULT_AUDIO_FRAME_PTIME = pjsuaJNI.PJSUA_DEFAULT_AUDIO_FRAME_PTIME_get();
+  public final static int PJSUA_DEFAULT_CODEC_QUALITY = pjsuaJNI.PJSUA_DEFAULT_CODEC_QUALITY_get();
+  public final static int PJSUA_DEFAULT_ILBC_MODE = pjsuaJNI.PJSUA_DEFAULT_ILBC_MODE_get();
+  public final static int PJSUA_DEFAULT_EC_TAIL_LEN = pjsuaJNI.PJSUA_DEFAULT_EC_TAIL_LEN_get();
+  public final static int PJSUA_MAX_PLAYERS = pjsuaJNI.PJSUA_MAX_PLAYERS_get();
+  public final static int PJSUA_MAX_RECORDERS = pjsuaJNI.PJSUA_MAX_RECORDERS_get();
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsuaJNI.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsuaJNI.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsuaJNI.java	(working copy)
@@ -0,0 +1,1492 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsuaJNI {
+  public final static native long pj_str_copy(String jarg1);
+  public final static native long WRAPPER_CALLBACK_STRUCT_get();
+  public final static native void delete_Callback(long jarg1);
+  public final static native void Callback_on_call_state(long jarg1, Callback jarg1_, int jarg2, long jarg3, pjsip_event jarg3_);
+  public final static native void Callback_on_call_stateSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pjsip_event jarg3_);
+  public final static native void Callback_on_incoming_call(long jarg1, Callback jarg1_, int jarg2, int jarg3, long jarg4);
+  public final static native void Callback_on_incoming_callSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, int jarg3, long jarg4);
+  public final static native void Callback_on_call_tsx_state(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4, pjsip_event jarg4_);
+  public final static native void Callback_on_call_tsx_stateSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4, pjsip_event jarg4_);
+  public final static native void Callback_on_call_media_state(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_call_media_stateSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_call_sdp_created(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4, pj_pool_t jarg4_, long jarg5);
+  public final static native void Callback_on_call_sdp_createdSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4, pj_pool_t jarg4_, long jarg5);
+  public final static native void Callback_on_stream_created(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4, long jarg5);
+  public final static native void Callback_on_stream_createdSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4, long jarg5);
+  public final static native void Callback_on_stream_destroyed(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4);
+  public final static native void Callback_on_stream_destroyedSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4);
+  public final static native void Callback_on_dtmf_digit(long jarg1, Callback jarg1_, int jarg2, int jarg3);
+  public final static native void Callback_on_dtmf_digitSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, int jarg3);
+  public final static native void Callback_on_call_transfer_request(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4);
+  public final static native void Callback_on_call_transfer_requestSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4);
+  public final static native void Callback_on_call_transfer_status(long jarg1, Callback jarg1_, int jarg2, int jarg3, long jarg4, pj_str_t jarg4_, int jarg5, long jarg6);
+  public final static native void Callback_on_call_transfer_statusSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, int jarg3, long jarg4, pj_str_t jarg4_, int jarg5, long jarg6);
+  public final static native void Callback_on_call_replace_request(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4, long jarg5, pj_str_t jarg5_);
+  public final static native void Callback_on_call_replace_requestSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4, long jarg5, pj_str_t jarg5_);
+  public final static native void Callback_on_call_replaced(long jarg1, Callback jarg1_, int jarg2, int jarg3);
+  public final static native void Callback_on_call_replacedSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, int jarg3);
+  public final static native void Callback_on_reg_state(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_reg_stateSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_buddy_state(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_buddy_stateSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_pager(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, long jarg5, pj_str_t jarg5_, long jarg6, pj_str_t jarg6_, long jarg7, pj_str_t jarg7_);
+  public final static native void Callback_on_pagerSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, long jarg5, pj_str_t jarg5_, long jarg6, pj_str_t jarg6_, long jarg7, pj_str_t jarg7_);
+  public final static native void Callback_on_pager2(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, long jarg5, pj_str_t jarg5_, long jarg6, pj_str_t jarg6_, long jarg7, pj_str_t jarg7_, long jarg8);
+  public final static native void Callback_on_pager2SwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, long jarg5, pj_str_t jarg5_, long jarg6, pj_str_t jarg6_, long jarg7, pj_str_t jarg7_, long jarg8);
+  public final static native void Callback_on_pager_status(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, int jarg5, long jarg6, pj_str_t jarg6_);
+  public final static native void Callback_on_pager_statusSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, int jarg5, long jarg6, pj_str_t jarg6_);
+  public final static native void Callback_on_pager_status2(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, int jarg5, long jarg6, pj_str_t jarg6_, long jarg7, long jarg8);
+  public final static native void Callback_on_pager_status2SwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, int jarg5, long jarg6, pj_str_t jarg6_, long jarg7, long jarg8);
+  public final static native void Callback_on_typing(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, long jarg5, pj_str_t jarg5_, int jarg6);
+  public final static native void Callback_on_typingSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, long jarg5, pj_str_t jarg5_, int jarg6);
+  public final static native void Callback_on_nat_detect(long jarg1, Callback jarg1_, long jarg2, pj_stun_nat_detect_result jarg2_);
+  public final static native void Callback_on_nat_detectSwigExplicitCallback(long jarg1, Callback jarg1_, long jarg2, pj_stun_nat_detect_result jarg2_);
+  public final static native int Callback_on_call_redirected(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_);
+  public final static native int Callback_on_call_redirectedSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_);
+  public final static native void Callback_on_mwi_info(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_);
+  public final static native void Callback_on_mwi_infoSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_);
+  public final static native void Callback_on_call_media_transport_state(long jarg1, Callback jarg1_, int jarg2, long jarg3, pjsua_med_tp_state_info jarg3_);
+  public final static native void Callback_on_call_media_transport_stateSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pjsua_med_tp_state_info jarg3_);
+  public final static native int Callback_on_validate_audio_clock_rate(long jarg1, Callback jarg1_, int jarg2);
+  public final static native int Callback_on_validate_audio_clock_rateSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_setup_audio(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_setup_audioSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_teardown_audio(long jarg1, Callback jarg1_);
+  public final static native void Callback_on_teardown_audioSwigExplicitCallback(long jarg1, Callback jarg1_);
+  public final static native int Callback_on_set_micro_source(long jarg1, Callback jarg1_);
+  public final static native int Callback_on_set_micro_sourceSwigExplicitCallback(long jarg1, Callback jarg1_);
+  public final static native int Callback_timer_schedule(long jarg1, Callback jarg1_, int jarg2, int jarg3, int jarg4);
+  public final static native int Callback_timer_scheduleSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, int jarg3, int jarg4);
+  public final static native int Callback_timer_cancel(long jarg1, Callback jarg1_, int jarg2, int jarg3);
+  public final static native int Callback_timer_cancelSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, int jarg3);
+  public final static native long new_Callback();
+  public final static native void Callback_director_connect(Callback obj, long cptr, boolean mem_own, boolean weak_global);
+  public final static native void Callback_change_ownership(Callback obj, long cptr, boolean take_or_release);
+  public final static native void setCallbackObject(long jarg1, Callback jarg1_);
+  public final static native int PJ_SUCCESS_get();
+  public final static native int PJ_TRUE_get();
+  public final static native int PJ_FALSE_get();
+  public final static native void pj_str_t_ptr_set(long jarg1, pj_str_t jarg1_, String jarg2);
+  public final static native String pj_str_t_ptr_get(long jarg1, pj_str_t jarg1_);
+  public final static native void pj_str_t_slen_set(long jarg1, pj_str_t jarg1_, int jarg2);
+  public final static native int pj_str_t_slen_get(long jarg1, pj_str_t jarg1_);
+  public final static native long new_pj_str_t();
+  public final static native void delete_pj_str_t(long jarg1);
+  public final static native void pjmedia_port_info_name_set(long jarg1, pjmedia_port_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjmedia_port_info_name_get(long jarg1, pjmedia_port_info jarg1_);
+  public final static native void pjmedia_port_info_signature_set(long jarg1, pjmedia_port_info jarg1_, long jarg2);
+  public final static native long pjmedia_port_info_signature_get(long jarg1, pjmedia_port_info jarg1_);
+  public final static native void pjmedia_port_info_dir_set(long jarg1, pjmedia_port_info jarg1_, int jarg2);
+  public final static native int pjmedia_port_info_dir_get(long jarg1, pjmedia_port_info jarg1_);
+  public final static native void pjmedia_port_info_fmt_set(long jarg1, pjmedia_port_info jarg1_, long jarg2);
+  public final static native long pjmedia_port_info_fmt_get(long jarg1, pjmedia_port_info jarg1_);
+  public final static native long new_pjmedia_port_info();
+  public final static native void delete_pjmedia_port_info(long jarg1);
+  public final static native void pjmedia_port_info_set(long jarg1, pjmedia_port jarg1_, long jarg2, pjmedia_port_info jarg2_);
+  public final static native long pjmedia_port_info_get(long jarg1, pjmedia_port jarg1_);
+  public final static native void pjmedia_port_get_clock_src_set(long jarg1, pjmedia_port jarg1_, long jarg2);
+  public final static native long pjmedia_port_get_clock_src_get(long jarg1, pjmedia_port jarg1_);
+  public final static native void pjmedia_port_put_frame_set(long jarg1, pjmedia_port jarg1_, long jarg2);
+  public final static native long pjmedia_port_put_frame_get(long jarg1, pjmedia_port jarg1_);
+  public final static native void pjmedia_port_get_frame_set(long jarg1, pjmedia_port jarg1_, long jarg2);
+  public final static native long pjmedia_port_get_frame_get(long jarg1, pjmedia_port jarg1_);
+  public final static native void pjmedia_port_on_destroy_set(long jarg1, pjmedia_port jarg1_, long jarg2);
+  public final static native long pjmedia_port_on_destroy_get(long jarg1, pjmedia_port jarg1_);
+  public final static native int PJMEDIA_DIR_NONE_get();
+  public final static native int PJMEDIA_DIR_ENCODING_get();
+  public final static native int PJMEDIA_DIR_CAPTURE_get();
+  public final static native int PJMEDIA_DIR_DECODING_get();
+  public final static native int PJMEDIA_DIR_PLAYBACK_get();
+  public final static native int PJMEDIA_DIR_RENDER_get();
+  public final static native int PJMEDIA_DIR_ENCODING_DECODING_get();
+  public final static native int PJMEDIA_DIR_CAPTURE_PLAYBACK_get();
+  public final static native int PJMEDIA_DIR_CAPTURE_RENDER_get();
+  public final static native void pjsip_cred_info_realm_set(long jarg1, pjsip_cred_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_cred_info_realm_get(long jarg1, pjsip_cred_info jarg1_);
+  public final static native void pjsip_cred_info_scheme_set(long jarg1, pjsip_cred_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_cred_info_scheme_get(long jarg1, pjsip_cred_info jarg1_);
+  public final static native void pjsip_cred_info_username_set(long jarg1, pjsip_cred_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_cred_info_username_get(long jarg1, pjsip_cred_info jarg1_);
+  public final static native void pjsip_cred_info_data_type_set(long jarg1, pjsip_cred_info jarg1_, int jarg2);
+  public final static native int pjsip_cred_info_data_type_get(long jarg1, pjsip_cred_info jarg1_);
+  public final static native void pjsip_cred_info_data_set(long jarg1, pjsip_cred_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_cred_info_data_get(long jarg1, pjsip_cred_info jarg1_);
+  public final static native long new_pjsip_cred_info();
+  public final static native void delete_pjsip_cred_info(long jarg1);
+  public final static native int PJSIP_CRED_DATA_PLAIN_PASSWD_get();
+  public final static native int PJSIP_CRED_DATA_DIGEST_get();
+  public final static native int PJSIP_CRED_DATA_EXT_AKA_get();
+  public final static native int PJMEDIA_TONEGEN_LOOP_get();
+  public final static native int PJMEDIA_TONEGEN_NO_LOCK_get();
+  public final static native void pjsip_event_type_set(long jarg1, pjsip_event jarg1_, int jarg2);
+  public final static native int pjsip_event_type_get(long jarg1, pjsip_event jarg1_);
+  public final static native long new_pjsip_event();
+  public final static native void delete_pjsip_event(long jarg1);
+  public final static native void pjmedia_snd_dev_info_name_set(long jarg1, pjmedia_snd_dev_info jarg1_, String jarg2);
+  public final static native String pjmedia_snd_dev_info_name_get(long jarg1, pjmedia_snd_dev_info jarg1_);
+  public final static native void pjmedia_snd_dev_info_input_count_set(long jarg1, pjmedia_snd_dev_info jarg1_, long jarg2);
+  public final static native long pjmedia_snd_dev_info_input_count_get(long jarg1, pjmedia_snd_dev_info jarg1_);
+  public final static native void pjmedia_snd_dev_info_output_count_set(long jarg1, pjmedia_snd_dev_info jarg1_, long jarg2);
+  public final static native long pjmedia_snd_dev_info_output_count_get(long jarg1, pjmedia_snd_dev_info jarg1_);
+  public final static native void pjmedia_snd_dev_info_default_samples_per_sec_set(long jarg1, pjmedia_snd_dev_info jarg1_, long jarg2);
+  public final static native long pjmedia_snd_dev_info_default_samples_per_sec_get(long jarg1, pjmedia_snd_dev_info jarg1_);
+  public final static native long new_pjmedia_snd_dev_info();
+  public final static native void delete_pjmedia_snd_dev_info(long jarg1);
+  public final static native void pjmedia_tone_desc_freq1_set(long jarg1, pjmedia_tone_desc jarg1_, short jarg2);
+  public final static native short pjmedia_tone_desc_freq1_get(long jarg1, pjmedia_tone_desc jarg1_);
+  public final static native void pjmedia_tone_desc_freq2_set(long jarg1, pjmedia_tone_desc jarg1_, short jarg2);
+  public final static native short pjmedia_tone_desc_freq2_get(long jarg1, pjmedia_tone_desc jarg1_);
+  public final static native void pjmedia_tone_desc_on_msec_set(long jarg1, pjmedia_tone_desc jarg1_, short jarg2);
+  public final static native short pjmedia_tone_desc_on_msec_get(long jarg1, pjmedia_tone_desc jarg1_);
+  public final static native void pjmedia_tone_desc_off_msec_set(long jarg1, pjmedia_tone_desc jarg1_, short jarg2);
+  public final static native short pjmedia_tone_desc_off_msec_get(long jarg1, pjmedia_tone_desc jarg1_);
+  public final static native void pjmedia_tone_desc_volume_set(long jarg1, pjmedia_tone_desc jarg1_, short jarg2);
+  public final static native short pjmedia_tone_desc_volume_get(long jarg1, pjmedia_tone_desc jarg1_);
+  public final static native void pjmedia_tone_desc_flags_set(long jarg1, pjmedia_tone_desc jarg1_, short jarg2);
+  public final static native short pjmedia_tone_desc_flags_get(long jarg1, pjmedia_tone_desc jarg1_);
+  public final static native long new_pjmedia_tone_desc();
+  public final static native void delete_pjmedia_tone_desc(long jarg1);
+  public final static native void pjmedia_tone_digit_digit_set(long jarg1, pjmedia_tone_digit jarg1_, char jarg2);
+  public final static native char pjmedia_tone_digit_digit_get(long jarg1, pjmedia_tone_digit jarg1_);
+  public final static native void pjmedia_tone_digit_on_msec_set(long jarg1, pjmedia_tone_digit jarg1_, short jarg2);
+  public final static native short pjmedia_tone_digit_on_msec_get(long jarg1, pjmedia_tone_digit jarg1_);
+  public final static native void pjmedia_tone_digit_off_msec_set(long jarg1, pjmedia_tone_digit jarg1_, short jarg2);
+  public final static native short pjmedia_tone_digit_off_msec_get(long jarg1, pjmedia_tone_digit jarg1_);
+  public final static native void pjmedia_tone_digit_volume_set(long jarg1, pjmedia_tone_digit jarg1_, short jarg2);
+  public final static native short pjmedia_tone_digit_volume_get(long jarg1, pjmedia_tone_digit jarg1_);
+  public final static native long new_pjmedia_tone_digit();
+  public final static native void delete_pjmedia_tone_digit(long jarg1);
+  public final static native void pj_pool_t_obj_name_set(long jarg1, pj_pool_t jarg1_, String jarg2);
+  public final static native String pj_pool_t_obj_name_get(long jarg1, pj_pool_t jarg1_);
+  public final static native void pj_pool_t_factory_set(long jarg1, pj_pool_t jarg1_, long jarg2);
+  public final static native long pj_pool_t_factory_get(long jarg1, pj_pool_t jarg1_);
+  public final static native void pj_pool_t_factory_data_set(long jarg1, pj_pool_t jarg1_, byte[] jarg2);
+  public final static native byte[] pj_pool_t_factory_data_get(long jarg1, pj_pool_t jarg1_);
+  public final static native void pj_pool_t_capacity_set(long jarg1, pj_pool_t jarg1_, long jarg2);
+  public final static native long pj_pool_t_capacity_get(long jarg1, pj_pool_t jarg1_);
+  public final static native void pj_pool_t_increment_size_set(long jarg1, pj_pool_t jarg1_, long jarg2);
+  public final static native long pj_pool_t_increment_size_get(long jarg1, pj_pool_t jarg1_);
+  public final static native void pj_pool_t_block_list_set(long jarg1, pj_pool_t jarg1_, long jarg2);
+  public final static native long pj_pool_t_block_list_get(long jarg1, pj_pool_t jarg1_);
+  public final static native void pj_pool_t_callback_set(long jarg1, pj_pool_t jarg1_, long jarg2);
+  public final static native long pj_pool_t_callback_get(long jarg1, pj_pool_t jarg1_);
+  public final static native long new_pj_pool_t();
+  public final static native void delete_pj_pool_t(long jarg1);
+  public final static native int PJSIP_TRANSPORT_IPV6_get();
+  public final static native int PJSIP_TRANSPORT_UDP6_get();
+  public final static native int PJSIP_TRANSPORT_TCP6_get();
+  public final static native int PJSIP_TRANSPORT_TLS6_get();
+  public final static native int PJ_TURN_TP_UDP_get();
+  public final static native int PJ_TURN_TP_TCP_get();
+  public final static native int PJ_TURN_TP_TLS_get();
+  public final static native int PJSIP_SC_TRYING_get();
+  public final static native int PJSIP_SC_RINGING_get();
+  public final static native int PJSIP_SC_CALL_BEING_FORWARDED_get();
+  public final static native int PJSIP_SC_QUEUED_get();
+  public final static native int PJSIP_SC_PROGRESS_get();
+  public final static native int PJSIP_SC_OK_get();
+  public final static native int PJSIP_SC_ACCEPTED_get();
+  public final static native int PJSIP_SC_MULTIPLE_CHOICES_get();
+  public final static native int PJSIP_SC_MOVED_PERMANENTLY_get();
+  public final static native int PJSIP_SC_MOVED_TEMPORARILY_get();
+  public final static native int PJSIP_SC_USE_PROXY_get();
+  public final static native int PJSIP_SC_ALTERNATIVE_SERVICE_get();
+  public final static native int PJSIP_SC_BAD_REQUEST_get();
+  public final static native int PJSIP_SC_UNAUTHORIZED_get();
+  public final static native int PJSIP_SC_PAYMENT_REQUIRED_get();
+  public final static native int PJSIP_SC_FORBIDDEN_get();
+  public final static native int PJSIP_SC_NOT_FOUND_get();
+  public final static native int PJSIP_SC_METHOD_NOT_ALLOWED_get();
+  public final static native int PJSIP_SC_NOT_ACCEPTABLE_get();
+  public final static native int PJSIP_SC_PROXY_AUTHENTICATION_REQUIRED_get();
+  public final static native int PJSIP_SC_REQUEST_TIMEOUT_get();
+  public final static native int PJSIP_SC_GONE_get();
+  public final static native int PJSIP_SC_REQUEST_ENTITY_TOO_LARGE_get();
+  public final static native int PJSIP_SC_REQUEST_URI_TOO_LONG_get();
+  public final static native int PJSIP_SC_UNSUPPORTED_MEDIA_TYPE_get();
+  public final static native int PJSIP_SC_UNSUPPORTED_URI_SCHEME_get();
+  public final static native int PJSIP_SC_BAD_EXTENSION_get();
+  public final static native int PJSIP_SC_EXTENSION_REQUIRED_get();
+  public final static native int PJSIP_SC_SESSION_TIMER_TOO_SMALL_get();
+  public final static native int PJSIP_SC_INTERVAL_TOO_BRIEF_get();
+  public final static native int PJSIP_SC_TEMPORARILY_UNAVAILABLE_get();
+  public final static native int PJSIP_SC_CALL_TSX_DOES_NOT_EXIST_get();
+  public final static native int PJSIP_SC_LOOP_DETECTED_get();
+  public final static native int PJSIP_SC_TOO_MANY_HOPS_get();
+  public final static native int PJSIP_SC_ADDRESS_INCOMPLETE_get();
+  public final static native int PJSIP_AC_AMBIGUOUS_get();
+  public final static native int PJSIP_SC_BUSY_HERE_get();
+  public final static native int PJSIP_SC_REQUEST_TERMINATED_get();
+  public final static native int PJSIP_SC_NOT_ACCEPTABLE_HERE_get();
+  public final static native int PJSIP_SC_BAD_EVENT_get();
+  public final static native int PJSIP_SC_REQUEST_UPDATED_get();
+  public final static native int PJSIP_SC_REQUEST_PENDING_get();
+  public final static native int PJSIP_SC_UNDECIPHERABLE_get();
+  public final static native int PJSIP_SC_INTERNAL_SERVER_ERROR_get();
+  public final static native int PJSIP_SC_NOT_IMPLEMENTED_get();
+  public final static native int PJSIP_SC_BAD_GATEWAY_get();
+  public final static native int PJSIP_SC_SERVICE_UNAVAILABLE_get();
+  public final static native int PJSIP_SC_SERVER_TIMEOUT_get();
+  public final static native int PJSIP_SC_VERSION_NOT_SUPPORTED_get();
+  public final static native int PJSIP_SC_MESSAGE_TOO_LARGE_get();
+  public final static native int PJSIP_SC_PRECONDITION_FAILURE_get();
+  public final static native int PJSIP_SC_BUSY_EVERYWHERE_get();
+  public final static native int PJSIP_SC_DECLINE_get();
+  public final static native int PJSIP_SC_DOES_NOT_EXIST_ANYWHERE_get();
+  public final static native int PJSIP_SC_NOT_ACCEPTABLE_ANYWHERE_get();
+  public final static native int PJSIP_SC_TSX_TIMEOUT_get();
+  public final static native int PJSIP_SC_TSX_TRANSPORT_ERROR_get();
+  public final static native long pjsua_pool_create(String jarg1, long jarg2, long jarg3);
+  public final static native void pj_pool_release(long jarg1, pj_pool_t jarg1_);
+  public final static native int pjmedia_tonegen_create2(long jarg1, pj_pool_t jarg1_, long jarg2, pj_str_t jarg2_, long jarg3, long jarg4, long jarg5, long jarg6, long jarg7, pjmedia_port jarg8);
+  public final static native int pjmedia_tonegen_play(long jarg1, pjmedia_port jarg1_, long jarg2, long[] jarg3, long jarg4);
+  public final static native int pjmedia_tonegen_play_digits(long jarg1, pjmedia_port jarg1_, long jarg2, long[] jarg3, long jarg4);
+  public final static native int pjmedia_tonegen_rewind(long jarg1, pjmedia_port jarg1_);
+  public final static native int pjmedia_tonegen_stop(long jarg1, pjmedia_port jarg1_);
+  public final static native int pjmedia_port_destroy(long jarg1, pjmedia_port jarg1_);
+  public final static native int PJSIP_SSL_UNSPECIFIED_METHOD_get();
+  public final static native int PJSIP_SSLV2_METHOD_get();
+  public final static native int PJSIP_SSLV3_METHOD_get();
+  public final static native int PJSIP_TLSV1_METHOD_get();
+  public final static native int PJSIP_TLSV1_1_METHOD_get();
+  public final static native int PJSIP_TLSV1_2_METHOD_get();
+  public final static native int PJSIP_SSLV23_METHOD_get();
+  public final static native void pjsip_tls_setting_ca_list_file_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_tls_setting_ca_list_file_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_ca_list_path_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_tls_setting_ca_list_path_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_cert_file_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_tls_setting_cert_file_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_privkey_file_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_tls_setting_privkey_file_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_password_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_tls_setting_password_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_method_set(long jarg1, pjsip_tls_setting jarg1_, int jarg2);
+  public final static native int pjsip_tls_setting_method_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_proto_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2);
+  public final static native long pjsip_tls_setting_proto_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_ciphers_num_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2);
+  public final static native long pjsip_tls_setting_ciphers_num_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_ciphers_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2);
+  public final static native long pjsip_tls_setting_ciphers_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_verify_server_set(long jarg1, pjsip_tls_setting jarg1_, int jarg2);
+  public final static native int pjsip_tls_setting_verify_server_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_verify_client_set(long jarg1, pjsip_tls_setting jarg1_, int jarg2);
+  public final static native int pjsip_tls_setting_verify_client_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_require_client_cert_set(long jarg1, pjsip_tls_setting jarg1_, int jarg2);
+  public final static native int pjsip_tls_setting_require_client_cert_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_timeout_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2, pj_time_val jarg2_);
+  public final static native long pjsip_tls_setting_timeout_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_reuse_addr_set(long jarg1, pjsip_tls_setting jarg1_, int jarg2);
+  public final static native int pjsip_tls_setting_reuse_addr_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_qos_type_set(long jarg1, pjsip_tls_setting jarg1_, int jarg2);
+  public final static native int pjsip_tls_setting_qos_type_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_qos_params_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2, pj_qos_params jarg2_);
+  public final static native long pjsip_tls_setting_qos_params_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_qos_ignore_error_set(long jarg1, pjsip_tls_setting jarg1_, int jarg2);
+  public final static native int pjsip_tls_setting_qos_ignore_error_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_sockopt_params_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2);
+  public final static native long pjsip_tls_setting_sockopt_params_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_sockopt_ignore_error_set(long jarg1, pjsip_tls_setting jarg1_, int jarg2);
+  public final static native int pjsip_tls_setting_sockopt_ignore_error_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native long new_pjsip_tls_setting();
+  public final static native void delete_pjsip_tls_setting(long jarg1);
+  public final static native void pj_qos_params_flags_set(long jarg1, pj_qos_params jarg1_, short jarg2);
+  public final static native short pj_qos_params_flags_get(long jarg1, pj_qos_params jarg1_);
+  public final static native void pj_qos_params_dscp_val_set(long jarg1, pj_qos_params jarg1_, short jarg2);
+  public final static native short pj_qos_params_dscp_val_get(long jarg1, pj_qos_params jarg1_);
+  public final static native void pj_qos_params_so_prio_set(long jarg1, pj_qos_params jarg1_, short jarg2);
+  public final static native short pj_qos_params_so_prio_get(long jarg1, pj_qos_params jarg1_);
+  public final static native void pj_qos_params_wmm_prio_set(long jarg1, pj_qos_params jarg1_, long jarg2);
+  public final static native long pj_qos_params_wmm_prio_get(long jarg1, pj_qos_params jarg1_);
+  public final static native long new_pj_qos_params();
+  public final static native void delete_pj_qos_params(long jarg1);
+  public final static native void pj_time_val_sec_set(long jarg1, pj_time_val jarg1_, int jarg2);
+  public final static native int pj_time_val_sec_get(long jarg1, pj_time_val jarg1_);
+  public final static native void pj_time_val_msec_set(long jarg1, pj_time_val jarg1_, int jarg2);
+  public final static native int pj_time_val_msec_get(long jarg1, pj_time_val jarg1_);
+  public final static native long new_pj_time_val();
+  public final static native void delete_pj_time_val(long jarg1);
+  public final static native void pj_stun_nat_detect_result_status_set(long jarg1, pj_stun_nat_detect_result jarg1_, int jarg2);
+  public final static native int pj_stun_nat_detect_result_status_get(long jarg1, pj_stun_nat_detect_result jarg1_);
+  public final static native void pj_stun_nat_detect_result_status_text_set(long jarg1, pj_stun_nat_detect_result jarg1_, String jarg2);
+  public final static native String pj_stun_nat_detect_result_status_text_get(long jarg1, pj_stun_nat_detect_result jarg1_);
+  public final static native void pj_stun_nat_detect_result_nat_type_set(long jarg1, pj_stun_nat_detect_result jarg1_, int jarg2);
+  public final static native int pj_stun_nat_detect_result_nat_type_get(long jarg1, pj_stun_nat_detect_result jarg1_);
+  public final static native void pj_stun_nat_detect_result_nat_type_name_set(long jarg1, pj_stun_nat_detect_result jarg1_, String jarg2);
+  public final static native String pj_stun_nat_detect_result_nat_type_name_get(long jarg1, pj_stun_nat_detect_result jarg1_);
+  public final static native long new_pj_stun_nat_detect_result();
+  public final static native void delete_pj_stun_nat_detect_result(long jarg1);
+  public final static native void pjsip_timer_setting_min_se_set(long jarg1, pjsip_timer_setting jarg1_, long jarg2);
+  public final static native long pjsip_timer_setting_min_se_get(long jarg1, pjsip_timer_setting jarg1_);
+  public final static native void pjsip_timer_setting_sess_expires_set(long jarg1, pjsip_timer_setting jarg1_, long jarg2);
+  public final static native long pjsip_timer_setting_sess_expires_get(long jarg1, pjsip_timer_setting jarg1_);
+  public final static native long new_pjsip_timer_setting();
+  public final static native void delete_pjsip_timer_setting(long jarg1);
+  public final static native void pjsua_msg_data_target_uri_set(long jarg1, pjsua_msg_data jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_msg_data_target_uri_get(long jarg1, pjsua_msg_data jarg1_);
+  public final static native void pjsua_msg_data_hdr_list_set(long jarg1, pjsua_msg_data jarg1_, long jarg2);
+  public final static native long pjsua_msg_data_hdr_list_get(long jarg1, pjsua_msg_data jarg1_);
+  public final static native void pjsua_msg_data_content_type_set(long jarg1, pjsua_msg_data jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_msg_data_content_type_get(long jarg1, pjsua_msg_data jarg1_);
+  public final static native void pjsua_msg_data_msg_body_set(long jarg1, pjsua_msg_data jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_msg_data_msg_body_get(long jarg1, pjsua_msg_data jarg1_);
+  public final static native void pjsua_msg_data_multipart_ctype_set(long jarg1, pjsua_msg_data jarg1_, long jarg2);
+  public final static native long pjsua_msg_data_multipart_ctype_get(long jarg1, pjsua_msg_data jarg1_);
+  public final static native void pjsua_msg_data_multipart_parts_set(long jarg1, pjsua_msg_data jarg1_, long jarg2);
+  public final static native long pjsua_msg_data_multipart_parts_get(long jarg1, pjsua_msg_data jarg1_);
+  public final static native long new_pjsua_msg_data();
+  public final static native void delete_pjsua_msg_data(long jarg1);
+  public final static native void pjrpid_element_type_set(long jarg1, pjrpid_element jarg1_, long jarg2);
+  public final static native long pjrpid_element_type_get(long jarg1, pjrpid_element jarg1_);
+  public final static native void pjrpid_element_id_set(long jarg1, pjrpid_element jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjrpid_element_id_get(long jarg1, pjrpid_element jarg1_);
+  public final static native void pjrpid_element_activity_set(long jarg1, pjrpid_element jarg1_, int jarg2);
+  public final static native int pjrpid_element_activity_get(long jarg1, pjrpid_element jarg1_);
+  public final static native void pjrpid_element_note_set(long jarg1, pjrpid_element jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjrpid_element_note_get(long jarg1, pjrpid_element jarg1_);
+  public final static native long new_pjrpid_element();
+  public final static native void delete_pjrpid_element(long jarg1);
+  public final static native void pjsip_auth_clt_pref_initial_auth_set(long jarg1, pjsip_auth_clt_pref jarg1_, int jarg2);
+  public final static native int pjsip_auth_clt_pref_initial_auth_get(long jarg1, pjsip_auth_clt_pref jarg1_);
+  public final static native void pjsip_auth_clt_pref_algorithm_set(long jarg1, pjsip_auth_clt_pref jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_auth_clt_pref_algorithm_get(long jarg1, pjsip_auth_clt_pref jarg1_);
+  public final static native long new_pjsip_auth_clt_pref();
+  public final static native void delete_pjsip_auth_clt_pref(long jarg1);
+  public final static native void pj_ice_sess_options_aggressive_set(long jarg1, pj_ice_sess_options jarg1_, int jarg2);
+  public final static native int pj_ice_sess_options_aggressive_get(long jarg1, pj_ice_sess_options jarg1_);
+  public final static native void pj_ice_sess_options_nominated_check_delay_set(long jarg1, pj_ice_sess_options jarg1_, long jarg2);
+  public final static native long pj_ice_sess_options_nominated_check_delay_get(long jarg1, pj_ice_sess_options jarg1_);
+  public final static native void pj_ice_sess_options_controlled_agent_want_nom_timeout_set(long jarg1, pj_ice_sess_options jarg1_, int jarg2);
+  public final static native int pj_ice_sess_options_controlled_agent_want_nom_timeout_get(long jarg1, pj_ice_sess_options jarg1_);
+  public final static native long new_pj_ice_sess_options();
+  public final static native void delete_pj_ice_sess_options(long jarg1);
+  public final static native void delete_ZrtpCallback(long jarg1);
+  public final static native void ZrtpCallback_on_zrtp_show_sas(long jarg1, ZrtpCallback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, int jarg4);
+  public final static native void ZrtpCallback_on_zrtp_show_sasSwigExplicitZrtpCallback(long jarg1, ZrtpCallback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, int jarg4);
+  public final static native void ZrtpCallback_on_zrtp_update_transport(long jarg1, ZrtpCallback jarg1_, int jarg2);
+  public final static native void ZrtpCallback_on_zrtp_update_transportSwigExplicitZrtpCallback(long jarg1, ZrtpCallback jarg1_, int jarg2);
+  public final static native long new_ZrtpCallback();
+  public final static native void ZrtpCallback_director_connect(ZrtpCallback obj, long cptr, boolean mem_own, boolean weak_global);
+  public final static native void ZrtpCallback_change_ownership(ZrtpCallback obj, long cptr, boolean take_or_release);
+  public final static native void setZrtpCallbackObject(long jarg1, ZrtpCallback jarg1_);
+  public final static native void delete_MobileRegHandlerCallback(long jarg1);
+  public final static native void MobileRegHandlerCallback_on_save_contact(long jarg1, MobileRegHandlerCallback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, int jarg4);
+  public final static native void MobileRegHandlerCallback_on_save_contactSwigExplicitMobileRegHandlerCallback(long jarg1, MobileRegHandlerCallback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, int jarg4);
+  public final static native long MobileRegHandlerCallback_on_restore_contact(long jarg1, MobileRegHandlerCallback jarg1_, int jarg2);
+  public final static native long MobileRegHandlerCallback_on_restore_contactSwigExplicitMobileRegHandlerCallback(long jarg1, MobileRegHandlerCallback jarg1_, int jarg2);
+  public final static native long new_MobileRegHandlerCallback();
+  public final static native void MobileRegHandlerCallback_director_connect(MobileRegHandlerCallback obj, long cptr, boolean mem_own, boolean weak_global);
+  public final static native void MobileRegHandlerCallback_change_ownership(MobileRegHandlerCallback obj, long cptr, boolean take_or_release);
+  public final static native int mobile_reg_handler_init();
+  public final static native void mobile_reg_handler_set_callback(long jarg1, MobileRegHandlerCallback jarg1_);
+  public final static native int sipclf_mod_init();
+  public final static native void delete_EarlyLockCallback(long jarg1);
+  public final static native void EarlyLockCallback_on_create_early_lock(long jarg1, EarlyLockCallback jarg1_);
+  public final static native void EarlyLockCallback_on_create_early_lockSwigExplicitEarlyLockCallback(long jarg1, EarlyLockCallback jarg1_);
+  public final static native long new_EarlyLockCallback();
+  public final static native void EarlyLockCallback_director_connect(EarlyLockCallback obj, long cptr, boolean mem_own, boolean weak_global);
+  public final static native void EarlyLockCallback_change_ownership(EarlyLockCallback obj, long cptr, boolean take_or_release);
+  public final static native int mod_earlylock_init();
+  public final static native void mod_earlylock_set_callback(long jarg1, EarlyLockCallback jarg1_);
+  public final static native int PJSUA_INVALID_ID_get();
+  public final static native int DISABLED_FOR_TICKET_1185_get();
+  public final static native int PJSUA_ACC_MAX_PROXIES_get();
+  public final static native int PJSUA_DEFAULT_SRTP_SECURE_SIGNALING_get();
+  public final static native int PJSUA_ADD_ICE_TAGS_get();
+  public final static native int PJSUA_ACQUIRE_CALL_TIMEOUT_get();
+  public final static native int PJSUA_HAS_VIDEO_get();
+  public final static native int PJSUA_VID_REQ_KEYFRAME_INTERVAL_get();
+  public final static native void pjsua_logging_config_msg_logging_set(long jarg1, pjsua_logging_config jarg1_, int jarg2);
+  public final static native int pjsua_logging_config_msg_logging_get(long jarg1, pjsua_logging_config jarg1_);
+  public final static native void pjsua_logging_config_level_set(long jarg1, pjsua_logging_config jarg1_, long jarg2);
+  public final static native long pjsua_logging_config_level_get(long jarg1, pjsua_logging_config jarg1_);
+  public final static native void pjsua_logging_config_console_level_set(long jarg1, pjsua_logging_config jarg1_, long jarg2);
+  public final static native long pjsua_logging_config_console_level_get(long jarg1, pjsua_logging_config jarg1_);
+  public final static native void pjsua_logging_config_decor_set(long jarg1, pjsua_logging_config jarg1_, long jarg2);
+  public final static native long pjsua_logging_config_decor_get(long jarg1, pjsua_logging_config jarg1_);
+  public final static native void pjsua_logging_config_log_filename_set(long jarg1, pjsua_logging_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_logging_config_log_filename_get(long jarg1, pjsua_logging_config jarg1_);
+  public final static native void pjsua_logging_config_log_file_flags_set(long jarg1, pjsua_logging_config jarg1_, long jarg2);
+  public final static native long pjsua_logging_config_log_file_flags_get(long jarg1, pjsua_logging_config jarg1_);
+  public final static native void pjsua_logging_config_cb_set(long jarg1, pjsua_logging_config jarg1_, long jarg2);
+  public final static native long pjsua_logging_config_cb_get(long jarg1, pjsua_logging_config jarg1_);
+  public final static native long new_pjsua_logging_config();
+  public final static native void delete_pjsua_logging_config(long jarg1);
+  public final static native void logging_config_default(long jarg1, pjsua_logging_config jarg1_);
+  public final static native void logging_config_dup(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_logging_config jarg2_, long jarg3, pjsua_logging_config jarg3_);
+  public final static native void pjsua_mwi_info_evsub_set(long jarg1, pjsua_mwi_info jarg1_, long jarg2);
+  public final static native long pjsua_mwi_info_evsub_get(long jarg1, pjsua_mwi_info jarg1_);
+  public final static native void pjsua_mwi_info_rdata_set(long jarg1, pjsua_mwi_info jarg1_, long jarg2);
+  public final static native long pjsua_mwi_info_rdata_get(long jarg1, pjsua_mwi_info jarg1_);
+  public final static native long new_pjsua_mwi_info();
+  public final static native void delete_pjsua_mwi_info(long jarg1);
+  public final static native void pjsua_reg_info_cbparam_set(long jarg1, pjsua_reg_info jarg1_, long jarg2);
+  public final static native long pjsua_reg_info_cbparam_get(long jarg1, pjsua_reg_info jarg1_);
+  public final static native long new_pjsua_reg_info();
+  public final static native void delete_pjsua_reg_info(long jarg1);
+  public final static native void pjsua_med_tp_state_info_med_idx_set(long jarg1, pjsua_med_tp_state_info jarg1_, long jarg2);
+  public final static native long pjsua_med_tp_state_info_med_idx_get(long jarg1, pjsua_med_tp_state_info jarg1_);
+  public final static native void pjsua_med_tp_state_info_state_set(long jarg1, pjsua_med_tp_state_info jarg1_, int jarg2);
+  public final static native int pjsua_med_tp_state_info_state_get(long jarg1, pjsua_med_tp_state_info jarg1_);
+  public final static native void pjsua_med_tp_state_info_status_set(long jarg1, pjsua_med_tp_state_info jarg1_, int jarg2);
+  public final static native int pjsua_med_tp_state_info_status_get(long jarg1, pjsua_med_tp_state_info jarg1_);
+  public final static native void pjsua_med_tp_state_info_sip_err_code_set(long jarg1, pjsua_med_tp_state_info jarg1_, int jarg2);
+  public final static native int pjsua_med_tp_state_info_sip_err_code_get(long jarg1, pjsua_med_tp_state_info jarg1_);
+  public final static native void pjsua_med_tp_state_info_ext_info_set(long jarg1, pjsua_med_tp_state_info jarg1_, byte[] jarg2);
+  public final static native byte[] pjsua_med_tp_state_info_ext_info_get(long jarg1, pjsua_med_tp_state_info jarg1_);
+  public final static native long new_pjsua_med_tp_state_info();
+  public final static native void delete_pjsua_med_tp_state_info(long jarg1);
+  public final static native int PJSUA_MED_TP_CLOSE_MEMBER_get();
+  public final static native int PJSUA_CONTACT_REWRITE_UNREGISTER_get();
+  public final static native int PJSUA_CONTACT_REWRITE_NO_UNREG_get();
+  public final static native int PJSUA_CONTACT_REWRITE_ALWAYS_UPDATE_get();
+  public final static native void pjsua_call_setting_flag_set(long jarg1, pjsua_call_setting jarg1_, long jarg2);
+  public final static native long pjsua_call_setting_flag_get(long jarg1, pjsua_call_setting jarg1_);
+  public final static native void pjsua_call_setting_req_keyframe_method_set(long jarg1, pjsua_call_setting jarg1_, long jarg2);
+  public final static native long pjsua_call_setting_req_keyframe_method_get(long jarg1, pjsua_call_setting jarg1_);
+  public final static native void pjsua_call_setting_aud_cnt_set(long jarg1, pjsua_call_setting jarg1_, long jarg2);
+  public final static native long pjsua_call_setting_aud_cnt_get(long jarg1, pjsua_call_setting jarg1_);
+  public final static native void pjsua_call_setting_vid_cnt_set(long jarg1, pjsua_call_setting jarg1_, long jarg2);
+  public final static native long pjsua_call_setting_vid_cnt_get(long jarg1, pjsua_call_setting jarg1_);
+  public final static native long new_pjsua_call_setting();
+  public final static native void delete_pjsua_call_setting(long jarg1);
+  public final static native void pjsua_callback_on_call_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_incoming_call_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_incoming_call_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_tsx_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_tsx_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_media_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_media_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_sdp_created_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_sdp_created_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_stream_created_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_stream_created_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_stream_destroyed_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_stream_destroyed_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_dtmf_digit_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_dtmf_digit_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_transfer_request_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_transfer_request_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_transfer_request2_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_transfer_request2_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_transfer_status_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_transfer_status_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_replace_request_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_replace_request_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_replace_request2_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_replace_request2_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_replaced_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_replaced_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_rx_offer_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_rx_offer_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_reg_started_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_reg_started_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_reg_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_reg_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_reg_state2_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_reg_state2_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_incoming_subscribe_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_incoming_subscribe_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_srv_subscribe_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_srv_subscribe_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_buddy_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_buddy_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_buddy_evsub_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_buddy_evsub_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_pager_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_pager_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_pager2_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_pager2_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_pager_status_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_pager_status_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_pager_status2_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_pager_status2_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_typing_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_typing_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_typing2_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_typing2_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_nat_detect_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_nat_detect_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_redirected_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_redirected_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_mwi_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_mwi_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_mwi_info_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_mwi_info_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_transport_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_transport_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_media_transport_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_media_transport_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_ice_transport_error_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_ice_transport_error_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_snd_dev_operation_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_snd_dev_operation_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_media_event_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_media_event_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_create_media_transport_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_create_media_transport_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_acc_find_for_incoming_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_acc_find_for_incoming_get(long jarg1, pjsua_callback jarg1_);
+  public final static native long new_pjsua_callback();
+  public final static native void delete_pjsua_callback(long jarg1);
+  public final static native void pjsua_config_max_calls_set(long jarg1, pjsua_config jarg1_, long jarg2);
+  public final static native long pjsua_config_max_calls_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_thread_cnt_set(long jarg1, pjsua_config jarg1_, long jarg2);
+  public final static native long pjsua_config_thread_cnt_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_nameserver_count_set(long jarg1, pjsua_config jarg1_, long jarg2);
+  public final static native long pjsua_config_nameserver_count_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_nameserver_set(long jarg1, pjsua_config jarg1_, long[] jarg2);
+  public final static native long[] pjsua_config_nameserver_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_force_lr_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_force_lr_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_outbound_proxy_cnt_set(long jarg1, pjsua_config jarg1_, long jarg2);
+  public final static native long pjsua_config_outbound_proxy_cnt_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_outbound_proxy_set(long jarg1, pjsua_config jarg1_, long[] jarg2);
+  public final static native long[] pjsua_config_outbound_proxy_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_stun_domain_set(long jarg1, pjsua_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_config_stun_domain_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_stun_host_set(long jarg1, pjsua_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_config_stun_host_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_stun_srv_cnt_set(long jarg1, pjsua_config jarg1_, long jarg2);
+  public final static native long pjsua_config_stun_srv_cnt_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_stun_srv_set(long jarg1, pjsua_config jarg1_, long[] jarg2);
+  public final static native long[] pjsua_config_stun_srv_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_stun_ignore_failure_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_stun_ignore_failure_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_stun_map_use_stun2_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_stun_map_use_stun2_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_nat_type_in_sdp_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_nat_type_in_sdp_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_require_100rel_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_require_100rel_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_use_timer_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_use_timer_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_enable_unsolicited_mwi_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_enable_unsolicited_mwi_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_timer_setting_set(long jarg1, pjsua_config jarg1_, long jarg2, pjsip_timer_setting jarg2_);
+  public final static native long pjsua_config_timer_setting_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_cred_count_set(long jarg1, pjsua_config jarg1_, long jarg2);
+  public final static native long pjsua_config_cred_count_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_cred_info_set(long jarg1, pjsua_config jarg1_, long jarg2, pjsip_cred_info jarg2_);
+  public final static native long pjsua_config_cred_info_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_cb_set(long jarg1, pjsua_config jarg1_, long jarg2, pjsua_callback jarg2_);
+  public final static native long pjsua_config_cb_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_user_agent_set(long jarg1, pjsua_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_config_user_agent_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_use_srtp_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_use_srtp_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_srtp_secure_signaling_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_srtp_secure_signaling_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_srtp_optional_dup_offer_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_srtp_optional_dup_offer_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_hangup_forked_call_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_hangup_forked_call_get(long jarg1, pjsua_config jarg1_);
+  public final static native long new_pjsua_config();
+  public final static native void delete_pjsua_config(long jarg1);
+  public final static native int PJSUA_DESTROY_NO_RX_MSG_get();
+  public final static native int PJSUA_DESTROY_NO_TX_MSG_get();
+  public final static native int PJSUA_DESTROY_NO_NETWORK_get();
+  public final static native void config_default(long jarg1, pjsua_config jarg1_);
+  public final static native void config_dup(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_config jarg2_, long jarg3, pjsua_config jarg3_);
+  public final static native void msg_data_init(long jarg1, pjsua_msg_data jarg1_);
+  public final static native long msg_data_clone(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_msg_data jarg2_);
+  public final static native int create();
+  public final static native int start();
+  public final static native int get_state();
+  public final static native int handle_events(long jarg1);
+  public final static native void stop_worker_threads();
+  public final static native long pool_create(String jarg1, long jarg2, long jarg3);
+  public final static native int reconfigure_logging(long jarg1, pjsua_logging_config jarg1_);
+  public final static native long get_pjsip_endpt();
+  public final static native long get_pjmedia_endpt();
+  public final static native long get_pool_factory();
+  public final static native void pj_stun_resolve_result_token_set(long jarg1, pj_stun_resolve_result jarg1_, byte[] jarg2);
+  public final static native byte[] pj_stun_resolve_result_token_get(long jarg1, pj_stun_resolve_result jarg1_);
+  public final static native void pj_stun_resolve_result_status_set(long jarg1, pj_stun_resolve_result jarg1_, int jarg2);
+  public final static native int pj_stun_resolve_result_status_get(long jarg1, pj_stun_resolve_result jarg1_);
+  public final static native void pj_stun_resolve_result_name_set(long jarg1, pj_stun_resolve_result jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pj_stun_resolve_result_name_get(long jarg1, pj_stun_resolve_result jarg1_);
+  public final static native void pj_stun_resolve_result_addr_set(long jarg1, pj_stun_resolve_result jarg1_, long jarg2);
+  public final static native long pj_stun_resolve_result_addr_get(long jarg1, pj_stun_resolve_result jarg1_);
+  public final static native long new_pj_stun_resolve_result();
+  public final static native void delete_pj_stun_resolve_result(long jarg1);
+  public final static native int detect_nat_type();
+  public final static native int get_nat_type(int[] jarg1);
+  public final static native int resolve_stun_servers(long jarg1, long[] jarg2, int jarg3, byte[] jarg4, long jarg5);
+  public final static native int cancel_stun_resolution(byte[] jarg1, int jarg2);
+  public final static native int verify_sip_url(String jarg1);
+  public final static native int verify_url(String jarg1);
+  public final static native int schedule_timer(long jarg1, long jarg2, pj_time_val jarg2_);
+  public final static native int pjsua_schedule_timer2(long jarg1, byte[] jarg2, long jarg3);
+  public final static native void cancel_timer(long jarg1);
+  public final static native void perror(String jarg1, String jarg2, int jarg3);
+  public final static native void dump(int jarg1);
+  public final static native void pjsua_transport_config_port_set(long jarg1, pjsua_transport_config jarg1_, long jarg2);
+  public final static native long pjsua_transport_config_port_get(long jarg1, pjsua_transport_config jarg1_);
+  public final static native void pjsua_transport_config_port_range_set(long jarg1, pjsua_transport_config jarg1_, long jarg2);
+  public final static native long pjsua_transport_config_port_range_get(long jarg1, pjsua_transport_config jarg1_);
+  public final static native void pjsua_transport_config_public_addr_set(long jarg1, pjsua_transport_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_transport_config_public_addr_get(long jarg1, pjsua_transport_config jarg1_);
+  public final static native void pjsua_transport_config_bound_addr_set(long jarg1, pjsua_transport_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_transport_config_bound_addr_get(long jarg1, pjsua_transport_config jarg1_);
+  public final static native void pjsua_transport_config_tls_setting_set(long jarg1, pjsua_transport_config jarg1_, long jarg2, pjsip_tls_setting jarg2_);
+  public final static native long pjsua_transport_config_tls_setting_get(long jarg1, pjsua_transport_config jarg1_);
+  public final static native void pjsua_transport_config_qos_type_set(long jarg1, pjsua_transport_config jarg1_, int jarg2);
+  public final static native int pjsua_transport_config_qos_type_get(long jarg1, pjsua_transport_config jarg1_);
+  public final static native void pjsua_transport_config_qos_params_set(long jarg1, pjsua_transport_config jarg1_, long jarg2, pj_qos_params jarg2_);
+  public final static native long pjsua_transport_config_qos_params_get(long jarg1, pjsua_transport_config jarg1_);
+  public final static native void pjsua_transport_config_sockopt_params_set(long jarg1, pjsua_transport_config jarg1_, long jarg2);
+  public final static native long pjsua_transport_config_sockopt_params_get(long jarg1, pjsua_transport_config jarg1_);
+  public final static native long new_pjsua_transport_config();
+  public final static native void delete_pjsua_transport_config(long jarg1);
+  public final static native void transport_config_default(long jarg1, pjsua_transport_config jarg1_);
+  public final static native void transport_config_dup(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_transport_config jarg2_, long jarg3, pjsua_transport_config jarg3_);
+  public final static native void pjsua_transport_info_id_set(long jarg1, pjsua_transport_info jarg1_, int jarg2);
+  public final static native int pjsua_transport_info_id_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native void pjsua_transport_info_type_set(long jarg1, pjsua_transport_info jarg1_, int jarg2);
+  public final static native int pjsua_transport_info_type_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native void pjsua_transport_info_type_name_set(long jarg1, pjsua_transport_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_transport_info_type_name_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native void pjsua_transport_info_info_set(long jarg1, pjsua_transport_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_transport_info_info_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native void pjsua_transport_info_flag_set(long jarg1, pjsua_transport_info jarg1_, long jarg2);
+  public final static native long pjsua_transport_info_flag_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native void pjsua_transport_info_addr_len_set(long jarg1, pjsua_transport_info jarg1_, long jarg2);
+  public final static native long pjsua_transport_info_addr_len_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native void pjsua_transport_info_local_addr_set(long jarg1, pjsua_transport_info jarg1_, long jarg2);
+  public final static native long pjsua_transport_info_local_addr_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native void pjsua_transport_info_local_name_set(long jarg1, pjsua_transport_info jarg1_, long jarg2);
+  public final static native long pjsua_transport_info_local_name_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native void pjsua_transport_info_usage_count_set(long jarg1, pjsua_transport_info jarg1_, long jarg2);
+  public final static native long pjsua_transport_info_usage_count_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native long new_pjsua_transport_info();
+  public final static native void delete_pjsua_transport_info(long jarg1);
+  public final static native int transport_create(int jarg1, long jarg2, pjsua_transport_config jarg2_, int[] jarg3);
+  public final static native int transport_register(long jarg1, int[] jarg2);
+  public final static native int enum_transports(int[] jarg1, long[] jarg2);
+  public final static native int transport_get_info(int jarg1, long jarg2, pjsua_transport_info jarg2_);
+  public final static native int transport_set_enable(int jarg1, int jarg2);
+  public final static native int transport_close(int jarg1, int jarg2);
+  public final static native int PJSUA_MAX_ACC_get();
+  public final static native int PJSUA_REG_INTERVAL_get();
+  public final static native int PJSUA_UNREG_TIMEOUT_get();
+  public final static native int PJSUA_DEFAULT_ACC_PRIORITY_get();
+  public final static native int PJSUA_UNPUBLISH_MAX_WAIT_TIME_MSEC_get();
+  public final static native int PJSUA_REG_RETRY_INTERVAL_get();
+  public final static native int PJSUA_REG_USE_OUTBOUND_PROXY_get();
+  public final static native int PJSUA_REG_USE_ACC_PROXY_get();
+  public final static native void pjsua_ice_config_enable_ice_set(long jarg1, pjsua_ice_config jarg1_, int jarg2);
+  public final static native int pjsua_ice_config_enable_ice_get(long jarg1, pjsua_ice_config jarg1_);
+  public final static native void pjsua_ice_config_ice_max_host_cands_set(long jarg1, pjsua_ice_config jarg1_, int jarg2);
+  public final static native int pjsua_ice_config_ice_max_host_cands_get(long jarg1, pjsua_ice_config jarg1_);
+  public final static native void pjsua_ice_config_ice_opt_set(long jarg1, pjsua_ice_config jarg1_, long jarg2, pj_ice_sess_options jarg2_);
+  public final static native long pjsua_ice_config_ice_opt_get(long jarg1, pjsua_ice_config jarg1_);
+  public final static native void pjsua_ice_config_ice_no_rtcp_set(long jarg1, pjsua_ice_config jarg1_, int jarg2);
+  public final static native int pjsua_ice_config_ice_no_rtcp_get(long jarg1, pjsua_ice_config jarg1_);
+  public final static native void pjsua_ice_config_ice_always_update_set(long jarg1, pjsua_ice_config jarg1_, int jarg2);
+  public final static native int pjsua_ice_config_ice_always_update_get(long jarg1, pjsua_ice_config jarg1_);
+  public final static native long new_pjsua_ice_config();
+  public final static native void delete_pjsua_ice_config(long jarg1);
+  public final static native void pjsua_turn_config_enable_turn_set(long jarg1, pjsua_turn_config jarg1_, int jarg2);
+  public final static native int pjsua_turn_config_enable_turn_get(long jarg1, pjsua_turn_config jarg1_);
+  public final static native void pjsua_turn_config_turn_server_set(long jarg1, pjsua_turn_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_turn_config_turn_server_get(long jarg1, pjsua_turn_config jarg1_);
+  public final static native void pjsua_turn_config_turn_conn_type_set(long jarg1, pjsua_turn_config jarg1_, int jarg2);
+  public final static native int pjsua_turn_config_turn_conn_type_get(long jarg1, pjsua_turn_config jarg1_);
+  public final static native void pjsua_turn_config_turn_auth_cred_set(long jarg1, pjsua_turn_config jarg1_, long jarg2);
+  public final static native long pjsua_turn_config_turn_auth_cred_get(long jarg1, pjsua_turn_config jarg1_);
+  public final static native long new_pjsua_turn_config();
+  public final static native void delete_pjsua_turn_config(long jarg1);
+  public final static native void pjsua_acc_config_user_data_set(long jarg1, pjsua_acc_config jarg1_, byte[] jarg2);
+  public final static native byte[] pjsua_acc_config_user_data_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_priority_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_priority_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_id_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_id_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_reg_uri_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_reg_uri_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_reg_hdr_list_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_reg_hdr_list_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_sub_hdr_list_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_sub_hdr_list_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_mwi_enabled_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_mwi_enabled_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_mwi_expires_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_mwi_expires_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_publish_enabled_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_publish_enabled_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_publish_opt_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_publish_opt_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_unpublish_max_wait_time_msec_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_unpublish_max_wait_time_msec_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_auth_pref_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pjsip_auth_clt_pref jarg2_);
+  public final static native long pjsua_acc_config_auth_pref_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_pidf_tuple_id_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_pidf_tuple_id_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_force_contact_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_force_contact_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_contact_params_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_contact_params_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_contact_uri_params_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_contact_uri_params_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_require_100rel_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_require_100rel_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_use_timer_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_use_timer_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_timer_setting_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pjsip_timer_setting jarg2_);
+  public final static native long pjsua_acc_config_timer_setting_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_proxy_cnt_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_proxy_cnt_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_proxy_set(long jarg1, pjsua_acc_config jarg1_, long[] jarg2);
+  public final static native long[] pjsua_acc_config_proxy_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_lock_codec_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_lock_codec_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_reg_timeout_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_reg_timeout_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_reg_delay_before_refresh_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_reg_delay_before_refresh_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_unreg_timeout_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_unreg_timeout_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_cred_count_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_cred_count_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_cred_info_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pjsip_cred_info jarg2_);
+  public final static native long pjsua_acc_config_cred_info_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_transport_id_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_transport_id_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_allow_contact_rewrite_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_allow_contact_rewrite_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_contact_rewrite_method_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_contact_rewrite_method_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_contact_use_src_port_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_contact_use_src_port_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_allow_via_rewrite_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_allow_via_rewrite_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_allow_sdp_nat_rewrite_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_allow_sdp_nat_rewrite_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_use_rfc5626_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_use_rfc5626_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_rfc5626_instance_id_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_rfc5626_instance_id_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_rfc5626_reg_id_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_rfc5626_reg_id_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_ka_interval_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_ka_interval_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_ka_data_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_ka_data_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_vid_in_auto_show_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_vid_in_auto_show_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_vid_out_auto_transmit_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_vid_out_auto_transmit_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_vid_wnd_flags_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_vid_wnd_flags_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_vid_cap_dev_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_vid_cap_dev_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_vid_rend_dev_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_vid_rend_dev_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_vid_stream_rc_cfg_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_vid_stream_rc_cfg_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_rtp_cfg_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pjsua_transport_config jarg2_);
+  public final static native long pjsua_acc_config_rtp_cfg_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_ipv6_media_use_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_ipv6_media_use_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_sip_stun_use_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_sip_stun_use_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_media_stun_use_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_media_stun_use_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_ice_cfg_use_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_ice_cfg_use_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_ice_cfg_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pjsua_ice_config jarg2_);
+  public final static native long pjsua_acc_config_ice_cfg_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_turn_cfg_use_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_turn_cfg_use_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_turn_cfg_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pjsua_turn_config jarg2_);
+  public final static native long pjsua_acc_config_turn_cfg_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_use_srtp_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_use_srtp_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_srtp_secure_signaling_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_srtp_secure_signaling_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_srtp_optional_dup_offer_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_srtp_optional_dup_offer_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_reg_retry_interval_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_reg_retry_interval_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_reg_first_retry_interval_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_reg_first_retry_interval_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_reg_retry_random_interval_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_reg_retry_random_interval_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_drop_calls_on_reg_fail_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_drop_calls_on_reg_fail_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_reg_use_proxy_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_reg_use_proxy_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_call_hold_type_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_call_hold_type_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_register_on_acc_add_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_register_on_acc_add_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native long new_pjsua_acc_config();
+  public final static native void delete_pjsua_acc_config(long jarg1);
+  public final static native void ice_config_from_media_config(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_ice_config jarg2_, long jarg3, pjsua_media_config jarg3_);
+  public final static native void ice_config_dup(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_ice_config jarg2_, long jarg3, pjsua_ice_config jarg3_);
+  public final static native void turn_config_from_media_config(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_turn_config jarg2_, long jarg3, pjsua_media_config jarg3_);
+  public final static native void turn_config_dup(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_turn_config jarg2_, long jarg3, pjsua_turn_config jarg3_);
+  public final static native void acc_config_default(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void acc_config_dup(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_acc_config jarg2_, long jarg3, pjsua_acc_config jarg3_);
+  public final static native void pjsua_acc_info_id_set(long jarg1, pjsua_acc_info jarg1_, int jarg2);
+  public final static native int pjsua_acc_info_id_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_is_default_set(long jarg1, pjsua_acc_info jarg1_, int jarg2);
+  public final static native int pjsua_acc_info_is_default_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_acc_uri_set(long jarg1, pjsua_acc_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_info_acc_uri_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_has_registration_set(long jarg1, pjsua_acc_info jarg1_, int jarg2);
+  public final static native int pjsua_acc_info_has_registration_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_expires_set(long jarg1, pjsua_acc_info jarg1_, int jarg2);
+  public final static native int pjsua_acc_info_expires_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_status_set(long jarg1, pjsua_acc_info jarg1_, int jarg2);
+  public final static native int pjsua_acc_info_status_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_reg_last_err_set(long jarg1, pjsua_acc_info jarg1_, int jarg2);
+  public final static native int pjsua_acc_info_reg_last_err_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_status_text_set(long jarg1, pjsua_acc_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_info_status_text_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_online_status_set(long jarg1, pjsua_acc_info jarg1_, int jarg2);
+  public final static native int pjsua_acc_info_online_status_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_online_status_text_set(long jarg1, pjsua_acc_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_info_online_status_text_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_rpid_set(long jarg1, pjsua_acc_info jarg1_, long jarg2, pjrpid_element jarg2_);
+  public final static native long pjsua_acc_info_rpid_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_buf__set(long jarg1, pjsua_acc_info jarg1_, String jarg2);
+  public final static native String pjsua_acc_info_buf__get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native long new_pjsua_acc_info();
+  public final static native void delete_pjsua_acc_info(long jarg1);
+  public final static native long acc_get_count();
+  public final static native int acc_is_valid(int jarg1);
+  public final static native int acc_set_default(int jarg1);
+  public final static native int acc_get_default();
+  public final static native int acc_add(long jarg1, pjsua_acc_config jarg1_, int jarg2, int[] jarg3);
+  public final static native int acc_add_local(int jarg1, int jarg2, int[] jarg3);
+  public final static native int acc_set_user_data(int jarg1, byte[] jarg2);
+  public final static native byte[] acc_get_user_data(int jarg1);
+  public final static native int acc_del(int jarg1);
+  public final static native int acc_get_config(int jarg1, long jarg2, pj_pool_t jarg2_, long jarg3, pjsua_acc_config jarg3_);
+  public final static native int acc_modify(int jarg1, long jarg2, pjsua_acc_config jarg2_);
+  public final static native int acc_set_online_status(int jarg1, int jarg2);
+  public final static native int acc_set_online_status2(int jarg1, int jarg2, long jarg3, pjrpid_element jarg3_);
+  public final static native int acc_set_registration(int jarg1, int jarg2);
+  public final static native int acc_get_info(int jarg1, long jarg2, pjsua_acc_info jarg2_);
+  public final static native int enum_accs(int[] jarg1, long[] jarg2);
+  public final static native int acc_enum_info(long jarg1, pjsua_acc_info jarg1_, long[] jarg2);
+  public final static native int acc_find_for_outgoing(long jarg1, pj_str_t jarg1_);
+  public final static native int acc_find_for_incoming(long jarg1);
+  public final static native int acc_create_request(int jarg1, long jarg2, long jarg3, pj_str_t jarg3_, long jarg4);
+  public final static native int acc_create_uac_contact(long jarg1, pj_pool_t jarg1_, long jarg2, pj_str_t jarg2_, int jarg3, long jarg4, pj_str_t jarg4_);
+  public final static native int acc_create_uas_contact(long jarg1, pj_pool_t jarg1_, long jarg2, pj_str_t jarg2_, int jarg3, long jarg4);
+  public final static native int acc_set_transport(int jarg1, int jarg2);
+  public final static native int PJSUA_MAX_CALLS_get();
+  public final static native int PJSUA_MAX_VID_WINS_get();
+  public final static native int PJSUA_VID_REQ_KEYFRAME_SIP_INFO_get();
+  public final static native int PJSUA_VID_REQ_KEYFRAME_RTCP_PLI_get();
+  public final static native void pjsua_call_media_info_index_set(long jarg1, pjsua_call_media_info jarg1_, long jarg2);
+  public final static native long pjsua_call_media_info_index_get(long jarg1, pjsua_call_media_info jarg1_);
+  public final static native void pjsua_call_media_info_type_set(long jarg1, pjsua_call_media_info jarg1_, long jarg2);
+  public final static native long pjsua_call_media_info_type_get(long jarg1, pjsua_call_media_info jarg1_);
+  public final static native void pjsua_call_media_info_dir_set(long jarg1, pjsua_call_media_info jarg1_, int jarg2);
+  public final static native int pjsua_call_media_info_dir_get(long jarg1, pjsua_call_media_info jarg1_);
+  public final static native void pjsua_call_media_info_status_set(long jarg1, pjsua_call_media_info jarg1_, int jarg2);
+  public final static native int pjsua_call_media_info_status_get(long jarg1, pjsua_call_media_info jarg1_);
+  public final static native long new_pjsua_call_media_info();
+  public final static native void delete_pjsua_call_media_info(long jarg1);
+  public final static native void pjsua_call_info_id_set(long jarg1, pjsua_call_info jarg1_, int jarg2);
+  public final static native int pjsua_call_info_id_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_role_set(long jarg1, pjsua_call_info jarg1_, long jarg2);
+  public final static native long pjsua_call_info_role_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_acc_id_set(long jarg1, pjsua_call_info jarg1_, int jarg2);
+  public final static native int pjsua_call_info_acc_id_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_local_info_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_call_info_local_info_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_local_contact_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_call_info_local_contact_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_remote_info_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_call_info_remote_info_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_remote_contact_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_call_info_remote_contact_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_call_id_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_call_info_call_id_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_setting_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pjsua_call_setting jarg2_);
+  public final static native long pjsua_call_info_setting_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_state_set(long jarg1, pjsua_call_info jarg1_, int jarg2);
+  public final static native int pjsua_call_info_state_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_state_text_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_call_info_state_text_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_last_status_set(long jarg1, pjsua_call_info jarg1_, int jarg2);
+  public final static native int pjsua_call_info_last_status_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_last_status_text_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_call_info_last_status_text_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_media_status_set(long jarg1, pjsua_call_info jarg1_, int jarg2);
+  public final static native int pjsua_call_info_media_status_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_media_dir_set(long jarg1, pjsua_call_info jarg1_, int jarg2);
+  public final static native int pjsua_call_info_media_dir_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_conf_slot_set(long jarg1, pjsua_call_info jarg1_, int jarg2);
+  public final static native int pjsua_call_info_conf_slot_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_media_cnt_set(long jarg1, pjsua_call_info jarg1_, long jarg2);
+  public final static native long pjsua_call_info_media_cnt_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_media_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pjsua_call_media_info jarg2_);
+  public final static native long pjsua_call_info_media_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_prov_media_cnt_set(long jarg1, pjsua_call_info jarg1_, long jarg2);
+  public final static native long pjsua_call_info_prov_media_cnt_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_prov_media_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pjsua_call_media_info jarg2_);
+  public final static native long pjsua_call_info_prov_media_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_connect_duration_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_time_val jarg2_);
+  public final static native long pjsua_call_info_connect_duration_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_total_duration_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_time_val jarg2_);
+  public final static native long pjsua_call_info_total_duration_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_rem_offerer_set(long jarg1, pjsua_call_info jarg1_, int jarg2);
+  public final static native int pjsua_call_info_rem_offerer_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_rem_aud_cnt_set(long jarg1, pjsua_call_info jarg1_, long jarg2);
+  public final static native long pjsua_call_info_rem_aud_cnt_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_rem_vid_cnt_set(long jarg1, pjsua_call_info jarg1_, long jarg2);
+  public final static native long pjsua_call_info_rem_vid_cnt_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native long new_pjsua_call_info();
+  public final static native void delete_pjsua_call_info(long jarg1);
+  public final static native int PJSUA_CALL_UNHOLD_get();
+  public final static native int PJSUA_CALL_UPDATE_CONTACT_get();
+  public final static native int PJSUA_CALL_INCLUDE_DISABLED_MEDIA_get();
+  public final static native int PJSUA_CALL_NO_SDP_OFFER_get();
+  public final static native void pjsua_stream_info_type_set(long jarg1, pjsua_stream_info jarg1_, long jarg2);
+  public final static native long pjsua_stream_info_type_get(long jarg1, pjsua_stream_info jarg1_);
+  public final static native long new_pjsua_stream_info();
+  public final static native void delete_pjsua_stream_info(long jarg1);
+  public final static native void pjsua_stream_stat_rtcp_set(long jarg1, pjsua_stream_stat jarg1_, long jarg2);
+  public final static native long pjsua_stream_stat_rtcp_get(long jarg1, pjsua_stream_stat jarg1_);
+  public final static native void pjsua_stream_stat_jbuf_set(long jarg1, pjsua_stream_stat jarg1_, long jarg2);
+  public final static native long pjsua_stream_stat_jbuf_get(long jarg1, pjsua_stream_stat jarg1_);
+  public final static native long new_pjsua_stream_stat();
+  public final static native void delete_pjsua_stream_stat(long jarg1);
+  public final static native void pjsua_call_vid_strm_op_param_med_idx_set(long jarg1, pjsua_call_vid_strm_op_param jarg1_, int jarg2);
+  public final static native int pjsua_call_vid_strm_op_param_med_idx_get(long jarg1, pjsua_call_vid_strm_op_param jarg1_);
+  public final static native void pjsua_call_vid_strm_op_param_dir_set(long jarg1, pjsua_call_vid_strm_op_param jarg1_, int jarg2);
+  public final static native int pjsua_call_vid_strm_op_param_dir_get(long jarg1, pjsua_call_vid_strm_op_param jarg1_);
+  public final static native void pjsua_call_vid_strm_op_param_cap_dev_set(long jarg1, pjsua_call_vid_strm_op_param jarg1_, long jarg2);
+  public final static native long pjsua_call_vid_strm_op_param_cap_dev_get(long jarg1, pjsua_call_vid_strm_op_param jarg1_);
+  public final static native long new_pjsua_call_vid_strm_op_param();
+  public final static native void delete_pjsua_call_vid_strm_op_param(long jarg1);
+  public final static native void call_setting_default(long jarg1, pjsua_call_setting jarg1_);
+  public final static native void call_vid_strm_op_param_default(long jarg1, pjsua_call_vid_strm_op_param jarg1_);
+  public final static native long call_get_max_count();
+  public final static native long call_get_count();
+  public final static native int enum_calls(int[] jarg1, long[] jarg2);
+  public final static native int call_make_call(int jarg1, long jarg2, pj_str_t jarg2_, long jarg3, pjsua_call_setting jarg3_, byte[] jarg4, long jarg5, pjsua_msg_data jarg5_, int[] jarg6);
+  public final static native int call_is_active(int jarg1);
+  public final static native int call_has_media(int jarg1);
+  public final static native int call_get_conf_port(int jarg1);
+  public final static native int call_get_info(int jarg1, long jarg2, pjsua_call_info jarg2_);
+  public final static native long call_remote_has_cap(int jarg1, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_);
+  public final static native int call_set_user_data(int jarg1, byte[] jarg2);
+  public final static native byte[] call_get_user_data(int jarg1);
+  public final static native int call_get_rem_nat_type(int jarg1, int[] jarg2);
+  public final static native int call_answer(int jarg1, long jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pjsua_msg_data jarg4_);
+  public final static native int call_answer2(int jarg1, long jarg2, pjsua_call_setting jarg2_, long jarg3, long jarg4, pj_str_t jarg4_, long jarg5, pjsua_msg_data jarg5_);
+  public final static native int call_hangup(int jarg1, long jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pjsua_msg_data jarg4_);
+  public final static native int call_process_redirect(int jarg1, int jarg2);
+  public final static native int call_set_hold(int jarg1, long jarg2, pjsua_msg_data jarg2_);
+  public final static native int call_set_hold2(int jarg1, long jarg2, long jarg3, pjsua_msg_data jarg3_);
+  public final static native int call_reinvite(int jarg1, long jarg2, long jarg3, pjsua_msg_data jarg3_);
+  public final static native int call_reinvite2(int jarg1, long jarg2, pjsua_call_setting jarg2_, long jarg3, pjsua_msg_data jarg3_);
+  public final static native int call_update(int jarg1, long jarg2, long jarg3, pjsua_msg_data jarg3_);
+  public final static native int call_update2(int jarg1, long jarg2, pjsua_call_setting jarg2_, long jarg3, pjsua_msg_data jarg3_);
+  public final static native int call_xfer(int jarg1, long jarg2, pj_str_t jarg2_, long jarg3, pjsua_msg_data jarg3_);
+  public final static native int PJSUA_XFER_NO_REQUIRE_REPLACES_get();
+  public final static native int call_xfer_replaces(int jarg1, int jarg2, long jarg3, long jarg4, pjsua_msg_data jarg4_);
+  public final static native int call_dial_dtmf(int jarg1, long jarg2, pj_str_t jarg2_);
+  public final static native int call_send_im(int jarg1, long jarg2, pj_str_t jarg2_, long jarg3, pj_str_t jarg3_, long jarg4, pjsua_msg_data jarg4_, byte[] jarg5);
+  public final static native int call_send_typing_ind(int jarg1, int jarg2, long jarg3, pjsua_msg_data jarg3_);
+  public final static native int call_send_request(int jarg1, long jarg2, pj_str_t jarg2_, long jarg3, pjsua_msg_data jarg3_);
+  public final static native void call_hangup_all();
+  public final static native int call_dump__SWIG_0(int jarg1, int jarg2, String jarg3, long jarg4, String jarg5);
+  public final static native int call_get_vid_stream_idx(int jarg1);
+  public final static native int call_vid_stream_is_running(int jarg1, int jarg2, int jarg3);
+  public final static native int call_set_vid_strm(int jarg1, int jarg2, long jarg3, pjsua_call_vid_strm_op_param jarg3_);
+  public final static native int call_get_stream_info(int jarg1, long jarg2, long jarg3, pjsua_stream_info jarg3_);
+  public final static native int call_get_stream_stat(int jarg1, long jarg2, long jarg3, pjsua_stream_stat jarg3_);
+  public final static native int call_get_med_transport_info(int jarg1, long jarg2, long jarg3);
+  public final static native int PJSUA_MAX_BUDDIES_get();
+  public final static native int PJSUA_PRES_TIMER_get();
+  public final static native void pjsua_buddy_config_uri_set(long jarg1, pjsua_buddy_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_buddy_config_uri_get(long jarg1, pjsua_buddy_config jarg1_);
+  public final static native void pjsua_buddy_config_subscribe_set(long jarg1, pjsua_buddy_config jarg1_, int jarg2);
+  public final static native int pjsua_buddy_config_subscribe_get(long jarg1, pjsua_buddy_config jarg1_);
+  public final static native void pjsua_buddy_config_user_data_set(long jarg1, pjsua_buddy_config jarg1_, byte[] jarg2);
+  public final static native byte[] pjsua_buddy_config_user_data_get(long jarg1, pjsua_buddy_config jarg1_);
+  public final static native long new_pjsua_buddy_config();
+  public final static native void delete_pjsua_buddy_config(long jarg1);
+  public final static native void pjsua_buddy_info_id_set(long jarg1, pjsua_buddy_info jarg1_, int jarg2);
+  public final static native int pjsua_buddy_info_id_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_uri_set(long jarg1, pjsua_buddy_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_buddy_info_uri_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_contact_set(long jarg1, pjsua_buddy_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_buddy_info_contact_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_status_set(long jarg1, pjsua_buddy_info jarg1_, int jarg2);
+  public final static native int pjsua_buddy_info_status_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_status_text_set(long jarg1, pjsua_buddy_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_buddy_info_status_text_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_monitor_pres_set(long jarg1, pjsua_buddy_info jarg1_, int jarg2);
+  public final static native int pjsua_buddy_info_monitor_pres_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_sub_state_set(long jarg1, pjsua_buddy_info jarg1_, long jarg2);
+  public final static native long pjsua_buddy_info_sub_state_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_sub_state_name_set(long jarg1, pjsua_buddy_info jarg1_, String jarg2);
+  public final static native String pjsua_buddy_info_sub_state_name_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_sub_term_code_set(long jarg1, pjsua_buddy_info jarg1_, long jarg2);
+  public final static native long pjsua_buddy_info_sub_term_code_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_sub_term_reason_set(long jarg1, pjsua_buddy_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_buddy_info_sub_term_reason_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_rpid_set(long jarg1, pjsua_buddy_info jarg1_, long jarg2, pjrpid_element jarg2_);
+  public final static native long pjsua_buddy_info_rpid_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_pres_status_set(long jarg1, pjsua_buddy_info jarg1_, long jarg2);
+  public final static native long pjsua_buddy_info_pres_status_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_buf__set(long jarg1, pjsua_buddy_info jarg1_, String jarg2);
+  public final static native String pjsua_buddy_info_buf__get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native long new_pjsua_buddy_info();
+  public final static native void delete_pjsua_buddy_info(long jarg1);
+  public final static native void buddy_config_default(long jarg1, pjsua_buddy_config jarg1_);
+  public final static native long get_buddy_count();
+  public final static native int buddy_is_valid(int jarg1);
+  public final static native int enum_buddies(int[] jarg1, long[] jarg2);
+  public final static native int buddy_find(long jarg1, pj_str_t jarg1_);
+  public final static native int buddy_get_info(int jarg1, long jarg2, pjsua_buddy_info jarg2_);
+  public final static native int buddy_set_user_data(int jarg1, byte[] jarg2);
+  public final static native byte[] buddy_get_user_data(int jarg1);
+  public final static native int buddy_add(long jarg1, pjsua_buddy_config jarg1_, int[] jarg2);
+  public final static native int buddy_del(int jarg1);
+  public final static native int buddy_subscribe_pres(int jarg1, int jarg2);
+  public final static native int buddy_update_pres(int jarg1);
+  public final static native int pres_notify(int jarg1, long jarg2, long jarg3, long jarg4, pj_str_t jarg4_, long jarg5, pj_str_t jarg5_, int jarg6, long jarg7, pjsua_msg_data jarg7_);
+  public final static native void pres_dump(int jarg1);
+  public final static native long pjsip_message_method_get();
+  public final static native long pjsip_info_method_get();
+  public final static native int im_send(int jarg1, long jarg2, pj_str_t jarg2_, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, long jarg5, pjsua_msg_data jarg5_, byte[] jarg6);
+  public final static native int im_typing(int jarg1, long jarg2, pj_str_t jarg2_, int jarg3, long jarg4, pjsua_msg_data jarg4_);
+  public final static native int PJSUA_MEDIA_HAS_PJMEDIA_get();
+  public final static native int PJSUA_THIRD_PARTY_STREAM_HAS_GET_INFO_get();
+  public final static native int PJSUA_THIRD_PARTY_STREAM_HAS_GET_STAT_get();
+  public final static native int PJSUA_MAX_CONF_PORTS_get();
+  public final static native int PJSUA_DEFAULT_CLOCK_RATE_get();
+  public final static native int PJSUA_DEFAULT_AUDIO_FRAME_PTIME_get();
+  public final static native int PJSUA_DEFAULT_CODEC_QUALITY_get();
+  public final static native int PJSUA_DEFAULT_ILBC_MODE_get();
+  public final static native int PJSUA_DEFAULT_EC_TAIL_LEN_get();
+  public final static native int PJSUA_MAX_PLAYERS_get();
+  public final static native int PJSUA_MAX_RECORDERS_get();
+  public final static native void pjsua_media_config_clock_rate_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_clock_rate_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_snd_clock_rate_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_snd_clock_rate_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_channel_count_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_channel_count_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_audio_frame_ptime_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_audio_frame_ptime_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_max_media_ports_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_max_media_ports_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_has_ioqueue_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_has_ioqueue_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_thread_cnt_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_thread_cnt_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_quality_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_quality_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_ptime_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_ptime_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_no_vad_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_no_vad_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_ilbc_mode_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_ilbc_mode_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_tx_drop_pct_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_tx_drop_pct_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_rx_drop_pct_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_rx_drop_pct_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_ec_options_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_ec_options_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_ec_tail_len_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_ec_tail_len_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_snd_rec_latency_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_snd_rec_latency_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_snd_play_latency_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_snd_play_latency_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_jb_init_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_jb_init_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_jb_min_pre_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_jb_min_pre_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_jb_max_pre_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_jb_max_pre_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_jb_max_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_jb_max_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_enable_ice_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_enable_ice_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_ice_max_host_cands_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_ice_max_host_cands_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_ice_opt_set(long jarg1, pjsua_media_config jarg1_, long jarg2, pj_ice_sess_options jarg2_);
+  public final static native long pjsua_media_config_ice_opt_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_ice_no_rtcp_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_ice_no_rtcp_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_ice_always_update_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_ice_always_update_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_enable_turn_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_enable_turn_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_turn_server_set(long jarg1, pjsua_media_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_media_config_turn_server_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_turn_conn_type_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_turn_conn_type_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_turn_auth_cred_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_turn_auth_cred_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_snd_auto_close_time_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_snd_auto_close_time_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_vid_preview_enable_native_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_vid_preview_enable_native_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_no_smart_media_update_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_no_smart_media_update_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_no_rtcp_sdes_bye_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_no_rtcp_sdes_bye_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native long new_pjsua_media_config();
+  public final static native void delete_pjsua_media_config(long jarg1);
+  public final static native void media_config_default(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_codec_info_codec_id_set(long jarg1, pjsua_codec_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_codec_info_codec_id_get(long jarg1, pjsua_codec_info jarg1_);
+  public final static native void pjsua_codec_info_priority_set(long jarg1, pjsua_codec_info jarg1_, short jarg2);
+  public final static native short pjsua_codec_info_priority_get(long jarg1, pjsua_codec_info jarg1_);
+  public final static native void pjsua_codec_info_desc_set(long jarg1, pjsua_codec_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_codec_info_desc_get(long jarg1, pjsua_codec_info jarg1_);
+  public final static native void pjsua_codec_info_buf__set(long jarg1, pjsua_codec_info jarg1_, String jarg2);
+  public final static native String pjsua_codec_info_buf__get(long jarg1, pjsua_codec_info jarg1_);
+  public final static native long new_pjsua_codec_info();
+  public final static native void delete_pjsua_codec_info(long jarg1);
+  public final static native void pjsua_conf_port_info_slot_id_set(long jarg1, pjsua_conf_port_info jarg1_, int jarg2);
+  public final static native int pjsua_conf_port_info_slot_id_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_name_set(long jarg1, pjsua_conf_port_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_conf_port_info_name_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_format_set(long jarg1, pjsua_conf_port_info jarg1_, long jarg2);
+  public final static native long pjsua_conf_port_info_format_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_clock_rate_set(long jarg1, pjsua_conf_port_info jarg1_, long jarg2);
+  public final static native long pjsua_conf_port_info_clock_rate_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_channel_count_set(long jarg1, pjsua_conf_port_info jarg1_, long jarg2);
+  public final static native long pjsua_conf_port_info_channel_count_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_samples_per_frame_set(long jarg1, pjsua_conf_port_info jarg1_, long jarg2);
+  public final static native long pjsua_conf_port_info_samples_per_frame_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_bits_per_sample_set(long jarg1, pjsua_conf_port_info jarg1_, long jarg2);
+  public final static native long pjsua_conf_port_info_bits_per_sample_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_tx_level_adj_set(long jarg1, pjsua_conf_port_info jarg1_, float jarg2);
+  public final static native float pjsua_conf_port_info_tx_level_adj_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_rx_level_adj_set(long jarg1, pjsua_conf_port_info jarg1_, float jarg2);
+  public final static native float pjsua_conf_port_info_rx_level_adj_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_listener_cnt_set(long jarg1, pjsua_conf_port_info jarg1_, long jarg2);
+  public final static native long pjsua_conf_port_info_listener_cnt_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_listeners_set(long jarg1, pjsua_conf_port_info jarg1_, int[] jarg2);
+  public final static native int[] pjsua_conf_port_info_listeners_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native long new_pjsua_conf_port_info();
+  public final static native void delete_pjsua_conf_port_info(long jarg1);
+  public final static native void pjsua_media_transport_skinfo_set(long jarg1, pjsua_media_transport jarg1_, long jarg2);
+  public final static native long pjsua_media_transport_skinfo_get(long jarg1, pjsua_media_transport jarg1_);
+  public final static native void pjsua_media_transport_transport_set(long jarg1, pjsua_media_transport jarg1_, long jarg2);
+  public final static native long pjsua_media_transport_transport_get(long jarg1, pjsua_media_transport jarg1_);
+  public final static native long new_pjsua_media_transport();
+  public final static native void delete_pjsua_media_transport(long jarg1);
+  public final static native long conf_get_max_ports();
+  public final static native long conf_get_active_ports();
+  public final static native int enum_conf_ports(int[] jarg1, long[] jarg2);
+  public final static native int conf_get_port_info(int jarg1, long jarg2, pjsua_conf_port_info jarg2_);
+  public final static native int conf_add_port(long jarg1, pj_pool_t jarg1_, long jarg2, pjmedia_port jarg2_, int[] jarg3);
+  public final static native int conf_remove_port(int jarg1);
+  public final static native int conf_connect(int jarg1, int jarg2);
+  public final static native int conf_disconnect(int jarg1, int jarg2);
+  public final static native int conf_adjust_tx_level(int jarg1, float jarg2);
+  public final static native int conf_adjust_rx_level(int jarg1, float jarg2);
+  public final static native int conf_get_signal_level(int jarg1, long[] jarg2, long[] jarg3);
+  public final static native int player_create(long jarg1, pj_str_t jarg1_, long jarg2, int[] jarg3);
+  public final static native int playlist_create(long[] jarg1, long jarg2, long jarg3, pj_str_t jarg3_, long jarg4, int[] jarg5);
+  public final static native int player_get_conf_port(int jarg1);
+  public final static native int player_get_port(int jarg1, long jarg2);
+  public final static native int player_get_info(int jarg1, long jarg2);
+  public final static native int player_get_pos(int jarg1);
+  public final static native int player_set_pos(int jarg1, long jarg2);
+  public final static native int player_destroy(int jarg1);
+  public final static native int recorder_create(long jarg1, pj_str_t jarg1_, long jarg2, byte[] jarg3, int jarg4, long jarg5, int[] jarg6);
+  public final static native int recorder_get_conf_port(int jarg1);
+  public final static native int recorder_get_port(int jarg1, long jarg2);
+  public final static native int recorder_destroy(int jarg1);
+  public final static native int enum_aud_devs(long jarg1, long[] jarg2);
+  public final static native int enum_snd_devs(long jarg1, pjmedia_snd_dev_info jarg1_, long[] jarg2);
+  public final static native int get_snd_dev(int[] jarg1, int[] jarg2);
+  public final static native int set_snd_dev(int jarg1, int jarg2);
+  public final static native int set_null_snd_dev();
+  public final static native long set_no_snd_dev();
+  public final static native int set_ec(long jarg1, long jarg2);
+  public final static native int get_ec_tail(long jarg1);
+  public final static native int snd_is_active();
+  public final static native int snd_set_setting(long jarg1, byte[] jarg2, int jarg3);
+  public final static native int snd_get_setting(long jarg1, byte[] jarg2);
+  public final static native int enum_codecs(long jarg1, pjsua_codec_info jarg1_, long[] jarg2);
+  public final static native int codec_set_priority(long jarg1, pj_str_t jarg1_, short jarg2);
+  public final static native int codec_get_param(long jarg1, pj_str_t jarg1_, long jarg2);
+  public final static native int codec_set_param(long jarg1, pj_str_t jarg1_, long jarg2);
+  public final static native long vid_dev_count();
+  public final static native int vid_dev_get_info(long jarg1, long jarg2);
+  public final static native int vid_enum_devs(long jarg1, long[] jarg2);
+  public final static native void pjsua_vid_preview_param_rend_id_set(long jarg1, pjsua_vid_preview_param jarg1_, long jarg2);
+  public final static native long pjsua_vid_preview_param_rend_id_get(long jarg1, pjsua_vid_preview_param jarg1_);
+  public final static native void pjsua_vid_preview_param_show_set(long jarg1, pjsua_vid_preview_param jarg1_, int jarg2);
+  public final static native int pjsua_vid_preview_param_show_get(long jarg1, pjsua_vid_preview_param jarg1_);
+  public final static native void pjsua_vid_preview_param_wnd_flags_set(long jarg1, pjsua_vid_preview_param jarg1_, long jarg2);
+  public final static native long pjsua_vid_preview_param_wnd_flags_get(long jarg1, pjsua_vid_preview_param jarg1_);
+  public final static native void pjsua_vid_preview_param_format_set(long jarg1, pjsua_vid_preview_param jarg1_, long jarg2);
+  public final static native long pjsua_vid_preview_param_format_get(long jarg1, pjsua_vid_preview_param jarg1_);
+  public final static native long new_pjsua_vid_preview_param();
+  public final static native void delete_pjsua_vid_preview_param(long jarg1);
+  public final static native void vid_preview_param_default(long jarg1, pjsua_vid_preview_param jarg1_);
+  public final static native int vid_preview_has_native(long jarg1);
+  public final static native int vid_preview_start(long jarg1, long jarg2, pjsua_vid_preview_param jarg2_);
+  public final static native int vid_preview_get_win(long jarg1);
+  public final static native int vid_preview_stop(long jarg1);
+  public final static native void pjsua_vid_win_info_is_native_set(long jarg1, pjsua_vid_win_info jarg1_, int jarg2);
+  public final static native int pjsua_vid_win_info_is_native_get(long jarg1, pjsua_vid_win_info jarg1_);
+  public final static native void pjsua_vid_win_info_hwnd_set(long jarg1, pjsua_vid_win_info jarg1_, long jarg2);
+  public final static native long pjsua_vid_win_info_hwnd_get(long jarg1, pjsua_vid_win_info jarg1_);
+  public final static native void pjsua_vid_win_info_rdr_dev_set(long jarg1, pjsua_vid_win_info jarg1_, long jarg2);
+  public final static native long pjsua_vid_win_info_rdr_dev_get(long jarg1, pjsua_vid_win_info jarg1_);
+  public final static native void pjsua_vid_win_info_show_set(long jarg1, pjsua_vid_win_info jarg1_, int jarg2);
+  public final static native int pjsua_vid_win_info_show_get(long jarg1, pjsua_vid_win_info jarg1_);
+  public final static native void pjsua_vid_win_info_pos_set(long jarg1, pjsua_vid_win_info jarg1_, long jarg2);
+  public final static native long pjsua_vid_win_info_pos_get(long jarg1, pjsua_vid_win_info jarg1_);
+  public final static native void pjsua_vid_win_info_size_set(long jarg1, pjsua_vid_win_info jarg1_, long jarg2);
+  public final static native long pjsua_vid_win_info_size_get(long jarg1, pjsua_vid_win_info jarg1_);
+  public final static native long new_pjsua_vid_win_info();
+  public final static native void delete_pjsua_vid_win_info(long jarg1);
+  public final static native int vid_enum_wins(int[] jarg1, long[] jarg2);
+  public final static native int vid_win_get_info(int jarg1, long jarg2, pjsua_vid_win_info jarg2_);
+  public final static native int vid_win_set_show(int jarg1, int jarg2);
+  public final static native int vid_win_set_pos(int jarg1, long jarg2);
+  public final static native int vid_win_set_size(int jarg1, long jarg2);
+  public final static native int vid_win_rotate(int jarg1, int jarg2);
+  public final static native int vid_enum_codecs(long jarg1, pjsua_codec_info jarg1_, long[] jarg2);
+  public final static native int vid_codec_set_priority(long jarg1, pj_str_t jarg1_, short jarg2);
+  public final static native int vid_codec_get_param(long jarg1, pj_str_t jarg1_, long jarg2);
+  public final static native int vid_codec_set_param(long jarg1, pj_str_t jarg1_, long jarg2);
+  public final static native void dynamic_factory_shared_lib_path_set(long jarg1, dynamic_factory jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long dynamic_factory_shared_lib_path_get(long jarg1, dynamic_factory jarg1_);
+  public final static native void dynamic_factory_init_factory_name_set(long jarg1, dynamic_factory jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long dynamic_factory_init_factory_name_get(long jarg1, dynamic_factory jarg1_);
+  public final static native long new_dynamic_factory();
+  public final static native void delete_dynamic_factory(long jarg1);
+  public final static native void csipsimple_config_use_compact_form_sdp_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_use_compact_form_sdp_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_use_compact_form_headers_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_use_compact_form_headers_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_add_bandwidth_tias_in_sdp_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_add_bandwidth_tias_in_sdp_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_use_no_update_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_use_no_update_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_use_zrtp_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_use_zrtp_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_extra_aud_codecs_cnt_set(long jarg1, csipsimple_config jarg1_, long jarg2);
+  public final static native long csipsimple_config_extra_aud_codecs_cnt_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_extra_aud_codecs_set(long jarg1, csipsimple_config jarg1_, long[] jarg2);
+  public final static native long[] csipsimple_config_extra_aud_codecs_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_extra_vid_codecs_cnt_set(long jarg1, csipsimple_config jarg1_, long jarg2);
+  public final static native long csipsimple_config_extra_vid_codecs_cnt_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_extra_vid_codecs_set(long jarg1, csipsimple_config jarg1_, long[] jarg2);
+  public final static native long[] csipsimple_config_extra_vid_codecs_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_extra_vid_codecs_destroy_set(long jarg1, csipsimple_config jarg1_, long[] jarg2);
+  public final static native long[] csipsimple_config_extra_vid_codecs_destroy_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_vid_converter_set(long jarg1, csipsimple_config jarg1_, long jarg2, dynamic_factory jarg2_);
+  public final static native long csipsimple_config_vid_converter_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_storage_folder_set(long jarg1, csipsimple_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long csipsimple_config_storage_folder_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_audio_implementation_set(long jarg1, csipsimple_config jarg1_, long jarg2, dynamic_factory jarg2_);
+  public final static native long csipsimple_config_audio_implementation_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_video_render_implementation_set(long jarg1, csipsimple_config jarg1_, long jarg2, dynamic_factory jarg2_);
+  public final static native long csipsimple_config_video_render_implementation_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_video_capture_implementation_set(long jarg1, csipsimple_config jarg1_, long jarg2, dynamic_factory jarg2_);
+  public final static native long csipsimple_config_video_capture_implementation_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_tcp_keep_alive_interval_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_tcp_keep_alive_interval_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_tls_keep_alive_interval_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_tls_keep_alive_interval_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_tsx_t1_timeout_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_tsx_t1_timeout_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_tsx_t2_timeout_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_tsx_t2_timeout_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_tsx_t4_timeout_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_tsx_t4_timeout_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_tsx_td_timeout_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_tsx_td_timeout_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_disable_tcp_switch_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_disable_tcp_switch_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_disable_rport_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_disable_rport_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_use_noise_suppressor_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_use_noise_suppressor_get(long jarg1, csipsimple_config jarg1_);
+  public final static native long new_csipsimple_config();
+  public final static native void delete_csipsimple_config(long jarg1);
+  public final static native void csipsimple_acc_config_use_zrtp_set(long jarg1, csipsimple_acc_config jarg1_, int jarg2);
+  public final static native int csipsimple_acc_config_use_zrtp_get(long jarg1, csipsimple_acc_config jarg1_);
+  public final static native void csipsimple_acc_config_p_preferred_identity_set(long jarg1, csipsimple_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long csipsimple_acc_config_p_preferred_identity_get(long jarg1, csipsimple_acc_config jarg1_);
+  public final static native long new_csipsimple_acc_config();
+  public final static native void delete_csipsimple_acc_config(long jarg1);
+  public final static native int send_dtmf_info(int jarg1, long jarg2, pj_str_t jarg2_);
+  public final static native long call_dump__SWIG_1(int jarg1, int jarg2, String jarg3);
+  public final static native long call_secure_media_info(int jarg1);
+  public final static native int call_secure_sig_level(int jarg1);
+  public final static native long get_error_message(int jarg1);
+  public final static native int get_event_status_code(long jarg1, pjsip_event jarg1_);
+  public final static native int get_event_reason_code(long jarg1, pjsip_event jarg1_);
+  public final static native void csipsimple_config_default(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_acc_config_default(long jarg1, csipsimple_acc_config jarg1_);
+  public final static native int csipsimple_init(long jarg1, pjsua_config jarg1_, long jarg2, pjsua_logging_config jarg2_, long jarg3, pjsua_media_config jarg3_, long jarg4, csipsimple_config jarg4_, Object jarg5);
+  public final static native int csipsimple_destroy(long jarg1);
+  public final static native int csipsimple_set_acc_user_data(int jarg1, long jarg2, csipsimple_acc_config jarg2_);
+  public final static native int csipsimple_init_acc_msg_data(long jarg1, pj_pool_t jarg1_, int jarg2, long jarg3, pjsua_msg_data jarg3_);
+  public final static native int csipsimple_msg_data_add_string_hdr(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_msg_data jarg2_, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_);
+  public final static native int pj_timer_fire(int jarg1);
+  public final static native int update_transport(long jarg1, pj_str_t jarg1_);
+  public final static native int vid_set_android_renderer(int jarg1, Object jarg2);
+  public final static native int vid_set_android_capturer(Object jarg1);
+  public final static native int set_turn_credentials(long jarg1, pj_str_t jarg1_, long jarg2, pj_str_t jarg2_, long jarg3, pj_str_t jarg3_, long jarg4);
+  public final static native long get_rx_data_header(long jarg1, pj_str_t jarg1_, long jarg2);
+  public final static native void css_on_call_state(int jarg1, long jarg2, pjsip_event jarg2_);
+  public final static native void css_on_call_media_state(int jarg1);
+  public final static native void zrtp_state_info_call_id_set(long jarg1, zrtp_state_info jarg1_, int jarg2);
+  public final static native int zrtp_state_info_call_id_get(long jarg1, zrtp_state_info jarg1_);
+  public final static native void zrtp_state_info_secure_set(long jarg1, zrtp_state_info jarg1_, int jarg2);
+  public final static native int zrtp_state_info_secure_get(long jarg1, zrtp_state_info jarg1_);
+  public final static native void zrtp_state_info_sas_set(long jarg1, zrtp_state_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long zrtp_state_info_sas_get(long jarg1, zrtp_state_info jarg1_);
+  public final static native void zrtp_state_info_cipher_set(long jarg1, zrtp_state_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long zrtp_state_info_cipher_get(long jarg1, zrtp_state_info jarg1_);
+  public final static native void zrtp_state_info_sas_verified_set(long jarg1, zrtp_state_info jarg1_, int jarg2);
+  public final static native int zrtp_state_info_sas_verified_get(long jarg1, zrtp_state_info jarg1_);
+  public final static native long new_zrtp_state_info();
+  public final static native void delete_zrtp_state_info(long jarg1);
+  public final static native void jzrtp_SASVerified(int jarg1);
+  public final static native void jzrtp_SASRevoked(int jarg1);
+  public final static native long jzrtp_getInfoFromCall(int jarg1);
+  public final static native int codecs_get_nbr();
+  public final static native long codecs_get_id(int jarg1);
+  public final static native int codecs_vid_get_nbr();
+  public final static native long codecs_vid_get_id(int jarg1);
+  public final static native int codec_set_frames_per_packet(long jarg1, pj_str_t jarg1_, int jarg2);
+  public final static native int codec_h264_set_profile(long jarg1, long jarg2, long jarg3, long jarg4, long jarg5, long jarg6, long jarg7);
+
+  public static void SwigDirector_Callback_on_call_state(Callback self, int call_id, long e) {
+    self.on_call_state(call_id, (e == 0) ? null : new pjsip_event(e, false));
+  }
+  public static void SwigDirector_Callback_on_incoming_call(Callback self, int acc_id, int call_id, long rdata) {
+    self.on_incoming_call(acc_id, call_id, (rdata == 0) ? null : new SWIGTYPE_p_pjsip_rx_data(rdata, false));
+  }
+  public static void SwigDirector_Callback_on_call_tsx_state(Callback self, int call_id, long tsx, long e) {
+    self.on_call_tsx_state(call_id, (tsx == 0) ? null : new SWIGTYPE_p_pjsip_transaction(tsx, false), (e == 0) ? null : new pjsip_event(e, false));
+  }
+  public static void SwigDirector_Callback_on_call_media_state(Callback self, int call_id) {
+    self.on_call_media_state(call_id);
+  }
+  public static void SwigDirector_Callback_on_call_sdp_created(Callback self, int call_id, long sdp, long pool, long rem_sdp) {
+    self.on_call_sdp_created(call_id, (sdp == 0) ? null : new SWIGTYPE_p_pjmedia_sdp_session(sdp, false), (pool == 0) ? null : new pj_pool_t(pool, false), (rem_sdp == 0) ? null : new SWIGTYPE_p_pjmedia_sdp_session(rem_sdp, false));
+  }
+  public static void SwigDirector_Callback_on_stream_created(Callback self, int call_id, long strm, long stream_idx, long p_port) {
+    self.on_stream_created(call_id, (strm == 0) ? null : new SWIGTYPE_p_pjmedia_stream(strm, false), stream_idx, (p_port == 0) ? null : new SWIGTYPE_p_p_pjmedia_port(p_port, false));
+  }
+  public static void SwigDirector_Callback_on_stream_destroyed(Callback self, int call_id, long strm, long stream_idx) {
+    self.on_stream_destroyed(call_id, (strm == 0) ? null : new SWIGTYPE_p_pjmedia_stream(strm, false), stream_idx);
+  }
+  public static void SwigDirector_Callback_on_dtmf_digit(Callback self, int call_id, int digit) {
+    self.on_dtmf_digit(call_id, digit);
+  }
+  public static void SwigDirector_Callback_on_call_transfer_request(Callback self, int call_id, long dst, long code) {
+    self.on_call_transfer_request(call_id, (dst == 0) ? null : new pj_str_t(dst, false), (code == 0) ? null : new SWIGTYPE_p_pjsip_status_code(code, false));
+  }
+  public static void SwigDirector_Callback_on_call_transfer_status(Callback self, int call_id, int st_code, long st_text, int final_, long p_cont) {
+    self.on_call_transfer_status(call_id, st_code, (st_text == 0) ? null : new pj_str_t(st_text, false), final_, (p_cont == 0) ? null : new SWIGTYPE_p_int(p_cont, false));
+  }
+  public static void SwigDirector_Callback_on_call_replace_request(Callback self, int call_id, long rdata, long st_code, long st_text) {
+    self.on_call_replace_request(call_id, (rdata == 0) ? null : new SWIGTYPE_p_pjsip_rx_data(rdata, false), (st_code == 0) ? null : new SWIGTYPE_p_int(st_code, false), (st_text == 0) ? null : new pj_str_t(st_text, false));
+  }
+  public static void SwigDirector_Callback_on_call_replaced(Callback self, int old_call_id, int new_call_id) {
+    self.on_call_replaced(old_call_id, new_call_id);
+  }
+  public static void SwigDirector_Callback_on_reg_state(Callback self, int acc_id) {
+    self.on_reg_state(acc_id);
+  }
+  public static void SwigDirector_Callback_on_buddy_state(Callback self, int buddy_id) {
+    self.on_buddy_state(buddy_id);
+  }
+  public static void SwigDirector_Callback_on_pager(Callback self, int call_id, long from, long to, long contact, long mime_type, long body) {
+    self.on_pager(call_id, (from == 0) ? null : new pj_str_t(from, false), (to == 0) ? null : new pj_str_t(to, false), (contact == 0) ? null : new pj_str_t(contact, false), (mime_type == 0) ? null : new pj_str_t(mime_type, false), (body == 0) ? null : new pj_str_t(body, false));
+  }
+  public static void SwigDirector_Callback_on_pager2(Callback self, int call_id, long from, long to, long contact, long mime_type, long body, long rdata) {
+    self.on_pager2(call_id, (from == 0) ? null : new pj_str_t(from, false), (to == 0) ? null : new pj_str_t(to, false), (contact == 0) ? null : new pj_str_t(contact, false), (mime_type == 0) ? null : new pj_str_t(mime_type, false), (body == 0) ? null : new pj_str_t(body, false), (rdata == 0) ? null : new SWIGTYPE_p_pjsip_rx_data(rdata, false));
+  }
+  public static void SwigDirector_Callback_on_pager_status(Callback self, int call_id, long to, long body, int status, long reason) {
+    self.on_pager_status(call_id, (to == 0) ? null : new pj_str_t(to, false), (body == 0) ? null : new pj_str_t(body, false), pjsip_status_code.swigToEnum(status), (reason == 0) ? null : new pj_str_t(reason, false));
+  }
+  public static void SwigDirector_Callback_on_pager_status2(Callback self, int call_id, long to, long body, int status, long reason, long tdata, long rdata) {
+    self.on_pager_status2(call_id, (to == 0) ? null : new pj_str_t(to, false), (body == 0) ? null : new pj_str_t(body, false), pjsip_status_code.swigToEnum(status), (reason == 0) ? null : new pj_str_t(reason, false), (tdata == 0) ? null : new SWIGTYPE_p_pjsip_tx_data(tdata, false), (rdata == 0) ? null : new SWIGTYPE_p_pjsip_rx_data(rdata, false));
+  }
+  public static void SwigDirector_Callback_on_typing(Callback self, int call_id, long from, long to, long contact, int is_typing) {
+    self.on_typing(call_id, (from == 0) ? null : new pj_str_t(from, false), (to == 0) ? null : new pj_str_t(to, false), (contact == 0) ? null : new pj_str_t(contact, false), is_typing);
+  }
+  public static void SwigDirector_Callback_on_nat_detect(Callback self, long res) {
+    self.on_nat_detect((res == 0) ? null : new pj_stun_nat_detect_result(res, false));
+  }
+  public static int SwigDirector_Callback_on_call_redirected(Callback self, int call_id, long target) {
+    return (self.on_call_redirected(call_id, (target == 0) ? null : new pj_str_t(target, false))).swigValue();
+  }
+  public static void SwigDirector_Callback_on_mwi_info(Callback self, int acc_id, long mime_type, long body) {
+    self.on_mwi_info(acc_id, (mime_type == 0) ? null : new pj_str_t(mime_type, false), (body == 0) ? null : new pj_str_t(body, false));
+  }
+  public static void SwigDirector_Callback_on_call_media_transport_state(Callback self, int call_id, long info) {
+    self.on_call_media_transport_state(call_id, (info == 0) ? null : new pjsua_med_tp_state_info(info, false));
+  }
+  public static int SwigDirector_Callback_on_validate_audio_clock_rate(Callback self, int clock_rate) {
+    return self.on_validate_audio_clock_rate(clock_rate);
+  }
+  public static void SwigDirector_Callback_on_setup_audio(Callback self, int before_init) {
+    self.on_setup_audio(before_init);
+  }
+  public static void SwigDirector_Callback_on_teardown_audio(Callback self) {
+    self.on_teardown_audio();
+  }
+  public static int SwigDirector_Callback_on_set_micro_source(Callback self) {
+    return self.on_set_micro_source();
+  }
+  public static int SwigDirector_Callback_timer_schedule(Callback self, int entry, int entryId, int time) {
+    return self.timer_schedule(entry, entryId, time);
+  }
+  public static int SwigDirector_Callback_timer_cancel(Callback self, int entry, int entryId) {
+    return self.timer_cancel(entry, entryId);
+  }
+  public static void SwigDirector_ZrtpCallback_on_zrtp_show_sas(ZrtpCallback self, int call_id, long sas, int verified) {
+    self.on_zrtp_show_sas(call_id, (sas == 0) ? null : new pj_str_t(sas, false), verified);
+  }
+  public static void SwigDirector_ZrtpCallback_on_zrtp_update_transport(ZrtpCallback self, int call_id) {
+    self.on_zrtp_update_transport(call_id);
+  }
+  public static void SwigDirector_MobileRegHandlerCallback_on_save_contact(MobileRegHandlerCallback self, int acc_id, long contact, int expires) {
+    self.on_save_contact(acc_id, new pj_str_t(contact, false), expires);
+  }
+  public static long SwigDirector_MobileRegHandlerCallback_on_restore_contact(MobileRegHandlerCallback self, int acc_id) {
+    return pj_str_t.getCPtr(self.on_restore_contact(acc_id));
+  }
+  public static void SwigDirector_EarlyLockCallback_on_create_early_lock(EarlyLockCallback self) {
+    self.on_create_early_lock();
+  }
+
+  private final static native void swig_module_init();
+  static {
+    swig_module_init();
+  }
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_100rel_use.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_100rel_use.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_100rel_use.java	(working copy)
@@ -0,0 +1,53 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_100rel_use {
+  PJSUA_100REL_NOT_USED,
+  PJSUA_100REL_MANDATORY,
+  PJSUA_100REL_OPTIONAL;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_100rel_use swigToEnum(int swigValue) {
+    pjsua_100rel_use[] swigValues = pjsua_100rel_use.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_100rel_use swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_100rel_use.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_100rel_use() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_100rel_use(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_100rel_use(pjsua_100rel_use swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_acc_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_acc_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_acc_config.java	(working copy)
@@ -0,0 +1,553 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_acc_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_acc_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_acc_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_acc_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setUser_data(byte[] value) {
+    pjsuaJNI.pjsua_acc_config_user_data_set(swigCPtr, this, value);
+  }
+
+  public byte[] getUser_data() {
+	return pjsuaJNI.pjsua_acc_config_user_data_get(swigCPtr, this);
+}
+
+  public void setPriority(int value) {
+    pjsuaJNI.pjsua_acc_config_priority_set(swigCPtr, this, value);
+  }
+
+  public int getPriority() {
+    return pjsuaJNI.pjsua_acc_config_priority_get(swigCPtr, this);
+  }
+
+  public void setId(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_id_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getId() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_id_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setReg_uri(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_reg_uri_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getReg_uri() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_reg_uri_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setReg_hdr_list(SWIGTYPE_p_pjsip_hdr value) {
+    pjsuaJNI.pjsua_acc_config_reg_hdr_list_set(swigCPtr, this, SWIGTYPE_p_pjsip_hdr.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_hdr getReg_hdr_list() {
+    return new SWIGTYPE_p_pjsip_hdr(pjsuaJNI.pjsua_acc_config_reg_hdr_list_get(swigCPtr, this), true);
+  }
+
+  public void setSub_hdr_list(SWIGTYPE_p_pjsip_hdr value) {
+    pjsuaJNI.pjsua_acc_config_sub_hdr_list_set(swigCPtr, this, SWIGTYPE_p_pjsip_hdr.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_hdr getSub_hdr_list() {
+    return new SWIGTYPE_p_pjsip_hdr(pjsuaJNI.pjsua_acc_config_sub_hdr_list_get(swigCPtr, this), true);
+  }
+
+  public void setMwi_enabled(int value) {
+    pjsuaJNI.pjsua_acc_config_mwi_enabled_set(swigCPtr, this, value);
+  }
+
+  public int getMwi_enabled() {
+    return pjsuaJNI.pjsua_acc_config_mwi_enabled_get(swigCPtr, this);
+  }
+
+  public void setMwi_expires(long value) {
+    pjsuaJNI.pjsua_acc_config_mwi_expires_set(swigCPtr, this, value);
+  }
+
+  public long getMwi_expires() {
+    return pjsuaJNI.pjsua_acc_config_mwi_expires_get(swigCPtr, this);
+  }
+
+  public void setPublish_enabled(int value) {
+    pjsuaJNI.pjsua_acc_config_publish_enabled_set(swigCPtr, this, value);
+  }
+
+  public int getPublish_enabled() {
+    return pjsuaJNI.pjsua_acc_config_publish_enabled_get(swigCPtr, this);
+  }
+
+  public void setPublish_opt(SWIGTYPE_p_pjsip_publishc_opt value) {
+    pjsuaJNI.pjsua_acc_config_publish_opt_set(swigCPtr, this, SWIGTYPE_p_pjsip_publishc_opt.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_publishc_opt getPublish_opt() {
+    return new SWIGTYPE_p_pjsip_publishc_opt(pjsuaJNI.pjsua_acc_config_publish_opt_get(swigCPtr, this), true);
+  }
+
+  public void setUnpublish_max_wait_time_msec(long value) {
+    pjsuaJNI.pjsua_acc_config_unpublish_max_wait_time_msec_set(swigCPtr, this, value);
+  }
+
+  public long getUnpublish_max_wait_time_msec() {
+    return pjsuaJNI.pjsua_acc_config_unpublish_max_wait_time_msec_get(swigCPtr, this);
+  }
+
+  public void setAuth_pref(pjsip_auth_clt_pref value) {
+    pjsuaJNI.pjsua_acc_config_auth_pref_set(swigCPtr, this, pjsip_auth_clt_pref.getCPtr(value), value);
+  }
+
+  public pjsip_auth_clt_pref getAuth_pref() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_auth_pref_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsip_auth_clt_pref(cPtr, false);
+  }
+
+  public void setPidf_tuple_id(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_pidf_tuple_id_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getPidf_tuple_id() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_pidf_tuple_id_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setForce_contact(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_force_contact_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getForce_contact() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_force_contact_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setContact_params(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_contact_params_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getContact_params() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_contact_params_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setContact_uri_params(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_contact_uri_params_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getContact_uri_params() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_contact_uri_params_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setRequire_100rel(pjsua_100rel_use value) {
+    pjsuaJNI.pjsua_acc_config_require_100rel_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_100rel_use getRequire_100rel() {
+    return pjsua_100rel_use.swigToEnum(pjsuaJNI.pjsua_acc_config_require_100rel_get(swigCPtr, this));
+  }
+
+  public void setUse_timer(pjsua_sip_timer_use value) {
+    pjsuaJNI.pjsua_acc_config_use_timer_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_sip_timer_use getUse_timer() {
+    return pjsua_sip_timer_use.swigToEnum(pjsuaJNI.pjsua_acc_config_use_timer_get(swigCPtr, this));
+  }
+
+  public void setTimer_setting(pjsip_timer_setting value) {
+    pjsuaJNI.pjsua_acc_config_timer_setting_set(swigCPtr, this, pjsip_timer_setting.getCPtr(value), value);
+  }
+
+  public pjsip_timer_setting getTimer_setting() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_timer_setting_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsip_timer_setting(cPtr, false);
+  }
+
+  public void setProxy_cnt(long value) {
+    pjsuaJNI.pjsua_acc_config_proxy_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getProxy_cnt() {
+    return pjsuaJNI.pjsua_acc_config_proxy_cnt_get(swigCPtr, this);
+  }
+
+  public void setProxy(pj_str_t[] value) {
+    pjsuaJNI.pjsua_acc_config_proxy_set(swigCPtr, this, pj_str_t.cArrayUnwrap(value));
+  }
+
+  public pj_str_t[] getProxy() {
+    return pj_str_t.cArrayWrap(pjsuaJNI.pjsua_acc_config_proxy_get(swigCPtr, this), false);
+  }
+
+  public void setLock_codec(long value) {
+    pjsuaJNI.pjsua_acc_config_lock_codec_set(swigCPtr, this, value);
+  }
+
+  public long getLock_codec() {
+    return pjsuaJNI.pjsua_acc_config_lock_codec_get(swigCPtr, this);
+  }
+
+  public void setReg_timeout(long value) {
+    pjsuaJNI.pjsua_acc_config_reg_timeout_set(swigCPtr, this, value);
+  }
+
+  public long getReg_timeout() {
+    return pjsuaJNI.pjsua_acc_config_reg_timeout_get(swigCPtr, this);
+  }
+
+  public void setReg_delay_before_refresh(long value) {
+    pjsuaJNI.pjsua_acc_config_reg_delay_before_refresh_set(swigCPtr, this, value);
+  }
+
+  public long getReg_delay_before_refresh() {
+    return pjsuaJNI.pjsua_acc_config_reg_delay_before_refresh_get(swigCPtr, this);
+  }
+
+  public void setUnreg_timeout(long value) {
+    pjsuaJNI.pjsua_acc_config_unreg_timeout_set(swigCPtr, this, value);
+  }
+
+  public long getUnreg_timeout() {
+    return pjsuaJNI.pjsua_acc_config_unreg_timeout_get(swigCPtr, this);
+  }
+
+  public void setCred_count(long value) {
+    pjsuaJNI.pjsua_acc_config_cred_count_set(swigCPtr, this, value);
+  }
+
+  public long getCred_count() {
+    return pjsuaJNI.pjsua_acc_config_cred_count_get(swigCPtr, this);
+  }
+
+  public void setCred_info(pjsip_cred_info value) {
+    pjsuaJNI.pjsua_acc_config_cred_info_set(swigCPtr, this, pjsip_cred_info.getCPtr(value), value);
+  }
+
+  public pjsip_cred_info getCred_info() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_cred_info_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsip_cred_info(cPtr, false);
+  }
+
+  public void setTransport_id(int value) {
+    pjsuaJNI.pjsua_acc_config_transport_id_set(swigCPtr, this, value);
+  }
+
+  public int getTransport_id() {
+    return pjsuaJNI.pjsua_acc_config_transport_id_get(swigCPtr, this);
+  }
+
+  public void setAllow_contact_rewrite(int value) {
+    pjsuaJNI.pjsua_acc_config_allow_contact_rewrite_set(swigCPtr, this, value);
+  }
+
+  public int getAllow_contact_rewrite() {
+    return pjsuaJNI.pjsua_acc_config_allow_contact_rewrite_get(swigCPtr, this);
+  }
+
+  public void setContact_rewrite_method(int value) {
+    pjsuaJNI.pjsua_acc_config_contact_rewrite_method_set(swigCPtr, this, value);
+  }
+
+  public int getContact_rewrite_method() {
+    return pjsuaJNI.pjsua_acc_config_contact_rewrite_method_get(swigCPtr, this);
+  }
+
+  public void setContact_use_src_port(int value) {
+    pjsuaJNI.pjsua_acc_config_contact_use_src_port_set(swigCPtr, this, value);
+  }
+
+  public int getContact_use_src_port() {
+    return pjsuaJNI.pjsua_acc_config_contact_use_src_port_get(swigCPtr, this);
+  }
+
+  public void setAllow_via_rewrite(int value) {
+    pjsuaJNI.pjsua_acc_config_allow_via_rewrite_set(swigCPtr, this, value);
+  }
+
+  public int getAllow_via_rewrite() {
+    return pjsuaJNI.pjsua_acc_config_allow_via_rewrite_get(swigCPtr, this);
+  }
+
+  public void setAllow_sdp_nat_rewrite(int value) {
+    pjsuaJNI.pjsua_acc_config_allow_sdp_nat_rewrite_set(swigCPtr, this, value);
+  }
+
+  public int getAllow_sdp_nat_rewrite() {
+    return pjsuaJNI.pjsua_acc_config_allow_sdp_nat_rewrite_get(swigCPtr, this);
+  }
+
+  public void setUse_rfc5626(long value) {
+    pjsuaJNI.pjsua_acc_config_use_rfc5626_set(swigCPtr, this, value);
+  }
+
+  public long getUse_rfc5626() {
+    return pjsuaJNI.pjsua_acc_config_use_rfc5626_get(swigCPtr, this);
+  }
+
+  public void setRfc5626_instance_id(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_rfc5626_instance_id_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getRfc5626_instance_id() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_rfc5626_instance_id_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setRfc5626_reg_id(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_rfc5626_reg_id_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getRfc5626_reg_id() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_rfc5626_reg_id_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setKa_interval(long value) {
+    pjsuaJNI.pjsua_acc_config_ka_interval_set(swigCPtr, this, value);
+  }
+
+  public long getKa_interval() {
+    return pjsuaJNI.pjsua_acc_config_ka_interval_get(swigCPtr, this);
+  }
+
+  public void setKa_data(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_ka_data_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getKa_data() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_ka_data_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setVid_in_auto_show(int value) {
+    pjsuaJNI.pjsua_acc_config_vid_in_auto_show_set(swigCPtr, this, value);
+  }
+
+  public int getVid_in_auto_show() {
+    return pjsuaJNI.pjsua_acc_config_vid_in_auto_show_get(swigCPtr, this);
+  }
+
+  public void setVid_out_auto_transmit(int value) {
+    pjsuaJNI.pjsua_acc_config_vid_out_auto_transmit_set(swigCPtr, this, value);
+  }
+
+  public int getVid_out_auto_transmit() {
+    return pjsuaJNI.pjsua_acc_config_vid_out_auto_transmit_get(swigCPtr, this);
+  }
+
+  public void setVid_wnd_flags(long value) {
+    pjsuaJNI.pjsua_acc_config_vid_wnd_flags_set(swigCPtr, this, value);
+  }
+
+  public long getVid_wnd_flags() {
+    return pjsuaJNI.pjsua_acc_config_vid_wnd_flags_get(swigCPtr, this);
+  }
+
+  public void setVid_cap_dev(SWIGTYPE_p_pjmedia_vid_dev_index value) {
+    pjsuaJNI.pjsua_acc_config_vid_cap_dev_set(swigCPtr, this, SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_vid_dev_index getVid_cap_dev() {
+    return new SWIGTYPE_p_pjmedia_vid_dev_index(pjsuaJNI.pjsua_acc_config_vid_cap_dev_get(swigCPtr, this), true);
+  }
+
+  public void setVid_rend_dev(SWIGTYPE_p_pjmedia_vid_dev_index value) {
+    pjsuaJNI.pjsua_acc_config_vid_rend_dev_set(swigCPtr, this, SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_vid_dev_index getVid_rend_dev() {
+    return new SWIGTYPE_p_pjmedia_vid_dev_index(pjsuaJNI.pjsua_acc_config_vid_rend_dev_get(swigCPtr, this), true);
+  }
+
+  public void setVid_stream_rc_cfg(SWIGTYPE_p_pjmedia_vid_stream_rc_config value) {
+    pjsuaJNI.pjsua_acc_config_vid_stream_rc_cfg_set(swigCPtr, this, SWIGTYPE_p_pjmedia_vid_stream_rc_config.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_vid_stream_rc_config getVid_stream_rc_cfg() {
+    return new SWIGTYPE_p_pjmedia_vid_stream_rc_config(pjsuaJNI.pjsua_acc_config_vid_stream_rc_cfg_get(swigCPtr, this), true);
+  }
+
+  public void setRtp_cfg(pjsua_transport_config value) {
+    pjsuaJNI.pjsua_acc_config_rtp_cfg_set(swigCPtr, this, pjsua_transport_config.getCPtr(value), value);
+  }
+
+  public pjsua_transport_config getRtp_cfg() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_rtp_cfg_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsua_transport_config(cPtr, false);
+  }
+
+  public void setIpv6_media_use(pjsua_ipv6_use value) {
+    pjsuaJNI.pjsua_acc_config_ipv6_media_use_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_ipv6_use getIpv6_media_use() {
+    return pjsua_ipv6_use.swigToEnum(pjsuaJNI.pjsua_acc_config_ipv6_media_use_get(swigCPtr, this));
+  }
+
+  public void setSip_stun_use(pjsua_stun_use value) {
+    pjsuaJNI.pjsua_acc_config_sip_stun_use_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_stun_use getSip_stun_use() {
+    return pjsua_stun_use.swigToEnum(pjsuaJNI.pjsua_acc_config_sip_stun_use_get(swigCPtr, this));
+  }
+
+  public void setMedia_stun_use(pjsua_stun_use value) {
+    pjsuaJNI.pjsua_acc_config_media_stun_use_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_stun_use getMedia_stun_use() {
+    return pjsua_stun_use.swigToEnum(pjsuaJNI.pjsua_acc_config_media_stun_use_get(swigCPtr, this));
+  }
+
+  public void setIce_cfg_use(pjsua_ice_config_use value) {
+    pjsuaJNI.pjsua_acc_config_ice_cfg_use_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_ice_config_use getIce_cfg_use() {
+    return pjsua_ice_config_use.swigToEnum(pjsuaJNI.pjsua_acc_config_ice_cfg_use_get(swigCPtr, this));
+  }
+
+  public void setIce_cfg(pjsua_ice_config value) {
+    pjsuaJNI.pjsua_acc_config_ice_cfg_set(swigCPtr, this, pjsua_ice_config.getCPtr(value), value);
+  }
+
+  public pjsua_ice_config getIce_cfg() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_ice_cfg_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsua_ice_config(cPtr, false);
+  }
+
+  public void setTurn_cfg_use(pjsua_turn_config_use value) {
+    pjsuaJNI.pjsua_acc_config_turn_cfg_use_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_turn_config_use getTurn_cfg_use() {
+    return pjsua_turn_config_use.swigToEnum(pjsuaJNI.pjsua_acc_config_turn_cfg_use_get(swigCPtr, this));
+  }
+
+  public void setTurn_cfg(pjsua_turn_config value) {
+    pjsuaJNI.pjsua_acc_config_turn_cfg_set(swigCPtr, this, pjsua_turn_config.getCPtr(value), value);
+  }
+
+  public pjsua_turn_config getTurn_cfg() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_turn_cfg_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsua_turn_config(cPtr, false);
+  }
+
+  public void setUse_srtp(pjmedia_srtp_use value) {
+    pjsuaJNI.pjsua_acc_config_use_srtp_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjmedia_srtp_use getUse_srtp() {
+    return pjmedia_srtp_use.swigToEnum(pjsuaJNI.pjsua_acc_config_use_srtp_get(swigCPtr, this));
+  }
+
+  public void setSrtp_secure_signaling(int value) {
+    pjsuaJNI.pjsua_acc_config_srtp_secure_signaling_set(swigCPtr, this, value);
+  }
+
+  public int getSrtp_secure_signaling() {
+    return pjsuaJNI.pjsua_acc_config_srtp_secure_signaling_get(swigCPtr, this);
+  }
+
+  public void setSrtp_optional_dup_offer(int value) {
+    pjsuaJNI.pjsua_acc_config_srtp_optional_dup_offer_set(swigCPtr, this, value);
+  }
+
+  public int getSrtp_optional_dup_offer() {
+    return pjsuaJNI.pjsua_acc_config_srtp_optional_dup_offer_get(swigCPtr, this);
+  }
+
+  public void setReg_retry_interval(long value) {
+    pjsuaJNI.pjsua_acc_config_reg_retry_interval_set(swigCPtr, this, value);
+  }
+
+  public long getReg_retry_interval() {
+    return pjsuaJNI.pjsua_acc_config_reg_retry_interval_get(swigCPtr, this);
+  }
+
+  public void setReg_first_retry_interval(long value) {
+    pjsuaJNI.pjsua_acc_config_reg_first_retry_interval_set(swigCPtr, this, value);
+  }
+
+  public long getReg_first_retry_interval() {
+    return pjsuaJNI.pjsua_acc_config_reg_first_retry_interval_get(swigCPtr, this);
+  }
+
+  public void setReg_retry_random_interval(long value) {
+    pjsuaJNI.pjsua_acc_config_reg_retry_random_interval_set(swigCPtr, this, value);
+  }
+
+  public long getReg_retry_random_interval() {
+    return pjsuaJNI.pjsua_acc_config_reg_retry_random_interval_get(swigCPtr, this);
+  }
+
+  public void setDrop_calls_on_reg_fail(int value) {
+    pjsuaJNI.pjsua_acc_config_drop_calls_on_reg_fail_set(swigCPtr, this, value);
+  }
+
+  public int getDrop_calls_on_reg_fail() {
+    return pjsuaJNI.pjsua_acc_config_drop_calls_on_reg_fail_get(swigCPtr, this);
+  }
+
+  public void setReg_use_proxy(long value) {
+    pjsuaJNI.pjsua_acc_config_reg_use_proxy_set(swigCPtr, this, value);
+  }
+
+  public long getReg_use_proxy() {
+    return pjsuaJNI.pjsua_acc_config_reg_use_proxy_get(swigCPtr, this);
+  }
+
+  public void setCall_hold_type(pjsua_call_hold_type value) {
+    pjsuaJNI.pjsua_acc_config_call_hold_type_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_call_hold_type getCall_hold_type() {
+    return pjsua_call_hold_type.swigToEnum(pjsuaJNI.pjsua_acc_config_call_hold_type_get(swigCPtr, this));
+  }
+
+  public void setRegister_on_acc_add(int value) {
+    pjsuaJNI.pjsua_acc_config_register_on_acc_add_set(swigCPtr, this, value);
+  }
+
+  public int getRegister_on_acc_add() {
+    return pjsuaJNI.pjsua_acc_config_register_on_acc_add_get(swigCPtr, this);
+  }
+
+  public pjsua_acc_config() {
+    this(pjsuaJNI.new_pjsua_acc_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_acc_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_acc_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_acc_info.java	(working copy)
@@ -0,0 +1,142 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_acc_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_acc_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_acc_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_acc_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setId(int value) {
+    pjsuaJNI.pjsua_acc_info_id_set(swigCPtr, this, value);
+  }
+
+  public int getId() {
+    return pjsuaJNI.pjsua_acc_info_id_get(swigCPtr, this);
+  }
+
+  public void setIs_default(int value) {
+    pjsuaJNI.pjsua_acc_info_is_default_set(swigCPtr, this, value);
+  }
+
+  public int getIs_default() {
+    return pjsuaJNI.pjsua_acc_info_is_default_get(swigCPtr, this);
+  }
+
+  public void setAcc_uri(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_info_acc_uri_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getAcc_uri() {
+    long cPtr = pjsuaJNI.pjsua_acc_info_acc_uri_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setHas_registration(int value) {
+    pjsuaJNI.pjsua_acc_info_has_registration_set(swigCPtr, this, value);
+  }
+
+  public int getHas_registration() {
+    return pjsuaJNI.pjsua_acc_info_has_registration_get(swigCPtr, this);
+  }
+
+  public void setExpires(int value) {
+    pjsuaJNI.pjsua_acc_info_expires_set(swigCPtr, this, value);
+  }
+
+  public int getExpires() {
+    return pjsuaJNI.pjsua_acc_info_expires_get(swigCPtr, this);
+  }
+
+  public void setStatus(pjsip_status_code value) {
+    pjsuaJNI.pjsua_acc_info_status_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsip_status_code getStatus() {
+    return pjsip_status_code.swigToEnum(pjsuaJNI.pjsua_acc_info_status_get(swigCPtr, this));
+  }
+
+  public void setReg_last_err(int value) {
+    pjsuaJNI.pjsua_acc_info_reg_last_err_set(swigCPtr, this, value);
+  }
+
+  public int getReg_last_err() {
+    return pjsuaJNI.pjsua_acc_info_reg_last_err_get(swigCPtr, this);
+  }
+
+  public void setStatus_text(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_info_status_text_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getStatus_text() {
+    long cPtr = pjsuaJNI.pjsua_acc_info_status_text_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setOnline_status(int value) {
+    pjsuaJNI.pjsua_acc_info_online_status_set(swigCPtr, this, value);
+  }
+
+  public int getOnline_status() {
+    return pjsuaJNI.pjsua_acc_info_online_status_get(swigCPtr, this);
+  }
+
+  public void setOnline_status_text(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_info_online_status_text_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getOnline_status_text() {
+    long cPtr = pjsuaJNI.pjsua_acc_info_online_status_text_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setRpid(pjrpid_element value) {
+    pjsuaJNI.pjsua_acc_info_rpid_set(swigCPtr, this, pjrpid_element.getCPtr(value), value);
+  }
+
+  public pjrpid_element getRpid() {
+    long cPtr = pjsuaJNI.pjsua_acc_info_rpid_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjrpid_element(cPtr, false);
+  }
+
+  public void setBuf_(String value) {
+    pjsuaJNI.pjsua_acc_info_buf__set(swigCPtr, this, value);
+  }
+
+  public String getBuf_() {
+    return pjsuaJNI.pjsua_acc_info_buf__get(swigCPtr, this);
+  }
+
+  public pjsua_acc_info() {
+    this(pjsuaJNI.new_pjsua_acc_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_config.java	(working copy)
@@ -0,0 +1,67 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_buddy_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_buddy_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_buddy_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_buddy_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setUri(pj_str_t value) {
+    pjsuaJNI.pjsua_buddy_config_uri_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getUri() {
+    long cPtr = pjsuaJNI.pjsua_buddy_config_uri_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setSubscribe(int value) {
+    pjsuaJNI.pjsua_buddy_config_subscribe_set(swigCPtr, this, value);
+  }
+
+  public int getSubscribe() {
+    return pjsuaJNI.pjsua_buddy_config_subscribe_get(swigCPtr, this);
+  }
+
+  public void setUser_data(byte[] value) {
+    pjsuaJNI.pjsua_buddy_config_user_data_set(swigCPtr, this, value);
+  }
+
+  public byte[] getUser_data() {
+	return pjsuaJNI.pjsua_buddy_config_user_data_get(swigCPtr, this);
+}
+
+  public pjsua_buddy_config() {
+    this(pjsuaJNI.new_pjsua_buddy_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_info.java	(working copy)
@@ -0,0 +1,151 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_buddy_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_buddy_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_buddy_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_buddy_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setId(int value) {
+    pjsuaJNI.pjsua_buddy_info_id_set(swigCPtr, this, value);
+  }
+
+  public int getId() {
+    return pjsuaJNI.pjsua_buddy_info_id_get(swigCPtr, this);
+  }
+
+  public void setUri(pj_str_t value) {
+    pjsuaJNI.pjsua_buddy_info_uri_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getUri() {
+    long cPtr = pjsuaJNI.pjsua_buddy_info_uri_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setContact(pj_str_t value) {
+    pjsuaJNI.pjsua_buddy_info_contact_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getContact() {
+    long cPtr = pjsuaJNI.pjsua_buddy_info_contact_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setStatus(pjsua_buddy_status value) {
+    pjsuaJNI.pjsua_buddy_info_status_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_buddy_status getStatus() {
+    return pjsua_buddy_status.swigToEnum(pjsuaJNI.pjsua_buddy_info_status_get(swigCPtr, this));
+  }
+
+  public void setStatus_text(pj_str_t value) {
+    pjsuaJNI.pjsua_buddy_info_status_text_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getStatus_text() {
+    long cPtr = pjsuaJNI.pjsua_buddy_info_status_text_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setMonitor_pres(int value) {
+    pjsuaJNI.pjsua_buddy_info_monitor_pres_set(swigCPtr, this, value);
+  }
+
+  public int getMonitor_pres() {
+    return pjsuaJNI.pjsua_buddy_info_monitor_pres_get(swigCPtr, this);
+  }
+
+  public void setSub_state(SWIGTYPE_p_pjsip_evsub_state value) {
+    pjsuaJNI.pjsua_buddy_info_sub_state_set(swigCPtr, this, SWIGTYPE_p_pjsip_evsub_state.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_evsub_state getSub_state() {
+    return new SWIGTYPE_p_pjsip_evsub_state(pjsuaJNI.pjsua_buddy_info_sub_state_get(swigCPtr, this), true);
+  }
+
+  public void setSub_state_name(String value) {
+    pjsuaJNI.pjsua_buddy_info_sub_state_name_set(swigCPtr, this, value);
+  }
+
+  public String getSub_state_name() {
+    return pjsuaJNI.pjsua_buddy_info_sub_state_name_get(swigCPtr, this);
+  }
+
+  public void setSub_term_code(long value) {
+    pjsuaJNI.pjsua_buddy_info_sub_term_code_set(swigCPtr, this, value);
+  }
+
+  public long getSub_term_code() {
+    return pjsuaJNI.pjsua_buddy_info_sub_term_code_get(swigCPtr, this);
+  }
+
+  public void setSub_term_reason(pj_str_t value) {
+    pjsuaJNI.pjsua_buddy_info_sub_term_reason_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getSub_term_reason() {
+    long cPtr = pjsuaJNI.pjsua_buddy_info_sub_term_reason_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setRpid(pjrpid_element value) {
+    pjsuaJNI.pjsua_buddy_info_rpid_set(swigCPtr, this, pjrpid_element.getCPtr(value), value);
+  }
+
+  public pjrpid_element getRpid() {
+    long cPtr = pjsuaJNI.pjsua_buddy_info_rpid_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjrpid_element(cPtr, false);
+  }
+
+  public void setPres_status(SWIGTYPE_p_pjsip_pres_status value) {
+    pjsuaJNI.pjsua_buddy_info_pres_status_set(swigCPtr, this, SWIGTYPE_p_pjsip_pres_status.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_pres_status getPres_status() {
+    return new SWIGTYPE_p_pjsip_pres_status(pjsuaJNI.pjsua_buddy_info_pres_status_get(swigCPtr, this), true);
+  }
+
+  public void setBuf_(String value) {
+    pjsuaJNI.pjsua_buddy_info_buf__set(swigCPtr, this, value);
+  }
+
+  public String getBuf_() {
+    return pjsuaJNI.pjsua_buddy_info_buf__get(swigCPtr, this);
+  }
+
+  public pjsua_buddy_info() {
+    this(pjsuaJNI.new_pjsua_buddy_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_status.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_status.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_status.java	(working copy)
@@ -0,0 +1,53 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_buddy_status {
+  PJSUA_BUDDY_STATUS_UNKNOWN,
+  PJSUA_BUDDY_STATUS_ONLINE,
+  PJSUA_BUDDY_STATUS_OFFLINE;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_buddy_status swigToEnum(int swigValue) {
+    pjsua_buddy_status[] swigValues = pjsua_buddy_status.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_buddy_status swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_buddy_status.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_buddy_status() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_buddy_status(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_buddy_status(pjsua_buddy_status swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_call_flag.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_call_flag.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_call_flag.java	(working copy)
@@ -0,0 +1,54 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_call_flag {
+  PJSUA_CALL_UNHOLD(pjsuaJNI.PJSUA_CALL_UNHOLD_get()),
+  PJSUA_CALL_UPDATE_CONTACT(pjsuaJNI.PJSUA_CALL_UPDATE_CONTACT_get()),
+  PJSUA_CALL_INCLUDE_DISABLED_MEDIA(pjsuaJNI.PJSUA_CALL_INCLUDE_DISABLED_MEDIA_get()),
+  PJSUA_CALL_NO_SDP_OFFER(pjsuaJNI.PJSUA_CALL_NO_SDP_OFFER_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_call_flag swigToEnum(int swigValue) {
+    pjsua_call_flag[] swigValues = pjsua_call_flag.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_call_flag swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_call_flag.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_flag() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_flag(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_flag(pjsua_call_flag swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_call_hold_type.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_call_hold_type.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_call_hold_type.java	(working copy)
@@ -0,0 +1,52 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_call_hold_type {
+  PJSUA_CALL_HOLD_TYPE_RFC3264,
+  PJSUA_CALL_HOLD_TYPE_RFC2543;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_call_hold_type swigToEnum(int swigValue) {
+    pjsua_call_hold_type[] swigValues = pjsua_call_hold_type.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_call_hold_type swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_call_hold_type.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_hold_type() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_hold_type(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_hold_type(pjsua_call_hold_type swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_call_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_call_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_call_info.java	(working copy)
@@ -0,0 +1,254 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_call_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_call_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_call_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_call_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setId(int value) {
+    pjsuaJNI.pjsua_call_info_id_set(swigCPtr, this, value);
+  }
+
+  public int getId() {
+    return pjsuaJNI.pjsua_call_info_id_get(swigCPtr, this);
+  }
+
+  public void setRole(SWIGTYPE_p_pjsip_role_e value) {
+    pjsuaJNI.pjsua_call_info_role_set(swigCPtr, this, SWIGTYPE_p_pjsip_role_e.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_role_e getRole() {
+    return new SWIGTYPE_p_pjsip_role_e(pjsuaJNI.pjsua_call_info_role_get(swigCPtr, this), true);
+  }
+
+  public void setAcc_id(int value) {
+    pjsuaJNI.pjsua_call_info_acc_id_set(swigCPtr, this, value);
+  }
+
+  public int getAcc_id() {
+    return pjsuaJNI.pjsua_call_info_acc_id_get(swigCPtr, this);
+  }
+
+  public void setLocal_info(pj_str_t value) {
+    pjsuaJNI.pjsua_call_info_local_info_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getLocal_info() {
+    long cPtr = pjsuaJNI.pjsua_call_info_local_info_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setLocal_contact(pj_str_t value) {
+    pjsuaJNI.pjsua_call_info_local_contact_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getLocal_contact() {
+    long cPtr = pjsuaJNI.pjsua_call_info_local_contact_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setRemote_info(pj_str_t value) {
+    pjsuaJNI.pjsua_call_info_remote_info_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getRemote_info() {
+    long cPtr = pjsuaJNI.pjsua_call_info_remote_info_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setRemote_contact(pj_str_t value) {
+    pjsuaJNI.pjsua_call_info_remote_contact_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getRemote_contact() {
+    long cPtr = pjsuaJNI.pjsua_call_info_remote_contact_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setCall_id(pj_str_t value) {
+    pjsuaJNI.pjsua_call_info_call_id_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getCall_id() {
+    long cPtr = pjsuaJNI.pjsua_call_info_call_id_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setSetting(pjsua_call_setting value) {
+    pjsuaJNI.pjsua_call_info_setting_set(swigCPtr, this, pjsua_call_setting.getCPtr(value), value);
+  }
+
+  public pjsua_call_setting getSetting() {
+    long cPtr = pjsuaJNI.pjsua_call_info_setting_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsua_call_setting(cPtr, false);
+  }
+
+  public void setState(pjsip_inv_state value) {
+    pjsuaJNI.pjsua_call_info_state_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsip_inv_state getState() {
+    return pjsip_inv_state.swigToEnum(pjsuaJNI.pjsua_call_info_state_get(swigCPtr, this));
+  }
+
+  public void setState_text(pj_str_t value) {
+    pjsuaJNI.pjsua_call_info_state_text_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getState_text() {
+    long cPtr = pjsuaJNI.pjsua_call_info_state_text_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setLast_status(pjsip_status_code value) {
+    pjsuaJNI.pjsua_call_info_last_status_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsip_status_code getLast_status() {
+    return pjsip_status_code.swigToEnum(pjsuaJNI.pjsua_call_info_last_status_get(swigCPtr, this));
+  }
+
+  public void setLast_status_text(pj_str_t value) {
+    pjsuaJNI.pjsua_call_info_last_status_text_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getLast_status_text() {
+    long cPtr = pjsuaJNI.pjsua_call_info_last_status_text_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setMedia_status(pjsua_call_media_status value) {
+    pjsuaJNI.pjsua_call_info_media_status_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_call_media_status getMedia_status() {
+    return pjsua_call_media_status.swigToEnum(pjsuaJNI.pjsua_call_info_media_status_get(swigCPtr, this));
+  }
+
+  public void setMedia_dir(pjmedia_dir value) {
+    pjsuaJNI.pjsua_call_info_media_dir_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjmedia_dir getMedia_dir() {
+    return pjmedia_dir.swigToEnum(pjsuaJNI.pjsua_call_info_media_dir_get(swigCPtr, this));
+  }
+
+  public void setConf_slot(int value) {
+    pjsuaJNI.pjsua_call_info_conf_slot_set(swigCPtr, this, value);
+  }
+
+  public int getConf_slot() {
+    return pjsuaJNI.pjsua_call_info_conf_slot_get(swigCPtr, this);
+  }
+
+  public void setMedia_cnt(long value) {
+    pjsuaJNI.pjsua_call_info_media_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getMedia_cnt() {
+    return pjsuaJNI.pjsua_call_info_media_cnt_get(swigCPtr, this);
+  }
+
+  public void setMedia(pjsua_call_media_info value) {
+    pjsuaJNI.pjsua_call_info_media_set(swigCPtr, this, pjsua_call_media_info.getCPtr(value), value);
+  }
+
+  public pjsua_call_media_info getMedia() {
+    long cPtr = pjsuaJNI.pjsua_call_info_media_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsua_call_media_info(cPtr, false);
+  }
+
+  public void setProv_media_cnt(long value) {
+    pjsuaJNI.pjsua_call_info_prov_media_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getProv_media_cnt() {
+    return pjsuaJNI.pjsua_call_info_prov_media_cnt_get(swigCPtr, this);
+  }
+
+  public void setProv_media(pjsua_call_media_info value) {
+    pjsuaJNI.pjsua_call_info_prov_media_set(swigCPtr, this, pjsua_call_media_info.getCPtr(value), value);
+  }
+
+  public pjsua_call_media_info getProv_media() {
+    long cPtr = pjsuaJNI.pjsua_call_info_prov_media_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsua_call_media_info(cPtr, false);
+  }
+
+  public void setConnect_duration(pj_time_val value) {
+    pjsuaJNI.pjsua_call_info_connect_duration_set(swigCPtr, this, pj_time_val.getCPtr(value), value);
+  }
+
+  public pj_time_val getConnect_duration() {
+    long cPtr = pjsuaJNI.pjsua_call_info_connect_duration_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_time_val(cPtr, false);
+  }
+
+  public void setTotal_duration(pj_time_val value) {
+    pjsuaJNI.pjsua_call_info_total_duration_set(swigCPtr, this, pj_time_val.getCPtr(value), value);
+  }
+
+  public pj_time_val getTotal_duration() {
+    long cPtr = pjsuaJNI.pjsua_call_info_total_duration_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_time_val(cPtr, false);
+  }
+
+  public void setRem_offerer(int value) {
+    pjsuaJNI.pjsua_call_info_rem_offerer_set(swigCPtr, this, value);
+  }
+
+  public int getRem_offerer() {
+    return pjsuaJNI.pjsua_call_info_rem_offerer_get(swigCPtr, this);
+  }
+
+  public void setRem_aud_cnt(long value) {
+    pjsuaJNI.pjsua_call_info_rem_aud_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getRem_aud_cnt() {
+    return pjsuaJNI.pjsua_call_info_rem_aud_cnt_get(swigCPtr, this);
+  }
+
+  public void setRem_vid_cnt(long value) {
+    pjsuaJNI.pjsua_call_info_rem_vid_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getRem_vid_cnt() {
+    return pjsuaJNI.pjsua_call_info_rem_vid_cnt_get(swigCPtr, this);
+  }
+
+  public pjsua_call_info() {
+    this(pjsuaJNI.new_pjsua_call_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_call_media_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_call_media_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_call_media_info.java	(working copy)
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_call_media_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_call_media_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_call_media_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_call_media_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setIndex(long value) {
+    pjsuaJNI.pjsua_call_media_info_index_set(swigCPtr, this, value);
+  }
+
+  public long getIndex() {
+    return pjsuaJNI.pjsua_call_media_info_index_get(swigCPtr, this);
+  }
+
+  public void setType(SWIGTYPE_p_pjmedia_type value) {
+    pjsuaJNI.pjsua_call_media_info_type_set(swigCPtr, this, SWIGTYPE_p_pjmedia_type.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_type getType() {
+    return new SWIGTYPE_p_pjmedia_type(pjsuaJNI.pjsua_call_media_info_type_get(swigCPtr, this), true);
+  }
+
+  public void setDir(pjmedia_dir value) {
+    pjsuaJNI.pjsua_call_media_info_dir_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjmedia_dir getDir() {
+    return pjmedia_dir.swigToEnum(pjsuaJNI.pjsua_call_media_info_dir_get(swigCPtr, this));
+  }
+
+  public void setStatus(pjsua_call_media_status value) {
+    pjsuaJNI.pjsua_call_media_info_status_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_call_media_status getStatus() {
+    return pjsua_call_media_status.swigToEnum(pjsuaJNI.pjsua_call_media_info_status_get(swigCPtr, this));
+  }
+
+  public pjsua_call_media_info() {
+    this(pjsuaJNI.new_pjsua_call_media_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_call_media_status.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_call_media_status.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_call_media_status.java	(working copy)
@@ -0,0 +1,55 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_call_media_status {
+  PJSUA_CALL_MEDIA_NONE,
+  PJSUA_CALL_MEDIA_ACTIVE,
+  PJSUA_CALL_MEDIA_LOCAL_HOLD,
+  PJSUA_CALL_MEDIA_REMOTE_HOLD,
+  PJSUA_CALL_MEDIA_ERROR;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_call_media_status swigToEnum(int swigValue) {
+    pjsua_call_media_status[] swigValues = pjsua_call_media_status.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_call_media_status swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_call_media_status.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_media_status() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_media_status(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_media_status(pjsua_call_media_status swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_call_setting.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_call_setting.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_call_setting.java	(working copy)
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_call_setting {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_call_setting(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_call_setting obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_call_setting(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setFlag(long value) {
+    pjsuaJNI.pjsua_call_setting_flag_set(swigCPtr, this, value);
+  }
+
+  public long getFlag() {
+    return pjsuaJNI.pjsua_call_setting_flag_get(swigCPtr, this);
+  }
+
+  public void setReq_keyframe_method(long value) {
+    pjsuaJNI.pjsua_call_setting_req_keyframe_method_set(swigCPtr, this, value);
+  }
+
+  public long getReq_keyframe_method() {
+    return pjsuaJNI.pjsua_call_setting_req_keyframe_method_get(swigCPtr, this);
+  }
+
+  public void setAud_cnt(long value) {
+    pjsuaJNI.pjsua_call_setting_aud_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getAud_cnt() {
+    return pjsuaJNI.pjsua_call_setting_aud_cnt_get(swigCPtr, this);
+  }
+
+  public void setVid_cnt(long value) {
+    pjsuaJNI.pjsua_call_setting_vid_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getVid_cnt() {
+    return pjsuaJNI.pjsua_call_setting_vid_cnt_get(swigCPtr, this);
+  }
+
+  public pjsua_call_setting() {
+    this(pjsuaJNI.new_pjsua_call_setting(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_call_vid_strm_op.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_call_vid_strm_op.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_call_vid_strm_op.java	(working copy)
@@ -0,0 +1,58 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_call_vid_strm_op {
+  PJSUA_CALL_VID_STRM_NO_OP,
+  PJSUA_CALL_VID_STRM_ADD,
+  PJSUA_CALL_VID_STRM_REMOVE,
+  PJSUA_CALL_VID_STRM_CHANGE_DIR,
+  PJSUA_CALL_VID_STRM_CHANGE_CAP_DEV,
+  PJSUA_CALL_VID_STRM_START_TRANSMIT,
+  PJSUA_CALL_VID_STRM_STOP_TRANSMIT,
+  PJSUA_CALL_VID_STRM_SEND_KEYFRAME;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_call_vid_strm_op swigToEnum(int swigValue) {
+    pjsua_call_vid_strm_op[] swigValues = pjsua_call_vid_strm_op.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_call_vid_strm_op swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_call_vid_strm_op.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_vid_strm_op() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_vid_strm_op(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_vid_strm_op(pjsua_call_vid_strm_op swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_call_vid_strm_op_param.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_call_vid_strm_op_param.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_call_vid_strm_op_param.java	(working copy)
@@ -0,0 +1,66 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_call_vid_strm_op_param {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_call_vid_strm_op_param(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_call_vid_strm_op_param obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_call_vid_strm_op_param(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setMed_idx(int value) {
+    pjsuaJNI.pjsua_call_vid_strm_op_param_med_idx_set(swigCPtr, this, value);
+  }
+
+  public int getMed_idx() {
+    return pjsuaJNI.pjsua_call_vid_strm_op_param_med_idx_get(swigCPtr, this);
+  }
+
+  public void setDir(pjmedia_dir value) {
+    pjsuaJNI.pjsua_call_vid_strm_op_param_dir_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjmedia_dir getDir() {
+    return pjmedia_dir.swigToEnum(pjsuaJNI.pjsua_call_vid_strm_op_param_dir_get(swigCPtr, this));
+  }
+
+  public void setCap_dev(SWIGTYPE_p_pjmedia_vid_dev_index value) {
+    pjsuaJNI.pjsua_call_vid_strm_op_param_cap_dev_set(swigCPtr, this, SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_vid_dev_index getCap_dev() {
+    return new SWIGTYPE_p_pjmedia_vid_dev_index(pjsuaJNI.pjsua_call_vid_strm_op_param_cap_dev_get(swigCPtr, this), true);
+  }
+
+  public pjsua_call_vid_strm_op_param() {
+    this(pjsuaJNI.new_pjsua_call_vid_strm_op_param(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_callback.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_callback.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_callback.java	(working copy)
@@ -0,0 +1,392 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_callback {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_callback(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_callback obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_callback(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setOn_call_state(SWIGTYPE_p_f_int_p_pjsip_event__void value) {
+    pjsuaJNI.pjsua_callback_on_call_state_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsip_event__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsip_event__void getOn_call_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsip_event__void(cPtr, false);
+  }
+
+  public void setOn_incoming_call(SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void value) {
+    pjsuaJNI.pjsua_callback_on_incoming_call_set(swigCPtr, this, SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void getOn_incoming_call() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_incoming_call_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void(cPtr, false);
+  }
+
+  public void setOn_call_tsx_state(SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void value) {
+    pjsuaJNI.pjsua_callback_on_call_tsx_state_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void getOn_call_tsx_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_tsx_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void(cPtr, false);
+  }
+
+  public void setOn_call_media_state(SWIGTYPE_p_f_int__void value) {
+    pjsuaJNI.pjsua_callback_on_call_media_state_set(swigCPtr, this, SWIGTYPE_p_f_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int__void getOn_call_media_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_media_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int__void(cPtr, false);
+  }
+
+  public void setOn_call_sdp_created(SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void value) {
+    pjsuaJNI.pjsua_callback_on_call_sdp_created_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void getOn_call_sdp_created() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_sdp_created_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void(cPtr, false);
+  }
+
+  public void setOn_stream_created(SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void value) {
+    pjsuaJNI.pjsua_callback_on_stream_created_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void getOn_stream_created() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_stream_created_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void(cPtr, false);
+  }
+
+  public void setOn_stream_destroyed(SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void value) {
+    pjsuaJNI.pjsua_callback_on_stream_destroyed_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void getOn_stream_destroyed() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_stream_destroyed_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void(cPtr, false);
+  }
+
+  public void setOn_dtmf_digit(SWIGTYPE_p_f_int_int__void value) {
+    pjsuaJNI.pjsua_callback_on_dtmf_digit_set(swigCPtr, this, SWIGTYPE_p_f_int_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_int__void getOn_dtmf_digit() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_dtmf_digit_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_int__void(cPtr, false);
+  }
+
+  public void setOn_call_transfer_request(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void value) {
+    pjsuaJNI.pjsua_callback_on_call_transfer_request_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void getOn_call_transfer_request() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_transfer_request_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void(cPtr, false);
+  }
+
+  public void setOn_call_transfer_request2(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void value) {
+    pjsuaJNI.pjsua_callback_on_call_transfer_request2_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void getOn_call_transfer_request2() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_transfer_request2_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void(cPtr, false);
+  }
+
+  public void setOn_call_transfer_status(SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void value) {
+    pjsuaJNI.pjsua_callback_on_call_transfer_status_set(swigCPtr, this, SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void getOn_call_transfer_status() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_transfer_status_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void(cPtr, false);
+  }
+
+  public void setOn_call_replace_request(SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void value) {
+    pjsuaJNI.pjsua_callback_on_call_replace_request_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void getOn_call_replace_request() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_replace_request_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void(cPtr, false);
+  }
+
+  public void setOn_call_replace_request2(SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void value) {
+    pjsuaJNI.pjsua_callback_on_call_replace_request2_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void getOn_call_replace_request2() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_replace_request2_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void(cPtr, false);
+  }
+
+  public void setOn_call_replaced(SWIGTYPE_p_f_int_int__void value) {
+    pjsuaJNI.pjsua_callback_on_call_replaced_set(swigCPtr, this, SWIGTYPE_p_f_int_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_int__void getOn_call_replaced() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_replaced_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_int__void(cPtr, false);
+  }
+
+  public void setOn_call_rx_offer(SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void value) {
+    pjsuaJNI.pjsua_callback_on_call_rx_offer_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void getOn_call_rx_offer() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_rx_offer_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void(cPtr, false);
+  }
+
+  public void setOn_reg_started(SWIGTYPE_p_f_int_int__void value) {
+    pjsuaJNI.pjsua_callback_on_reg_started_set(swigCPtr, this, SWIGTYPE_p_f_int_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_int__void getOn_reg_started() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_reg_started_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_int__void(cPtr, false);
+  }
+
+  public void setOn_reg_state(SWIGTYPE_p_f_int__void value) {
+    pjsuaJNI.pjsua_callback_on_reg_state_set(swigCPtr, this, SWIGTYPE_p_f_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int__void getOn_reg_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_reg_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int__void(cPtr, false);
+  }
+
+  public void setOn_reg_state2(SWIGTYPE_p_f_int_p_pjsua_reg_info__void value) {
+    pjsuaJNI.pjsua_callback_on_reg_state2_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsua_reg_info__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsua_reg_info__void getOn_reg_state2() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_reg_state2_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsua_reg_info__void(cPtr, false);
+  }
+
+  public void setOn_incoming_subscribe(SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void value) {
+    pjsuaJNI.pjsua_callback_on_incoming_subscribe_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void getOn_incoming_subscribe() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_incoming_subscribe_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void(cPtr, false);
+  }
+
+  public void setOn_srv_subscribe_state(SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void value) {
+    pjsuaJNI.pjsua_callback_on_srv_subscribe_state_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void getOn_srv_subscribe_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_srv_subscribe_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void(cPtr, false);
+  }
+
+  public void setOn_buddy_state(SWIGTYPE_p_f_int__void value) {
+    pjsuaJNI.pjsua_callback_on_buddy_state_set(swigCPtr, this, SWIGTYPE_p_f_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int__void getOn_buddy_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_buddy_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int__void(cPtr, false);
+  }
+
+  public void setOn_buddy_evsub_state(SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void value) {
+    pjsuaJNI.pjsua_callback_on_buddy_evsub_state_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void getOn_buddy_evsub_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_buddy_evsub_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void(cPtr, false);
+  }
+
+  public void setOn_pager(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void value) {
+    pjsuaJNI.pjsua_callback_on_pager_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void getOn_pager() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_pager_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void(cPtr, false);
+  }
+
+  public void setOn_pager2(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void value) {
+    pjsuaJNI.pjsua_callback_on_pager2_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void getOn_pager2() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_pager2_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void(cPtr, false);
+  }
+
+  public void setOn_pager_status(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void value) {
+    pjsuaJNI.pjsua_callback_on_pager_status_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void getOn_pager_status() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_pager_status_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void(cPtr, false);
+  }
+
+  public void setOn_pager_status2(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void value) {
+    pjsuaJNI.pjsua_callback_on_pager_status2_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void getOn_pager_status2() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_pager_status2_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void(cPtr, false);
+  }
+
+  public void setOn_typing(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void value) {
+    pjsuaJNI.pjsua_callback_on_typing_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void getOn_typing() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_typing_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void(cPtr, false);
+  }
+
+  public void setOn_typing2(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void value) {
+    pjsuaJNI.pjsua_callback_on_typing2_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void getOn_typing2() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_typing2_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void(cPtr, false);
+  }
+
+  public void setOn_nat_detect(SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void value) {
+    pjsuaJNI.pjsua_callback_on_nat_detect_set(swigCPtr, this, SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void getOn_nat_detect() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_nat_detect_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void(cPtr, false);
+  }
+
+  public void setOn_call_redirected(SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op value) {
+    pjsuaJNI.pjsua_callback_on_call_redirected_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op getOn_call_redirected() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_redirected_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op(cPtr, false);
+  }
+
+  public void setOn_mwi_state(SWIGTYPE_p_f_int_p_pjsip_evsub__void value) {
+    pjsuaJNI.pjsua_callback_on_mwi_state_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsip_evsub__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsip_evsub__void getOn_mwi_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_mwi_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsip_evsub__void(cPtr, false);
+  }
+
+  public void setOn_mwi_info(SWIGTYPE_p_f_int_p_pjsua_mwi_info__void value) {
+    pjsuaJNI.pjsua_callback_on_mwi_info_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsua_mwi_info__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsua_mwi_info__void getOn_mwi_info() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_mwi_info_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsua_mwi_info__void(cPtr, false);
+  }
+
+  public void setOn_transport_state(SWIGTYPE_p_pjsip_tp_state_callback value) {
+    pjsuaJNI.pjsua_callback_on_transport_state_set(swigCPtr, this, SWIGTYPE_p_pjsip_tp_state_callback.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_tp_state_callback getOn_transport_state() {
+    return new SWIGTYPE_p_pjsip_tp_state_callback(pjsuaJNI.pjsua_callback_on_transport_state_get(swigCPtr, this), true);
+  }
+
+  public void setOn_call_media_transport_state(SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int value) {
+    pjsuaJNI.pjsua_callback_on_call_media_transport_state_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int getOn_call_media_transport_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_media_transport_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int(cPtr, false);
+  }
+
+  public void setOn_ice_transport_error(SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void value) {
+    pjsuaJNI.pjsua_callback_on_ice_transport_error_set(swigCPtr, this, SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void getOn_ice_transport_error() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_ice_transport_error_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void(cPtr, false);
+  }
+
+  public void setOn_snd_dev_operation(SWIGTYPE_p_f_int__int value) {
+    pjsuaJNI.pjsua_callback_on_snd_dev_operation_set(swigCPtr, this, SWIGTYPE_p_f_int__int.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int__int getOn_snd_dev_operation() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_snd_dev_operation_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int__int(cPtr, false);
+  }
+
+  public void setOn_call_media_event(SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void value) {
+    pjsuaJNI.pjsua_callback_on_call_media_event_set(swigCPtr, this, SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void getOn_call_media_event() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_media_event_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void(cPtr, false);
+  }
+
+  public void setOn_create_media_transport(SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport value) {
+    pjsuaJNI.pjsua_callback_on_create_media_transport_set(swigCPtr, this, SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport getOn_create_media_transport() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_create_media_transport_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport(cPtr, false);
+  }
+
+  public void setOn_acc_find_for_incoming(SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void value) {
+    pjsuaJNI.pjsua_callback_on_acc_find_for_incoming_set(swigCPtr, this, SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void getOn_acc_find_for_incoming() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_acc_find_for_incoming_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void(cPtr, false);
+  }
+
+  public pjsua_callback() {
+    this(pjsuaJNI.new_pjsua_callback(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_codec_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_codec_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_codec_info.java	(working copy)
@@ -0,0 +1,76 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_codec_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_codec_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_codec_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_codec_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setCodec_id(pj_str_t value) {
+    pjsuaJNI.pjsua_codec_info_codec_id_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getCodec_id() {
+    long cPtr = pjsuaJNI.pjsua_codec_info_codec_id_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setPriority(short value) {
+    pjsuaJNI.pjsua_codec_info_priority_set(swigCPtr, this, value);
+  }
+
+  public short getPriority() {
+    return pjsuaJNI.pjsua_codec_info_priority_get(swigCPtr, this);
+  }
+
+  public void setDesc(pj_str_t value) {
+    pjsuaJNI.pjsua_codec_info_desc_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getDesc() {
+    long cPtr = pjsuaJNI.pjsua_codec_info_desc_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setBuf_(String value) {
+    pjsuaJNI.pjsua_codec_info_buf__set(swigCPtr, this, value);
+  }
+
+  public String getBuf_() {
+    return pjsuaJNI.pjsua_codec_info_buf__get(swigCPtr, this);
+  }
+
+  public pjsua_codec_info() {
+    this(pjsuaJNI.new_pjsua_codec_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_conf_port_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_conf_port_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_conf_port_info.java	(working copy)
@@ -0,0 +1,131 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_conf_port_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_conf_port_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_conf_port_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_conf_port_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setSlot_id(int value) {
+    pjsuaJNI.pjsua_conf_port_info_slot_id_set(swigCPtr, this, value);
+  }
+
+  public int getSlot_id() {
+    return pjsuaJNI.pjsua_conf_port_info_slot_id_get(swigCPtr, this);
+  }
+
+  public void setName(pj_str_t value) {
+    pjsuaJNI.pjsua_conf_port_info_name_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getName() {
+    long cPtr = pjsuaJNI.pjsua_conf_port_info_name_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setFormat(SWIGTYPE_p_pjmedia_format value) {
+    pjsuaJNI.pjsua_conf_port_info_format_set(swigCPtr, this, SWIGTYPE_p_pjmedia_format.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_format getFormat() {
+    return new SWIGTYPE_p_pjmedia_format(pjsuaJNI.pjsua_conf_port_info_format_get(swigCPtr, this), true);
+  }
+
+  public void setClock_rate(long value) {
+    pjsuaJNI.pjsua_conf_port_info_clock_rate_set(swigCPtr, this, value);
+  }
+
+  public long getClock_rate() {
+    return pjsuaJNI.pjsua_conf_port_info_clock_rate_get(swigCPtr, this);
+  }
+
+  public void setChannel_count(long value) {
+    pjsuaJNI.pjsua_conf_port_info_channel_count_set(swigCPtr, this, value);
+  }
+
+  public long getChannel_count() {
+    return pjsuaJNI.pjsua_conf_port_info_channel_count_get(swigCPtr, this);
+  }
+
+  public void setSamples_per_frame(long value) {
+    pjsuaJNI.pjsua_conf_port_info_samples_per_frame_set(swigCPtr, this, value);
+  }
+
+  public long getSamples_per_frame() {
+    return pjsuaJNI.pjsua_conf_port_info_samples_per_frame_get(swigCPtr, this);
+  }
+
+  public void setBits_per_sample(long value) {
+    pjsuaJNI.pjsua_conf_port_info_bits_per_sample_set(swigCPtr, this, value);
+  }
+
+  public long getBits_per_sample() {
+    return pjsuaJNI.pjsua_conf_port_info_bits_per_sample_get(swigCPtr, this);
+  }
+
+  public void setTx_level_adj(float value) {
+    pjsuaJNI.pjsua_conf_port_info_tx_level_adj_set(swigCPtr, this, value);
+  }
+
+  public float getTx_level_adj() {
+    return pjsuaJNI.pjsua_conf_port_info_tx_level_adj_get(swigCPtr, this);
+  }
+
+  public void setRx_level_adj(float value) {
+    pjsuaJNI.pjsua_conf_port_info_rx_level_adj_set(swigCPtr, this, value);
+  }
+
+  public float getRx_level_adj() {
+    return pjsuaJNI.pjsua_conf_port_info_rx_level_adj_get(swigCPtr, this);
+  }
+
+  public void setListener_cnt(long value) {
+    pjsuaJNI.pjsua_conf_port_info_listener_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getListener_cnt() {
+    return pjsuaJNI.pjsua_conf_port_info_listener_cnt_get(swigCPtr, this);
+  }
+
+  public void setListeners(int[] value) {
+    pjsuaJNI.pjsua_conf_port_info_listeners_set(swigCPtr, this, value);
+  }
+
+  public int[] getListeners() {
+    return pjsuaJNI.pjsua_conf_port_info_listeners_get(swigCPtr, this);
+  }
+
+  public pjsua_conf_port_info() {
+    this(pjsuaJNI.new_pjsua_conf_port_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_config.java	(working copy)
@@ -0,0 +1,256 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setMax_calls(long value) {
+    pjsuaJNI.pjsua_config_max_calls_set(swigCPtr, this, value);
+  }
+
+  public long getMax_calls() {
+    return pjsuaJNI.pjsua_config_max_calls_get(swigCPtr, this);
+  }
+
+  public void setThread_cnt(long value) {
+    pjsuaJNI.pjsua_config_thread_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getThread_cnt() {
+    return pjsuaJNI.pjsua_config_thread_cnt_get(swigCPtr, this);
+  }
+
+  public void setNameserver_count(long value) {
+    pjsuaJNI.pjsua_config_nameserver_count_set(swigCPtr, this, value);
+  }
+
+  public long getNameserver_count() {
+    return pjsuaJNI.pjsua_config_nameserver_count_get(swigCPtr, this);
+  }
+
+  public void setNameserver(pj_str_t[] value) {
+    pjsuaJNI.pjsua_config_nameserver_set(swigCPtr, this, pj_str_t.cArrayUnwrap(value));
+  }
+
+  public pj_str_t[] getNameserver() {
+    return pj_str_t.cArrayWrap(pjsuaJNI.pjsua_config_nameserver_get(swigCPtr, this), false);
+  }
+
+  public void setForce_lr(int value) {
+    pjsuaJNI.pjsua_config_force_lr_set(swigCPtr, this, value);
+  }
+
+  public int getForce_lr() {
+    return pjsuaJNI.pjsua_config_force_lr_get(swigCPtr, this);
+  }
+
+  public void setOutbound_proxy_cnt(long value) {
+    pjsuaJNI.pjsua_config_outbound_proxy_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getOutbound_proxy_cnt() {
+    return pjsuaJNI.pjsua_config_outbound_proxy_cnt_get(swigCPtr, this);
+  }
+
+  public void setOutbound_proxy(pj_str_t[] value) {
+    pjsuaJNI.pjsua_config_outbound_proxy_set(swigCPtr, this, pj_str_t.cArrayUnwrap(value));
+  }
+
+  public pj_str_t[] getOutbound_proxy() {
+    return pj_str_t.cArrayWrap(pjsuaJNI.pjsua_config_outbound_proxy_get(swigCPtr, this), false);
+  }
+
+  public void setStun_domain(pj_str_t value) {
+    pjsuaJNI.pjsua_config_stun_domain_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getStun_domain() {
+    long cPtr = pjsuaJNI.pjsua_config_stun_domain_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setStun_host(pj_str_t value) {
+    pjsuaJNI.pjsua_config_stun_host_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getStun_host() {
+    long cPtr = pjsuaJNI.pjsua_config_stun_host_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setStun_srv_cnt(long value) {
+    pjsuaJNI.pjsua_config_stun_srv_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getStun_srv_cnt() {
+    return pjsuaJNI.pjsua_config_stun_srv_cnt_get(swigCPtr, this);
+  }
+
+  public void setStun_srv(pj_str_t[] value) {
+    pjsuaJNI.pjsua_config_stun_srv_set(swigCPtr, this, pj_str_t.cArrayUnwrap(value));
+  }
+
+  public pj_str_t[] getStun_srv() {
+    return pj_str_t.cArrayWrap(pjsuaJNI.pjsua_config_stun_srv_get(swigCPtr, this), false);
+  }
+
+  public void setStun_ignore_failure(int value) {
+    pjsuaJNI.pjsua_config_stun_ignore_failure_set(swigCPtr, this, value);
+  }
+
+  public int getStun_ignore_failure() {
+    return pjsuaJNI.pjsua_config_stun_ignore_failure_get(swigCPtr, this);
+  }
+
+  public void setStun_map_use_stun2(int value) {
+    pjsuaJNI.pjsua_config_stun_map_use_stun2_set(swigCPtr, this, value);
+  }
+
+  public int getStun_map_use_stun2() {
+    return pjsuaJNI.pjsua_config_stun_map_use_stun2_get(swigCPtr, this);
+  }
+
+  public void setNat_type_in_sdp(int value) {
+    pjsuaJNI.pjsua_config_nat_type_in_sdp_set(swigCPtr, this, value);
+  }
+
+  public int getNat_type_in_sdp() {
+    return pjsuaJNI.pjsua_config_nat_type_in_sdp_get(swigCPtr, this);
+  }
+
+  public void setRequire_100rel(pjsua_100rel_use value) {
+    pjsuaJNI.pjsua_config_require_100rel_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_100rel_use getRequire_100rel() {
+    return pjsua_100rel_use.swigToEnum(pjsuaJNI.pjsua_config_require_100rel_get(swigCPtr, this));
+  }
+
+  public void setUse_timer(pjsua_sip_timer_use value) {
+    pjsuaJNI.pjsua_config_use_timer_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_sip_timer_use getUse_timer() {
+    return pjsua_sip_timer_use.swigToEnum(pjsuaJNI.pjsua_config_use_timer_get(swigCPtr, this));
+  }
+
+  public void setEnable_unsolicited_mwi(int value) {
+    pjsuaJNI.pjsua_config_enable_unsolicited_mwi_set(swigCPtr, this, value);
+  }
+
+  public int getEnable_unsolicited_mwi() {
+    return pjsuaJNI.pjsua_config_enable_unsolicited_mwi_get(swigCPtr, this);
+  }
+
+  public void setTimer_setting(pjsip_timer_setting value) {
+    pjsuaJNI.pjsua_config_timer_setting_set(swigCPtr, this, pjsip_timer_setting.getCPtr(value), value);
+  }
+
+  public pjsip_timer_setting getTimer_setting() {
+    long cPtr = pjsuaJNI.pjsua_config_timer_setting_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsip_timer_setting(cPtr, false);
+  }
+
+  public void setCred_count(long value) {
+    pjsuaJNI.pjsua_config_cred_count_set(swigCPtr, this, value);
+  }
+
+  public long getCred_count() {
+    return pjsuaJNI.pjsua_config_cred_count_get(swigCPtr, this);
+  }
+
+  public void setCred_info(pjsip_cred_info value) {
+    pjsuaJNI.pjsua_config_cred_info_set(swigCPtr, this, pjsip_cred_info.getCPtr(value), value);
+  }
+
+  public pjsip_cred_info getCred_info() {
+    long cPtr = pjsuaJNI.pjsua_config_cred_info_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsip_cred_info(cPtr, false);
+  }
+
+  public void setCb(pjsua_callback value) {
+    pjsuaJNI.pjsua_config_cb_set(swigCPtr, this, pjsua_callback.getCPtr(value), value);
+  }
+
+  public pjsua_callback getCb() {
+    long cPtr = pjsuaJNI.pjsua_config_cb_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsua_callback(cPtr, false);
+  }
+
+  public void setUser_agent(pj_str_t value) {
+    pjsuaJNI.pjsua_config_user_agent_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getUser_agent() {
+    long cPtr = pjsuaJNI.pjsua_config_user_agent_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setUse_srtp(pjmedia_srtp_use value) {
+    pjsuaJNI.pjsua_config_use_srtp_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjmedia_srtp_use getUse_srtp() {
+    return pjmedia_srtp_use.swigToEnum(pjsuaJNI.pjsua_config_use_srtp_get(swigCPtr, this));
+  }
+
+  public void setSrtp_secure_signaling(int value) {
+    pjsuaJNI.pjsua_config_srtp_secure_signaling_set(swigCPtr, this, value);
+  }
+
+  public int getSrtp_secure_signaling() {
+    return pjsuaJNI.pjsua_config_srtp_secure_signaling_get(swigCPtr, this);
+  }
+
+  public void setSrtp_optional_dup_offer(int value) {
+    pjsuaJNI.pjsua_config_srtp_optional_dup_offer_set(swigCPtr, this, value);
+  }
+
+  public int getSrtp_optional_dup_offer() {
+    return pjsuaJNI.pjsua_config_srtp_optional_dup_offer_get(swigCPtr, this);
+  }
+
+  public void setHangup_forked_call(int value) {
+    pjsuaJNI.pjsua_config_hangup_forked_call_set(swigCPtr, this, value);
+  }
+
+  public int getHangup_forked_call() {
+    return pjsuaJNI.pjsua_config_hangup_forked_call_get(swigCPtr, this);
+  }
+
+  public pjsua_config() {
+    this(pjsuaJNI.new_pjsua_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_contact_rewrite_method.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_contact_rewrite_method.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_contact_rewrite_method.java	(working copy)
@@ -0,0 +1,53 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_contact_rewrite_method {
+  PJSUA_CONTACT_REWRITE_UNREGISTER(pjsuaJNI.PJSUA_CONTACT_REWRITE_UNREGISTER_get()),
+  PJSUA_CONTACT_REWRITE_NO_UNREG(pjsuaJNI.PJSUA_CONTACT_REWRITE_NO_UNREG_get()),
+  PJSUA_CONTACT_REWRITE_ALWAYS_UPDATE(pjsuaJNI.PJSUA_CONTACT_REWRITE_ALWAYS_UPDATE_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_contact_rewrite_method swigToEnum(int swigValue) {
+    pjsua_contact_rewrite_method[] swigValues = pjsua_contact_rewrite_method.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_contact_rewrite_method swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_contact_rewrite_method.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_contact_rewrite_method() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_contact_rewrite_method(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_contact_rewrite_method(pjsua_contact_rewrite_method swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_create_media_transport_flag.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_create_media_transport_flag.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_create_media_transport_flag.java	(working copy)
@@ -0,0 +1,51 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_create_media_transport_flag {
+  PJSUA_MED_TP_CLOSE_MEMBER(pjsuaJNI.PJSUA_MED_TP_CLOSE_MEMBER_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_create_media_transport_flag swigToEnum(int swigValue) {
+    pjsua_create_media_transport_flag[] swigValues = pjsua_create_media_transport_flag.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_create_media_transport_flag swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_create_media_transport_flag.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_create_media_transport_flag() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_create_media_transport_flag(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_create_media_transport_flag(pjsua_create_media_transport_flag swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_destroy_flag.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_destroy_flag.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_destroy_flag.java	(working copy)
@@ -0,0 +1,53 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_destroy_flag {
+  PJSUA_DESTROY_NO_RX_MSG(pjsuaJNI.PJSUA_DESTROY_NO_RX_MSG_get()),
+  PJSUA_DESTROY_NO_TX_MSG(pjsuaJNI.PJSUA_DESTROY_NO_TX_MSG_get()),
+  PJSUA_DESTROY_NO_NETWORK(pjsuaJNI.PJSUA_DESTROY_NO_NETWORK_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_destroy_flag swigToEnum(int swigValue) {
+    pjsua_destroy_flag[] swigValues = pjsua_destroy_flag.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_destroy_flag swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_destroy_flag.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_destroy_flag() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_destroy_flag(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_destroy_flag(pjsua_destroy_flag swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_ice_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_ice_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_ice_config.java	(working copy)
@@ -0,0 +1,83 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_ice_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_ice_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_ice_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_ice_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setEnable_ice(int value) {
+    pjsuaJNI.pjsua_ice_config_enable_ice_set(swigCPtr, this, value);
+  }
+
+  public int getEnable_ice() {
+    return pjsuaJNI.pjsua_ice_config_enable_ice_get(swigCPtr, this);
+  }
+
+  public void setIce_max_host_cands(int value) {
+    pjsuaJNI.pjsua_ice_config_ice_max_host_cands_set(swigCPtr, this, value);
+  }
+
+  public int getIce_max_host_cands() {
+    return pjsuaJNI.pjsua_ice_config_ice_max_host_cands_get(swigCPtr, this);
+  }
+
+  public void setIce_opt(pj_ice_sess_options value) {
+    pjsuaJNI.pjsua_ice_config_ice_opt_set(swigCPtr, this, pj_ice_sess_options.getCPtr(value), value);
+  }
+
+  public pj_ice_sess_options getIce_opt() {
+    long cPtr = pjsuaJNI.pjsua_ice_config_ice_opt_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_ice_sess_options(cPtr, false);
+  }
+
+  public void setIce_no_rtcp(int value) {
+    pjsuaJNI.pjsua_ice_config_ice_no_rtcp_set(swigCPtr, this, value);
+  }
+
+  public int getIce_no_rtcp() {
+    return pjsuaJNI.pjsua_ice_config_ice_no_rtcp_get(swigCPtr, this);
+  }
+
+  public void setIce_always_update(int value) {
+    pjsuaJNI.pjsua_ice_config_ice_always_update_set(swigCPtr, this, value);
+  }
+
+  public int getIce_always_update() {
+    return pjsuaJNI.pjsua_ice_config_ice_always_update_get(swigCPtr, this);
+  }
+
+  public pjsua_ice_config() {
+    this(pjsuaJNI.new_pjsua_ice_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_ice_config_use.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_ice_config_use.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_ice_config_use.java	(working copy)
@@ -0,0 +1,52 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_ice_config_use {
+  PJSUA_ICE_CONFIG_USE_DEFAULT,
+  PJSUA_ICE_CONFIG_USE_CUSTOM;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_ice_config_use swigToEnum(int swigValue) {
+    pjsua_ice_config_use[] swigValues = pjsua_ice_config_use.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_ice_config_use swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_ice_config_use.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_ice_config_use() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_ice_config_use(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_ice_config_use(pjsua_ice_config_use swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_invalid_id_const_.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_invalid_id_const_.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_invalid_id_const_.java	(working copy)
@@ -0,0 +1,51 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_invalid_id_const_ {
+  PJSUA_INVALID_ID(pjsuaJNI.PJSUA_INVALID_ID_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_invalid_id_const_ swigToEnum(int swigValue) {
+    pjsua_invalid_id_const_[] swigValues = pjsua_invalid_id_const_.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_invalid_id_const_ swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_invalid_id_const_.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_invalid_id_const_() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_invalid_id_const_(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_invalid_id_const_(pjsua_invalid_id_const_ swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_ipv6_use.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_ipv6_use.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_ipv6_use.java	(working copy)
@@ -0,0 +1,52 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_ipv6_use {
+  PJSUA_IPV6_DISABLED,
+  PJSUA_IPV6_ENABLED;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_ipv6_use swigToEnum(int swigValue) {
+    pjsua_ipv6_use[] swigValues = pjsua_ipv6_use.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_ipv6_use swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_ipv6_use.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_ipv6_use() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_ipv6_use(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_ipv6_use(pjsua_ipv6_use swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_logging_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_logging_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_logging_config.java	(working copy)
@@ -0,0 +1,100 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_logging_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_logging_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_logging_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_logging_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setMsg_logging(int value) {
+    pjsuaJNI.pjsua_logging_config_msg_logging_set(swigCPtr, this, value);
+  }
+
+  public int getMsg_logging() {
+    return pjsuaJNI.pjsua_logging_config_msg_logging_get(swigCPtr, this);
+  }
+
+  public void setLevel(long value) {
+    pjsuaJNI.pjsua_logging_config_level_set(swigCPtr, this, value);
+  }
+
+  public long getLevel() {
+    return pjsuaJNI.pjsua_logging_config_level_get(swigCPtr, this);
+  }
+
+  public void setConsole_level(long value) {
+    pjsuaJNI.pjsua_logging_config_console_level_set(swigCPtr, this, value);
+  }
+
+  public long getConsole_level() {
+    return pjsuaJNI.pjsua_logging_config_console_level_get(swigCPtr, this);
+  }
+
+  public void setDecor(long value) {
+    pjsuaJNI.pjsua_logging_config_decor_set(swigCPtr, this, value);
+  }
+
+  public long getDecor() {
+    return pjsuaJNI.pjsua_logging_config_decor_get(swigCPtr, this);
+  }
+
+  public void setLog_filename(pj_str_t value) {
+    pjsuaJNI.pjsua_logging_config_log_filename_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getLog_filename() {
+    long cPtr = pjsuaJNI.pjsua_logging_config_log_filename_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setLog_file_flags(long value) {
+    pjsuaJNI.pjsua_logging_config_log_file_flags_set(swigCPtr, this, value);
+  }
+
+  public long getLog_file_flags() {
+    return pjsuaJNI.pjsua_logging_config_log_file_flags_get(swigCPtr, this);
+  }
+
+  public void setCb(SWIGTYPE_p_f_int_p_q_const__char_int__void value) {
+    pjsuaJNI.pjsua_logging_config_cb_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__char_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__char_int__void getCb() {
+    long cPtr = pjsuaJNI.pjsua_logging_config_cb_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__char_int__void(cPtr, false);
+  }
+
+  public pjsua_logging_config() {
+    this(pjsuaJNI.new_pjsua_logging_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_med_tp_st.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_med_tp_st.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_med_tp_st.java	(working copy)
@@ -0,0 +1,56 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_med_tp_st {
+  PJSUA_MED_TP_NULL,
+  PJSUA_MED_TP_CREATING,
+  PJSUA_MED_TP_IDLE,
+  PJSUA_MED_TP_INIT,
+  PJSUA_MED_TP_RUNNING,
+  PJSUA_MED_TP_DISABLED;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_med_tp_st swigToEnum(int swigValue) {
+    pjsua_med_tp_st[] swigValues = pjsua_med_tp_st.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_med_tp_st swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_med_tp_st.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_med_tp_st() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_med_tp_st(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_med_tp_st(pjsua_med_tp_st swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_med_tp_state_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_med_tp_state_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_med_tp_state_info.java	(working copy)
@@ -0,0 +1,82 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_med_tp_state_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_med_tp_state_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_med_tp_state_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_med_tp_state_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setMed_idx(long value) {
+    pjsuaJNI.pjsua_med_tp_state_info_med_idx_set(swigCPtr, this, value);
+  }
+
+  public long getMed_idx() {
+    return pjsuaJNI.pjsua_med_tp_state_info_med_idx_get(swigCPtr, this);
+  }
+
+  public void setState(pjsua_med_tp_st value) {
+    pjsuaJNI.pjsua_med_tp_state_info_state_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_med_tp_st getState() {
+    return pjsua_med_tp_st.swigToEnum(pjsuaJNI.pjsua_med_tp_state_info_state_get(swigCPtr, this));
+  }
+
+  public void setStatus(int value) {
+    pjsuaJNI.pjsua_med_tp_state_info_status_set(swigCPtr, this, value);
+  }
+
+  public int getStatus() {
+    return pjsuaJNI.pjsua_med_tp_state_info_status_get(swigCPtr, this);
+  }
+
+  public void setSip_err_code(int value) {
+    pjsuaJNI.pjsua_med_tp_state_info_sip_err_code_set(swigCPtr, this, value);
+  }
+
+  public int getSip_err_code() {
+    return pjsuaJNI.pjsua_med_tp_state_info_sip_err_code_get(swigCPtr, this);
+  }
+
+  public void setExt_info(byte[] value) {
+    pjsuaJNI.pjsua_med_tp_state_info_ext_info_set(swigCPtr, this, value);
+  }
+
+  public byte[] getExt_info() {
+	return pjsuaJNI.pjsua_med_tp_state_info_ext_info_get(swigCPtr, this);
+}
+
+  public pjsua_med_tp_state_info() {
+    this(pjsuaJNI.new_pjsua_med_tp_state_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_media_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_media_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_media_config.java	(working copy)
@@ -0,0 +1,316 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_media_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_media_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_media_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_media_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setClock_rate(long value) {
+    pjsuaJNI.pjsua_media_config_clock_rate_set(swigCPtr, this, value);
+  }
+
+  public long getClock_rate() {
+    return pjsuaJNI.pjsua_media_config_clock_rate_get(swigCPtr, this);
+  }
+
+  public void setSnd_clock_rate(long value) {
+    pjsuaJNI.pjsua_media_config_snd_clock_rate_set(swigCPtr, this, value);
+  }
+
+  public long getSnd_clock_rate() {
+    return pjsuaJNI.pjsua_media_config_snd_clock_rate_get(swigCPtr, this);
+  }
+
+  public void setChannel_count(long value) {
+    pjsuaJNI.pjsua_media_config_channel_count_set(swigCPtr, this, value);
+  }
+
+  public long getChannel_count() {
+    return pjsuaJNI.pjsua_media_config_channel_count_get(swigCPtr, this);
+  }
+
+  public void setAudio_frame_ptime(long value) {
+    pjsuaJNI.pjsua_media_config_audio_frame_ptime_set(swigCPtr, this, value);
+  }
+
+  public long getAudio_frame_ptime() {
+    return pjsuaJNI.pjsua_media_config_audio_frame_ptime_get(swigCPtr, this);
+  }
+
+  public void setMax_media_ports(long value) {
+    pjsuaJNI.pjsua_media_config_max_media_ports_set(swigCPtr, this, value);
+  }
+
+  public long getMax_media_ports() {
+    return pjsuaJNI.pjsua_media_config_max_media_ports_get(swigCPtr, this);
+  }
+
+  public void setHas_ioqueue(int value) {
+    pjsuaJNI.pjsua_media_config_has_ioqueue_set(swigCPtr, this, value);
+  }
+
+  public int getHas_ioqueue() {
+    return pjsuaJNI.pjsua_media_config_has_ioqueue_get(swigCPtr, this);
+  }
+
+  public void setThread_cnt(long value) {
+    pjsuaJNI.pjsua_media_config_thread_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getThread_cnt() {
+    return pjsuaJNI.pjsua_media_config_thread_cnt_get(swigCPtr, this);
+  }
+
+  public void setQuality(long value) {
+    pjsuaJNI.pjsua_media_config_quality_set(swigCPtr, this, value);
+  }
+
+  public long getQuality() {
+    return pjsuaJNI.pjsua_media_config_quality_get(swigCPtr, this);
+  }
+
+  public void setPtime(long value) {
+    pjsuaJNI.pjsua_media_config_ptime_set(swigCPtr, this, value);
+  }
+
+  public long getPtime() {
+    return pjsuaJNI.pjsua_media_config_ptime_get(swigCPtr, this);
+  }
+
+  public void setNo_vad(int value) {
+    pjsuaJNI.pjsua_media_config_no_vad_set(swigCPtr, this, value);
+  }
+
+  public int getNo_vad() {
+    return pjsuaJNI.pjsua_media_config_no_vad_get(swigCPtr, this);
+  }
+
+  public void setIlbc_mode(long value) {
+    pjsuaJNI.pjsua_media_config_ilbc_mode_set(swigCPtr, this, value);
+  }
+
+  public long getIlbc_mode() {
+    return pjsuaJNI.pjsua_media_config_ilbc_mode_get(swigCPtr, this);
+  }
+
+  public void setTx_drop_pct(long value) {
+    pjsuaJNI.pjsua_media_config_tx_drop_pct_set(swigCPtr, this, value);
+  }
+
+  public long getTx_drop_pct() {
+    return pjsuaJNI.pjsua_media_config_tx_drop_pct_get(swigCPtr, this);
+  }
+
+  public void setRx_drop_pct(long value) {
+    pjsuaJNI.pjsua_media_config_rx_drop_pct_set(swigCPtr, this, value);
+  }
+
+  public long getRx_drop_pct() {
+    return pjsuaJNI.pjsua_media_config_rx_drop_pct_get(swigCPtr, this);
+  }
+
+  public void setEc_options(long value) {
+    pjsuaJNI.pjsua_media_config_ec_options_set(swigCPtr, this, value);
+  }
+
+  public long getEc_options() {
+    return pjsuaJNI.pjsua_media_config_ec_options_get(swigCPtr, this);
+  }
+
+  public void setEc_tail_len(long value) {
+    pjsuaJNI.pjsua_media_config_ec_tail_len_set(swigCPtr, this, value);
+  }
+
+  public long getEc_tail_len() {
+    return pjsuaJNI.pjsua_media_config_ec_tail_len_get(swigCPtr, this);
+  }
+
+  public void setSnd_rec_latency(long value) {
+    pjsuaJNI.pjsua_media_config_snd_rec_latency_set(swigCPtr, this, value);
+  }
+
+  public long getSnd_rec_latency() {
+    return pjsuaJNI.pjsua_media_config_snd_rec_latency_get(swigCPtr, this);
+  }
+
+  public void setSnd_play_latency(long value) {
+    pjsuaJNI.pjsua_media_config_snd_play_latency_set(swigCPtr, this, value);
+  }
+
+  public long getSnd_play_latency() {
+    return pjsuaJNI.pjsua_media_config_snd_play_latency_get(swigCPtr, this);
+  }
+
+  public void setJb_init(int value) {
+    pjsuaJNI.pjsua_media_config_jb_init_set(swigCPtr, this, value);
+  }
+
+  public int getJb_init() {
+    return pjsuaJNI.pjsua_media_config_jb_init_get(swigCPtr, this);
+  }
+
+  public void setJb_min_pre(int value) {
+    pjsuaJNI.pjsua_media_config_jb_min_pre_set(swigCPtr, this, value);
+  }
+
+  public int getJb_min_pre() {
+    return pjsuaJNI.pjsua_media_config_jb_min_pre_get(swigCPtr, this);
+  }
+
+  public void setJb_max_pre(int value) {
+    pjsuaJNI.pjsua_media_config_jb_max_pre_set(swigCPtr, this, value);
+  }
+
+  public int getJb_max_pre() {
+    return pjsuaJNI.pjsua_media_config_jb_max_pre_get(swigCPtr, this);
+  }
+
+  public void setJb_max(int value) {
+    pjsuaJNI.pjsua_media_config_jb_max_set(swigCPtr, this, value);
+  }
+
+  public int getJb_max() {
+    return pjsuaJNI.pjsua_media_config_jb_max_get(swigCPtr, this);
+  }
+
+  public void setEnable_ice(int value) {
+    pjsuaJNI.pjsua_media_config_enable_ice_set(swigCPtr, this, value);
+  }
+
+  public int getEnable_ice() {
+    return pjsuaJNI.pjsua_media_config_enable_ice_get(swigCPtr, this);
+  }
+
+  public void setIce_max_host_cands(int value) {
+    pjsuaJNI.pjsua_media_config_ice_max_host_cands_set(swigCPtr, this, value);
+  }
+
+  public int getIce_max_host_cands() {
+    return pjsuaJNI.pjsua_media_config_ice_max_host_cands_get(swigCPtr, this);
+  }
+
+  public void setIce_opt(pj_ice_sess_options value) {
+    pjsuaJNI.pjsua_media_config_ice_opt_set(swigCPtr, this, pj_ice_sess_options.getCPtr(value), value);
+  }
+
+  public pj_ice_sess_options getIce_opt() {
+    long cPtr = pjsuaJNI.pjsua_media_config_ice_opt_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_ice_sess_options(cPtr, false);
+  }
+
+  public void setIce_no_rtcp(int value) {
+    pjsuaJNI.pjsua_media_config_ice_no_rtcp_set(swigCPtr, this, value);
+  }
+
+  public int getIce_no_rtcp() {
+    return pjsuaJNI.pjsua_media_config_ice_no_rtcp_get(swigCPtr, this);
+  }
+
+  public void setIce_always_update(int value) {
+    pjsuaJNI.pjsua_media_config_ice_always_update_set(swigCPtr, this, value);
+  }
+
+  public int getIce_always_update() {
+    return pjsuaJNI.pjsua_media_config_ice_always_update_get(swigCPtr, this);
+  }
+
+  public void setEnable_turn(int value) {
+    pjsuaJNI.pjsua_media_config_enable_turn_set(swigCPtr, this, value);
+  }
+
+  public int getEnable_turn() {
+    return pjsuaJNI.pjsua_media_config_enable_turn_get(swigCPtr, this);
+  }
+
+  public void setTurn_server(pj_str_t value) {
+    pjsuaJNI.pjsua_media_config_turn_server_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getTurn_server() {
+    long cPtr = pjsuaJNI.pjsua_media_config_turn_server_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setTurn_conn_type(pj_turn_tp_type value) {
+    pjsuaJNI.pjsua_media_config_turn_conn_type_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pj_turn_tp_type getTurn_conn_type() {
+    return pj_turn_tp_type.swigToEnum(pjsuaJNI.pjsua_media_config_turn_conn_type_get(swigCPtr, this));
+  }
+
+  public void setTurn_auth_cred(SWIGTYPE_p_pj_stun_auth_cred value) {
+    pjsuaJNI.pjsua_media_config_turn_auth_cred_set(swigCPtr, this, SWIGTYPE_p_pj_stun_auth_cred.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_stun_auth_cred getTurn_auth_cred() {
+    return new SWIGTYPE_p_pj_stun_auth_cred(pjsuaJNI.pjsua_media_config_turn_auth_cred_get(swigCPtr, this), true);
+  }
+
+  public void setSnd_auto_close_time(int value) {
+    pjsuaJNI.pjsua_media_config_snd_auto_close_time_set(swigCPtr, this, value);
+  }
+
+  public int getSnd_auto_close_time() {
+    return pjsuaJNI.pjsua_media_config_snd_auto_close_time_get(swigCPtr, this);
+  }
+
+  public void setVid_preview_enable_native(int value) {
+    pjsuaJNI.pjsua_media_config_vid_preview_enable_native_set(swigCPtr, this, value);
+  }
+
+  public int getVid_preview_enable_native() {
+    return pjsuaJNI.pjsua_media_config_vid_preview_enable_native_get(swigCPtr, this);
+  }
+
+  public void setNo_smart_media_update(int value) {
+    pjsuaJNI.pjsua_media_config_no_smart_media_update_set(swigCPtr, this, value);
+  }
+
+  public int getNo_smart_media_update() {
+    return pjsuaJNI.pjsua_media_config_no_smart_media_update_get(swigCPtr, this);
+  }
+
+  public void setNo_rtcp_sdes_bye(int value) {
+    pjsuaJNI.pjsua_media_config_no_rtcp_sdes_bye_set(swigCPtr, this, value);
+  }
+
+  public int getNo_rtcp_sdes_bye() {
+    return pjsuaJNI.pjsua_media_config_no_rtcp_sdes_bye_get(swigCPtr, this);
+  }
+
+  public pjsua_media_config() {
+    this(pjsuaJNI.new_pjsua_media_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_media_transport.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_media_transport.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_media_transport.java	(working copy)
@@ -0,0 +1,59 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_media_transport {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_media_transport(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_media_transport obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_media_transport(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setSkinfo(SWIGTYPE_p_pjmedia_sock_info value) {
+    pjsuaJNI.pjsua_media_transport_skinfo_set(swigCPtr, this, SWIGTYPE_p_pjmedia_sock_info.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_sock_info getSkinfo() {
+    return new SWIGTYPE_p_pjmedia_sock_info(pjsuaJNI.pjsua_media_transport_skinfo_get(swigCPtr, this), true);
+  }
+
+  public void setTransport(SWIGTYPE_p_pjmedia_transport value) {
+    pjsuaJNI.pjsua_media_transport_transport_set(swigCPtr, this, SWIGTYPE_p_pjmedia_transport.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_transport getTransport() {
+    long cPtr = pjsuaJNI.pjsua_media_transport_transport_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pjmedia_transport(cPtr, false);
+  }
+
+  public pjsua_media_transport() {
+    this(pjsuaJNI.new_pjsua_media_transport(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_msg_data.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_msg_data.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_msg_data.java	(working copy)
@@ -0,0 +1,93 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_msg_data {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_msg_data(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_msg_data obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_msg_data(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setTarget_uri(pj_str_t value) {
+    pjsuaJNI.pjsua_msg_data_target_uri_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getTarget_uri() {
+    long cPtr = pjsuaJNI.pjsua_msg_data_target_uri_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setHdr_list(SWIGTYPE_p_pjsip_hdr value) {
+    pjsuaJNI.pjsua_msg_data_hdr_list_set(swigCPtr, this, SWIGTYPE_p_pjsip_hdr.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_hdr getHdr_list() {
+    return new SWIGTYPE_p_pjsip_hdr(pjsuaJNI.pjsua_msg_data_hdr_list_get(swigCPtr, this), true);
+  }
+
+  public void setContent_type(pj_str_t value) {
+    pjsuaJNI.pjsua_msg_data_content_type_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getContent_type() {
+    long cPtr = pjsuaJNI.pjsua_msg_data_content_type_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setMsg_body(pj_str_t value) {
+    pjsuaJNI.pjsua_msg_data_msg_body_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getMsg_body() {
+    long cPtr = pjsuaJNI.pjsua_msg_data_msg_body_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setMultipart_ctype(SWIGTYPE_p_pjsip_media_type value) {
+    pjsuaJNI.pjsua_msg_data_multipart_ctype_set(swigCPtr, this, SWIGTYPE_p_pjsip_media_type.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_media_type getMultipart_ctype() {
+    return new SWIGTYPE_p_pjsip_media_type(pjsuaJNI.pjsua_msg_data_multipart_ctype_get(swigCPtr, this), true);
+  }
+
+  public void setMultipart_parts(SWIGTYPE_p_pjsip_multipart_part value) {
+    pjsuaJNI.pjsua_msg_data_multipart_parts_set(swigCPtr, this, SWIGTYPE_p_pjsip_multipart_part.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_multipart_part getMultipart_parts() {
+    return new SWIGTYPE_p_pjsip_multipart_part(pjsuaJNI.pjsua_msg_data_multipart_parts_get(swigCPtr, this), true);
+  }
+
+  public pjsua_msg_data() {
+    this(pjsuaJNI.new_pjsua_msg_data(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_mwi_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_mwi_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_mwi_info.java	(working copy)
@@ -0,0 +1,60 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_mwi_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_mwi_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_mwi_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_mwi_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setEvsub(SWIGTYPE_p_pjsip_evsub value) {
+    pjsuaJNI.pjsua_mwi_info_evsub_set(swigCPtr, this, SWIGTYPE_p_pjsip_evsub.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_evsub getEvsub() {
+    long cPtr = pjsuaJNI.pjsua_mwi_info_evsub_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pjsip_evsub(cPtr, false);
+  }
+
+  public void setRdata(SWIGTYPE_p_pjsip_rx_data value) {
+    pjsuaJNI.pjsua_mwi_info_rdata_set(swigCPtr, this, SWIGTYPE_p_pjsip_rx_data.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_rx_data getRdata() {
+    long cPtr = pjsuaJNI.pjsua_mwi_info_rdata_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pjsip_rx_data(cPtr, false);
+  }
+
+  public pjsua_mwi_info() {
+    this(pjsuaJNI.new_pjsua_mwi_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_reg_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_reg_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_reg_info.java	(working copy)
@@ -0,0 +1,51 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_reg_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_reg_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_reg_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_reg_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setCbparam(SWIGTYPE_p_pjsip_regc_cbparam value) {
+    pjsuaJNI.pjsua_reg_info_cbparam_set(swigCPtr, this, SWIGTYPE_p_pjsip_regc_cbparam.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_regc_cbparam getCbparam() {
+    long cPtr = pjsuaJNI.pjsua_reg_info_cbparam_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pjsip_regc_cbparam(cPtr, false);
+  }
+
+  public pjsua_reg_info() {
+    this(pjsuaJNI.new_pjsua_reg_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_sip_timer_use.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_sip_timer_use.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_sip_timer_use.java	(working copy)
@@ -0,0 +1,54 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_sip_timer_use {
+  PJSUA_SIP_TIMER_INACTIVE,
+  PJSUA_SIP_TIMER_OPTIONAL,
+  PJSUA_SIP_TIMER_REQUIRED,
+  PJSUA_SIP_TIMER_ALWAYS;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_sip_timer_use swigToEnum(int swigValue) {
+    pjsua_sip_timer_use[] swigValues = pjsua_sip_timer_use.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_sip_timer_use swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_sip_timer_use.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_sip_timer_use() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_sip_timer_use(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_sip_timer_use(pjsua_sip_timer_use swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_state.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_state.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_state.java	(working copy)
@@ -0,0 +1,56 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_state {
+  PJSUA_STATE_NULL,
+  PJSUA_STATE_CREATED,
+  PJSUA_STATE_INIT,
+  PJSUA_STATE_STARTING,
+  PJSUA_STATE_RUNNING,
+  PJSUA_STATE_CLOSING;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_state swigToEnum(int swigValue) {
+    pjsua_state[] swigValues = pjsua_state.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_state swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_state.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_state() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_state(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_state(pjsua_state swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_stream_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_stream_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_stream_info.java	(working copy)
@@ -0,0 +1,50 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_stream_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_stream_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_stream_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_stream_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setType(SWIGTYPE_p_pjmedia_type value) {
+    pjsuaJNI.pjsua_stream_info_type_set(swigCPtr, this, SWIGTYPE_p_pjmedia_type.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_type getType() {
+    return new SWIGTYPE_p_pjmedia_type(pjsuaJNI.pjsua_stream_info_type_get(swigCPtr, this), true);
+  }
+
+  public pjsua_stream_info() {
+    this(pjsuaJNI.new_pjsua_stream_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_stream_stat.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_stream_stat.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_stream_stat.java	(working copy)
@@ -0,0 +1,58 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_stream_stat {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_stream_stat(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_stream_stat obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_stream_stat(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setRtcp(SWIGTYPE_p_pjmedia_rtcp_stat value) {
+    pjsuaJNI.pjsua_stream_stat_rtcp_set(swigCPtr, this, SWIGTYPE_p_pjmedia_rtcp_stat.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_rtcp_stat getRtcp() {
+    return new SWIGTYPE_p_pjmedia_rtcp_stat(pjsuaJNI.pjsua_stream_stat_rtcp_get(swigCPtr, this), true);
+  }
+
+  public void setJbuf(SWIGTYPE_p_pjmedia_jb_state value) {
+    pjsuaJNI.pjsua_stream_stat_jbuf_set(swigCPtr, this, SWIGTYPE_p_pjmedia_jb_state.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_jb_state getJbuf() {
+    return new SWIGTYPE_p_pjmedia_jb_state(pjsuaJNI.pjsua_stream_stat_jbuf_get(swigCPtr, this), true);
+  }
+
+  public pjsua_stream_stat() {
+    this(pjsuaJNI.new_pjsua_stream_stat(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_stun_use.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_stun_use.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_stun_use.java	(working copy)
@@ -0,0 +1,52 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_stun_use {
+  PJSUA_STUN_USE_DEFAULT,
+  PJSUA_STUN_USE_DISABLED;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_stun_use swigToEnum(int swigValue) {
+    pjsua_stun_use[] swigValues = pjsua_stun_use.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_stun_use swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_stun_use.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_stun_use() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_stun_use(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_stun_use(pjsua_stun_use swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_transport_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_transport_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_transport_config.java	(working copy)
@@ -0,0 +1,110 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_transport_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_transport_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_transport_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_transport_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setPort(long value) {
+    pjsuaJNI.pjsua_transport_config_port_set(swigCPtr, this, value);
+  }
+
+  public long getPort() {
+    return pjsuaJNI.pjsua_transport_config_port_get(swigCPtr, this);
+  }
+
+  public void setPort_range(long value) {
+    pjsuaJNI.pjsua_transport_config_port_range_set(swigCPtr, this, value);
+  }
+
+  public long getPort_range() {
+    return pjsuaJNI.pjsua_transport_config_port_range_get(swigCPtr, this);
+  }
+
+  public void setPublic_addr(pj_str_t value) {
+    pjsuaJNI.pjsua_transport_config_public_addr_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getPublic_addr() {
+    long cPtr = pjsuaJNI.pjsua_transport_config_public_addr_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setBound_addr(pj_str_t value) {
+    pjsuaJNI.pjsua_transport_config_bound_addr_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getBound_addr() {
+    long cPtr = pjsuaJNI.pjsua_transport_config_bound_addr_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setTls_setting(pjsip_tls_setting value) {
+    pjsuaJNI.pjsua_transport_config_tls_setting_set(swigCPtr, this, pjsip_tls_setting.getCPtr(value), value);
+  }
+
+  public pjsip_tls_setting getTls_setting() {
+    long cPtr = pjsuaJNI.pjsua_transport_config_tls_setting_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsip_tls_setting(cPtr, false);
+  }
+
+  public void setQos_type(pj_qos_type value) {
+    pjsuaJNI.pjsua_transport_config_qos_type_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pj_qos_type getQos_type() {
+    return pj_qos_type.swigToEnum(pjsuaJNI.pjsua_transport_config_qos_type_get(swigCPtr, this));
+  }
+
+  public void setQos_params(pj_qos_params value) {
+    pjsuaJNI.pjsua_transport_config_qos_params_set(swigCPtr, this, pj_qos_params.getCPtr(value), value);
+  }
+
+  public pj_qos_params getQos_params() {
+    long cPtr = pjsuaJNI.pjsua_transport_config_qos_params_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_qos_params(cPtr, false);
+  }
+
+  public void setSockopt_params(SWIGTYPE_p_pj_sockopt_params value) {
+    pjsuaJNI.pjsua_transport_config_sockopt_params_set(swigCPtr, this, SWIGTYPE_p_pj_sockopt_params.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_sockopt_params getSockopt_params() {
+    return new SWIGTYPE_p_pj_sockopt_params(pjsuaJNI.pjsua_transport_config_sockopt_params_get(swigCPtr, this), true);
+  }
+
+  public pjsua_transport_config() {
+    this(pjsuaJNI.new_pjsua_transport_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_transport_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_transport_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_transport_info.java	(working copy)
@@ -0,0 +1,116 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_transport_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_transport_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_transport_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_transport_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setId(int value) {
+    pjsuaJNI.pjsua_transport_info_id_set(swigCPtr, this, value);
+  }
+
+  public int getId() {
+    return pjsuaJNI.pjsua_transport_info_id_get(swigCPtr, this);
+  }
+
+  public void setType(pjsip_transport_type_e value) {
+    pjsuaJNI.pjsua_transport_info_type_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsip_transport_type_e getType() {
+    return pjsip_transport_type_e.swigToEnum(pjsuaJNI.pjsua_transport_info_type_get(swigCPtr, this));
+  }
+
+  public void setType_name(pj_str_t value) {
+    pjsuaJNI.pjsua_transport_info_type_name_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getType_name() {
+    long cPtr = pjsuaJNI.pjsua_transport_info_type_name_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setInfo(pj_str_t value) {
+    pjsuaJNI.pjsua_transport_info_info_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getInfo() {
+    long cPtr = pjsuaJNI.pjsua_transport_info_info_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setFlag(long value) {
+    pjsuaJNI.pjsua_transport_info_flag_set(swigCPtr, this, value);
+  }
+
+  public long getFlag() {
+    return pjsuaJNI.pjsua_transport_info_flag_get(swigCPtr, this);
+  }
+
+  public void setAddr_len(long value) {
+    pjsuaJNI.pjsua_transport_info_addr_len_set(swigCPtr, this, value);
+  }
+
+  public long getAddr_len() {
+    return pjsuaJNI.pjsua_transport_info_addr_len_get(swigCPtr, this);
+  }
+
+  public void setLocal_addr(SWIGTYPE_p_pj_sockaddr value) {
+    pjsuaJNI.pjsua_transport_info_local_addr_set(swigCPtr, this, SWIGTYPE_p_pj_sockaddr.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_sockaddr getLocal_addr() {
+    return new SWIGTYPE_p_pj_sockaddr(pjsuaJNI.pjsua_transport_info_local_addr_get(swigCPtr, this), true);
+  }
+
+  public void setLocal_name(SWIGTYPE_p_pjsip_host_port value) {
+    pjsuaJNI.pjsua_transport_info_local_name_set(swigCPtr, this, SWIGTYPE_p_pjsip_host_port.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_host_port getLocal_name() {
+    return new SWIGTYPE_p_pjsip_host_port(pjsuaJNI.pjsua_transport_info_local_name_get(swigCPtr, this), true);
+  }
+
+  public void setUsage_count(long value) {
+    pjsuaJNI.pjsua_transport_info_usage_count_set(swigCPtr, this, value);
+  }
+
+  public long getUsage_count() {
+    return pjsuaJNI.pjsua_transport_info_usage_count_get(swigCPtr, this);
+  }
+
+  public pjsua_transport_info() {
+    this(pjsuaJNI.new_pjsua_transport_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_turn_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_turn_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_turn_config.java	(working copy)
@@ -0,0 +1,75 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_turn_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_turn_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_turn_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_turn_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setEnable_turn(int value) {
+    pjsuaJNI.pjsua_turn_config_enable_turn_set(swigCPtr, this, value);
+  }
+
+  public int getEnable_turn() {
+    return pjsuaJNI.pjsua_turn_config_enable_turn_get(swigCPtr, this);
+  }
+
+  public void setTurn_server(pj_str_t value) {
+    pjsuaJNI.pjsua_turn_config_turn_server_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getTurn_server() {
+    long cPtr = pjsuaJNI.pjsua_turn_config_turn_server_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setTurn_conn_type(pj_turn_tp_type value) {
+    pjsuaJNI.pjsua_turn_config_turn_conn_type_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pj_turn_tp_type getTurn_conn_type() {
+    return pj_turn_tp_type.swigToEnum(pjsuaJNI.pjsua_turn_config_turn_conn_type_get(swigCPtr, this));
+  }
+
+  public void setTurn_auth_cred(SWIGTYPE_p_pj_stun_auth_cred value) {
+    pjsuaJNI.pjsua_turn_config_turn_auth_cred_set(swigCPtr, this, SWIGTYPE_p_pj_stun_auth_cred.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_stun_auth_cred getTurn_auth_cred() {
+    return new SWIGTYPE_p_pj_stun_auth_cred(pjsuaJNI.pjsua_turn_config_turn_auth_cred_get(swigCPtr, this), true);
+  }
+
+  public pjsua_turn_config() {
+    this(pjsuaJNI.new_pjsua_turn_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_turn_config_use.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_turn_config_use.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_turn_config_use.java	(working copy)
@@ -0,0 +1,52 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_turn_config_use {
+  PJSUA_TURN_CONFIG_USE_DEFAULT,
+  PJSUA_TURN_CONFIG_USE_CUSTOM;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_turn_config_use swigToEnum(int swigValue) {
+    pjsua_turn_config_use[] swigValues = pjsua_turn_config_use.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_turn_config_use swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_turn_config_use.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_turn_config_use() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_turn_config_use(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_turn_config_use(pjsua_turn_config_use swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_vid_preview_param.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_vid_preview_param.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_vid_preview_param.java	(working copy)
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_vid_preview_param {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_vid_preview_param(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_vid_preview_param obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_vid_preview_param(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setRend_id(SWIGTYPE_p_pjmedia_vid_dev_index value) {
+    pjsuaJNI.pjsua_vid_preview_param_rend_id_set(swigCPtr, this, SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_vid_dev_index getRend_id() {
+    return new SWIGTYPE_p_pjmedia_vid_dev_index(pjsuaJNI.pjsua_vid_preview_param_rend_id_get(swigCPtr, this), true);
+  }
+
+  public void setShow(int value) {
+    pjsuaJNI.pjsua_vid_preview_param_show_set(swigCPtr, this, value);
+  }
+
+  public int getShow() {
+    return pjsuaJNI.pjsua_vid_preview_param_show_get(swigCPtr, this);
+  }
+
+  public void setWnd_flags(long value) {
+    pjsuaJNI.pjsua_vid_preview_param_wnd_flags_set(swigCPtr, this, value);
+  }
+
+  public long getWnd_flags() {
+    return pjsuaJNI.pjsua_vid_preview_param_wnd_flags_get(swigCPtr, this);
+  }
+
+  public void setFormat(SWIGTYPE_p_pjmedia_format value) {
+    pjsuaJNI.pjsua_vid_preview_param_format_set(swigCPtr, this, SWIGTYPE_p_pjmedia_format.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_format getFormat() {
+    return new SWIGTYPE_p_pjmedia_format(pjsuaJNI.pjsua_vid_preview_param_format_get(swigCPtr, this), true);
+  }
+
+  public pjsua_vid_preview_param() {
+    this(pjsuaJNI.new_pjsua_vid_preview_param(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_vid_req_keyframe_method.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_vid_req_keyframe_method.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_vid_req_keyframe_method.java	(working copy)
@@ -0,0 +1,52 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_vid_req_keyframe_method {
+  PJSUA_VID_REQ_KEYFRAME_SIP_INFO(pjsuaJNI.PJSUA_VID_REQ_KEYFRAME_SIP_INFO_get()),
+  PJSUA_VID_REQ_KEYFRAME_RTCP_PLI(pjsuaJNI.PJSUA_VID_REQ_KEYFRAME_RTCP_PLI_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_vid_req_keyframe_method swigToEnum(int swigValue) {
+    pjsua_vid_req_keyframe_method[] swigValues = pjsua_vid_req_keyframe_method.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_vid_req_keyframe_method swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_vid_req_keyframe_method.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_vid_req_keyframe_method() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_vid_req_keyframe_method(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_vid_req_keyframe_method(pjsua_vid_req_keyframe_method swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_vid_win_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_vid_win_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_vid_win_info.java	(working copy)
@@ -0,0 +1,90 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_vid_win_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_vid_win_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_vid_win_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_vid_win_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setIs_native(int value) {
+    pjsuaJNI.pjsua_vid_win_info_is_native_set(swigCPtr, this, value);
+  }
+
+  public int getIs_native() {
+    return pjsuaJNI.pjsua_vid_win_info_is_native_get(swigCPtr, this);
+  }
+
+  public void setHwnd(SWIGTYPE_p_pjmedia_vid_dev_hwnd value) {
+    pjsuaJNI.pjsua_vid_win_info_hwnd_set(swigCPtr, this, SWIGTYPE_p_pjmedia_vid_dev_hwnd.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_vid_dev_hwnd getHwnd() {
+    return new SWIGTYPE_p_pjmedia_vid_dev_hwnd(pjsuaJNI.pjsua_vid_win_info_hwnd_get(swigCPtr, this), true);
+  }
+
+  public void setRdr_dev(SWIGTYPE_p_pjmedia_vid_dev_index value) {
+    pjsuaJNI.pjsua_vid_win_info_rdr_dev_set(swigCPtr, this, SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_vid_dev_index getRdr_dev() {
+    return new SWIGTYPE_p_pjmedia_vid_dev_index(pjsuaJNI.pjsua_vid_win_info_rdr_dev_get(swigCPtr, this), true);
+  }
+
+  public void setShow(int value) {
+    pjsuaJNI.pjsua_vid_win_info_show_set(swigCPtr, this, value);
+  }
+
+  public int getShow() {
+    return pjsuaJNI.pjsua_vid_win_info_show_get(swigCPtr, this);
+  }
+
+  public void setPos(SWIGTYPE_p_pjmedia_coord value) {
+    pjsuaJNI.pjsua_vid_win_info_pos_set(swigCPtr, this, SWIGTYPE_p_pjmedia_coord.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_coord getPos() {
+    return new SWIGTYPE_p_pjmedia_coord(pjsuaJNI.pjsua_vid_win_info_pos_get(swigCPtr, this), true);
+  }
+
+  public void setSize(SWIGTYPE_p_pjmedia_rect_size value) {
+    pjsuaJNI.pjsua_vid_win_info_size_set(swigCPtr, this, SWIGTYPE_p_pjmedia_rect_size.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_rect_size getSize() {
+    return new SWIGTYPE_p_pjmedia_rect_size(pjsuaJNI.pjsua_vid_win_info_size_get(swigCPtr, this), true);
+  }
+
+  public pjsua_vid_win_info() {
+    this(pjsuaJNI.new_pjsua_vid_win_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/zrtp_state_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/zrtp_state_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/zrtp_state_info.java	(working copy)
@@ -0,0 +1,84 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class zrtp_state_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected zrtp_state_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(zrtp_state_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_zrtp_state_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setCall_id(int value) {
+    pjsuaJNI.zrtp_state_info_call_id_set(swigCPtr, this, value);
+  }
+
+  public int getCall_id() {
+    return pjsuaJNI.zrtp_state_info_call_id_get(swigCPtr, this);
+  }
+
+  public void setSecure(int value) {
+    pjsuaJNI.zrtp_state_info_secure_set(swigCPtr, this, value);
+  }
+
+  public int getSecure() {
+    return pjsuaJNI.zrtp_state_info_secure_get(swigCPtr, this);
+  }
+
+  public void setSas(pj_str_t value) {
+    pjsuaJNI.zrtp_state_info_sas_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getSas() {
+    long cPtr = pjsuaJNI.zrtp_state_info_sas_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setCipher(pj_str_t value) {
+    pjsuaJNI.zrtp_state_info_cipher_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getCipher() {
+    long cPtr = pjsuaJNI.zrtp_state_info_cipher_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setSas_verified(int value) {
+    pjsuaJNI.zrtp_state_info_sas_verified_set(swigCPtr, this, value);
+  }
+
+  public int getSas_verified() {
+    return pjsuaJNI.zrtp_state_info_sas_verified_get(swigCPtr, this);
+  }
+
+  public zrtp_state_info() {
+    this(pjsuaJNI.new_zrtp_state_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/Callback.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/Callback.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/Callback.java	(working copy)
@@ -0,0 +1,175 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class Callback {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected Callback(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(Callback obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_Callback(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  protected void swigDirectorDisconnect() {
+    swigCMemOwn = false;
+    delete();
+  }
+
+  public void swigReleaseOwnership() {
+    swigCMemOwn = false;
+    pjsuaJNI.Callback_change_ownership(this, swigCPtr, false);
+  }
+
+  public void swigTakeOwnership() {
+    swigCMemOwn = true;
+    pjsuaJNI.Callback_change_ownership(this, swigCPtr, true);
+  }
+
+  public void on_call_state(int call_id, pjsip_event e) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_state(swigCPtr, this, call_id, pjsip_event.getCPtr(e), e); else pjsuaJNI.Callback_on_call_stateSwigExplicitCallback(swigCPtr, this, call_id, pjsip_event.getCPtr(e), e);
+  }
+
+  public void on_incoming_call(int acc_id, int call_id, SWIGTYPE_p_pjsip_rx_data rdata) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_incoming_call(swigCPtr, this, acc_id, call_id, SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata)); else pjsuaJNI.Callback_on_incoming_callSwigExplicitCallback(swigCPtr, this, acc_id, call_id, SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata));
+  }
+
+  public void on_call_tsx_state(int call_id, SWIGTYPE_p_pjsip_transaction tsx, pjsip_event e) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_tsx_state(swigCPtr, this, call_id, SWIGTYPE_p_pjsip_transaction.getCPtr(tsx), pjsip_event.getCPtr(e), e); else pjsuaJNI.Callback_on_call_tsx_stateSwigExplicitCallback(swigCPtr, this, call_id, SWIGTYPE_p_pjsip_transaction.getCPtr(tsx), pjsip_event.getCPtr(e), e);
+  }
+
+  public void on_call_media_state(int call_id) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_media_state(swigCPtr, this, call_id); else pjsuaJNI.Callback_on_call_media_stateSwigExplicitCallback(swigCPtr, this, call_id);
+  }
+
+  public void on_call_sdp_created(int call_id, SWIGTYPE_p_pjmedia_sdp_session sdp, pj_pool_t pool, SWIGTYPE_p_pjmedia_sdp_session rem_sdp) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_sdp_created(swigCPtr, this, call_id, SWIGTYPE_p_pjmedia_sdp_session.getCPtr(sdp), pj_pool_t.getCPtr(pool), pool, SWIGTYPE_p_pjmedia_sdp_session.getCPtr(rem_sdp)); else pjsuaJNI.Callback_on_call_sdp_createdSwigExplicitCallback(swigCPtr, this, call_id, SWIGTYPE_p_pjmedia_sdp_session.getCPtr(sdp), pj_pool_t.getCPtr(pool), pool, SWIGTYPE_p_pjmedia_sdp_session.getCPtr(rem_sdp));
+  }
+
+  public void on_stream_created(int call_id, SWIGTYPE_p_pjmedia_stream strm, long stream_idx, SWIGTYPE_p_p_pjmedia_port p_port) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_stream_created(swigCPtr, this, call_id, SWIGTYPE_p_pjmedia_stream.getCPtr(strm), stream_idx, SWIGTYPE_p_p_pjmedia_port.getCPtr(p_port)); else pjsuaJNI.Callback_on_stream_createdSwigExplicitCallback(swigCPtr, this, call_id, SWIGTYPE_p_pjmedia_stream.getCPtr(strm), stream_idx, SWIGTYPE_p_p_pjmedia_port.getCPtr(p_port));
+  }
+
+  public void on_stream_destroyed(int call_id, SWIGTYPE_p_pjmedia_stream strm, long stream_idx) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_stream_destroyed(swigCPtr, this, call_id, SWIGTYPE_p_pjmedia_stream.getCPtr(strm), stream_idx); else pjsuaJNI.Callback_on_stream_destroyedSwigExplicitCallback(swigCPtr, this, call_id, SWIGTYPE_p_pjmedia_stream.getCPtr(strm), stream_idx);
+  }
+
+  public void on_dtmf_digit(int call_id, int digit) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_dtmf_digit(swigCPtr, this, call_id, digit); else pjsuaJNI.Callback_on_dtmf_digitSwigExplicitCallback(swigCPtr, this, call_id, digit);
+  }
+
+  public void on_call_transfer_request(int call_id, pj_str_t dst, SWIGTYPE_p_pjsip_status_code code) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_transfer_request(swigCPtr, this, call_id, pj_str_t.getCPtr(dst), dst, SWIGTYPE_p_pjsip_status_code.getCPtr(code)); else pjsuaJNI.Callback_on_call_transfer_requestSwigExplicitCallback(swigCPtr, this, call_id, pj_str_t.getCPtr(dst), dst, SWIGTYPE_p_pjsip_status_code.getCPtr(code));
+  }
+
+  public void on_call_transfer_status(int call_id, int st_code, pj_str_t st_text, int final_, SWIGTYPE_p_int p_cont) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_transfer_status(swigCPtr, this, call_id, st_code, pj_str_t.getCPtr(st_text), st_text, final_, SWIGTYPE_p_int.getCPtr(p_cont)); else pjsuaJNI.Callback_on_call_transfer_statusSwigExplicitCallback(swigCPtr, this, call_id, st_code, pj_str_t.getCPtr(st_text), st_text, final_, SWIGTYPE_p_int.getCPtr(p_cont));
+  }
+
+  public void on_call_replace_request(int call_id, SWIGTYPE_p_pjsip_rx_data rdata, SWIGTYPE_p_int st_code, pj_str_t st_text) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_replace_request(swigCPtr, this, call_id, SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata), SWIGTYPE_p_int.getCPtr(st_code), pj_str_t.getCPtr(st_text), st_text); else pjsuaJNI.Callback_on_call_replace_requestSwigExplicitCallback(swigCPtr, this, call_id, SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata), SWIGTYPE_p_int.getCPtr(st_code), pj_str_t.getCPtr(st_text), st_text);
+  }
+
+  public void on_call_replaced(int old_call_id, int new_call_id) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_replaced(swigCPtr, this, old_call_id, new_call_id); else pjsuaJNI.Callback_on_call_replacedSwigExplicitCallback(swigCPtr, this, old_call_id, new_call_id);
+  }
+
+  public void on_reg_state(int acc_id) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_reg_state(swigCPtr, this, acc_id); else pjsuaJNI.Callback_on_reg_stateSwigExplicitCallback(swigCPtr, this, acc_id);
+  }
+
+  public void on_buddy_state(int buddy_id) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_buddy_state(swigCPtr, this, buddy_id); else pjsuaJNI.Callback_on_buddy_stateSwigExplicitCallback(swigCPtr, this, buddy_id);
+  }
+
+  public void on_pager(int call_id, pj_str_t from, pj_str_t to, pj_str_t contact, pj_str_t mime_type, pj_str_t body) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_pager(swigCPtr, this, call_id, pj_str_t.getCPtr(from), from, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(contact), contact, pj_str_t.getCPtr(mime_type), mime_type, pj_str_t.getCPtr(body), body); else pjsuaJNI.Callback_on_pagerSwigExplicitCallback(swigCPtr, this, call_id, pj_str_t.getCPtr(from), from, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(contact), contact, pj_str_t.getCPtr(mime_type), mime_type, pj_str_t.getCPtr(body), body);
+  }
+
+  public void on_pager2(int call_id, pj_str_t from, pj_str_t to, pj_str_t contact, pj_str_t mime_type, pj_str_t body, SWIGTYPE_p_pjsip_rx_data rdata) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_pager2(swigCPtr, this, call_id, pj_str_t.getCPtr(from), from, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(contact), contact, pj_str_t.getCPtr(mime_type), mime_type, pj_str_t.getCPtr(body), body, SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata)); else pjsuaJNI.Callback_on_pager2SwigExplicitCallback(swigCPtr, this, call_id, pj_str_t.getCPtr(from), from, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(contact), contact, pj_str_t.getCPtr(mime_type), mime_type, pj_str_t.getCPtr(body), body, SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata));
+  }
+
+  public void on_pager_status(int call_id, pj_str_t to, pj_str_t body, pjsip_status_code status, pj_str_t reason) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_pager_status(swigCPtr, this, call_id, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(body), body, status.swigValue(), pj_str_t.getCPtr(reason), reason); else pjsuaJNI.Callback_on_pager_statusSwigExplicitCallback(swigCPtr, this, call_id, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(body), body, status.swigValue(), pj_str_t.getCPtr(reason), reason);
+  }
+
+  public void on_pager_status2(int call_id, pj_str_t to, pj_str_t body, pjsip_status_code status, pj_str_t reason, SWIGTYPE_p_pjsip_tx_data tdata, SWIGTYPE_p_pjsip_rx_data rdata) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_pager_status2(swigCPtr, this, call_id, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(body), body, status.swigValue(), pj_str_t.getCPtr(reason), reason, SWIGTYPE_p_pjsip_tx_data.getCPtr(tdata), SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata)); else pjsuaJNI.Callback_on_pager_status2SwigExplicitCallback(swigCPtr, this, call_id, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(body), body, status.swigValue(), pj_str_t.getCPtr(reason), reason, SWIGTYPE_p_pjsip_tx_data.getCPtr(tdata), SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata));
+  }
+
+  public void on_typing(int call_id, pj_str_t from, pj_str_t to, pj_str_t contact, int is_typing) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_typing(swigCPtr, this, call_id, pj_str_t.getCPtr(from), from, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(contact), contact, is_typing); else pjsuaJNI.Callback_on_typingSwigExplicitCallback(swigCPtr, this, call_id, pj_str_t.getCPtr(from), from, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(contact), contact, is_typing);
+  }
+
+  public void on_nat_detect(pj_stun_nat_detect_result res) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_nat_detect(swigCPtr, this, pj_stun_nat_detect_result.getCPtr(res), res); else pjsuaJNI.Callback_on_nat_detectSwigExplicitCallback(swigCPtr, this, pj_stun_nat_detect_result.getCPtr(res), res);
+  }
+
+  public pjsip_redirect_op on_call_redirected(int call_id, pj_str_t target) {
+    return pjsip_redirect_op.swigToEnum((getClass() == Callback.class) ? pjsuaJNI.Callback_on_call_redirected(swigCPtr, this, call_id, pj_str_t.getCPtr(target), target) : pjsuaJNI.Callback_on_call_redirectedSwigExplicitCallback(swigCPtr, this, call_id, pj_str_t.getCPtr(target), target));
+  }
+
+  public void on_mwi_info(int acc_id, pj_str_t mime_type, pj_str_t body) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_mwi_info(swigCPtr, this, acc_id, pj_str_t.getCPtr(mime_type), mime_type, pj_str_t.getCPtr(body), body); else pjsuaJNI.Callback_on_mwi_infoSwigExplicitCallback(swigCPtr, this, acc_id, pj_str_t.getCPtr(mime_type), mime_type, pj_str_t.getCPtr(body), body);
+  }
+
+  public void on_call_media_transport_state(int call_id, pjsua_med_tp_state_info info) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_call_media_transport_state(swigCPtr, this, call_id, pjsua_med_tp_state_info.getCPtr(info), info); else pjsuaJNI.Callback_on_call_media_transport_stateSwigExplicitCallback(swigCPtr, this, call_id, pjsua_med_tp_state_info.getCPtr(info), info);
+  }
+
+  public int on_validate_audio_clock_rate(int clock_rate) {
+    return (getClass() == Callback.class) ? pjsuaJNI.Callback_on_validate_audio_clock_rate(swigCPtr, this, clock_rate) : pjsuaJNI.Callback_on_validate_audio_clock_rateSwigExplicitCallback(swigCPtr, this, clock_rate);
+  }
+
+  public void on_setup_audio(int before_init) {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_setup_audio(swigCPtr, this, before_init); else pjsuaJNI.Callback_on_setup_audioSwigExplicitCallback(swigCPtr, this, before_init);
+  }
+
+  public void on_teardown_audio() {
+    if (getClass() == Callback.class) pjsuaJNI.Callback_on_teardown_audio(swigCPtr, this); else pjsuaJNI.Callback_on_teardown_audioSwigExplicitCallback(swigCPtr, this);
+  }
+
+  public int on_set_micro_source() {
+    return (getClass() == Callback.class) ? pjsuaJNI.Callback_on_set_micro_source(swigCPtr, this) : pjsuaJNI.Callback_on_set_micro_sourceSwigExplicitCallback(swigCPtr, this);
+  }
+
+  public int timer_schedule(int entry, int entryId, int time) {
+    return (getClass() == Callback.class) ? pjsuaJNI.Callback_timer_schedule(swigCPtr, this, entry, entryId, time) : pjsuaJNI.Callback_timer_scheduleSwigExplicitCallback(swigCPtr, this, entry, entryId, time);
+  }
+
+  public int timer_cancel(int entry, int entryId) {
+    return (getClass() == Callback.class) ? pjsuaJNI.Callback_timer_cancel(swigCPtr, this, entry, entryId) : pjsuaJNI.Callback_timer_cancelSwigExplicitCallback(swigCPtr, this, entry, entryId);
+  }
+
+  public Callback() {
+    this(pjsuaJNI.new_Callback(), true);
+    pjsuaJNI.Callback_director_connect(this, swigCPtr, swigCMemOwn, false);
+  }
+
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/csipsimple_acc_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/csipsimple_acc_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/csipsimple_acc_config.java	(working copy)
@@ -0,0 +1,59 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class csipsimple_acc_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected csipsimple_acc_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(csipsimple_acc_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_csipsimple_acc_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setUse_zrtp(int value) {
+    pjsuaJNI.csipsimple_acc_config_use_zrtp_set(swigCPtr, this, value);
+  }
+
+  public int getUse_zrtp() {
+    return pjsuaJNI.csipsimple_acc_config_use_zrtp_get(swigCPtr, this);
+  }
+
+  public void setP_preferred_identity(pj_str_t value) {
+    pjsuaJNI.csipsimple_acc_config_p_preferred_identity_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getP_preferred_identity() {
+    long cPtr = pjsuaJNI.csipsimple_acc_config_p_preferred_identity_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public csipsimple_acc_config() {
+    this(pjsuaJNI.new_csipsimple_acc_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/csipsimple_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/csipsimple_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/csipsimple_config.java	(working copy)
@@ -0,0 +1,239 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class csipsimple_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected csipsimple_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(csipsimple_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_csipsimple_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setUse_compact_form_sdp(int value) {
+    pjsuaJNI.csipsimple_config_use_compact_form_sdp_set(swigCPtr, this, value);
+  }
+
+  public int getUse_compact_form_sdp() {
+    return pjsuaJNI.csipsimple_config_use_compact_form_sdp_get(swigCPtr, this);
+  }
+
+  public void setUse_compact_form_headers(int value) {
+    pjsuaJNI.csipsimple_config_use_compact_form_headers_set(swigCPtr, this, value);
+  }
+
+  public int getUse_compact_form_headers() {
+    return pjsuaJNI.csipsimple_config_use_compact_form_headers_get(swigCPtr, this);
+  }
+
+  public void setAdd_bandwidth_tias_in_sdp(int value) {
+    pjsuaJNI.csipsimple_config_add_bandwidth_tias_in_sdp_set(swigCPtr, this, value);
+  }
+
+  public int getAdd_bandwidth_tias_in_sdp() {
+    return pjsuaJNI.csipsimple_config_add_bandwidth_tias_in_sdp_get(swigCPtr, this);
+  }
+
+  public void setUse_no_update(int value) {
+    pjsuaJNI.csipsimple_config_use_no_update_set(swigCPtr, this, value);
+  }
+
+  public int getUse_no_update() {
+    return pjsuaJNI.csipsimple_config_use_no_update_get(swigCPtr, this);
+  }
+
+  public void setUse_zrtp(int value) {
+    pjsuaJNI.csipsimple_config_use_zrtp_set(swigCPtr, this, value);
+  }
+
+  public int getUse_zrtp() {
+    return pjsuaJNI.csipsimple_config_use_zrtp_get(swigCPtr, this);
+  }
+
+  public void setExtra_aud_codecs_cnt(long value) {
+    pjsuaJNI.csipsimple_config_extra_aud_codecs_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getExtra_aud_codecs_cnt() {
+    return pjsuaJNI.csipsimple_config_extra_aud_codecs_cnt_get(swigCPtr, this);
+  }
+
+  public void setExtra_aud_codecs(dynamic_factory[] value) {
+    pjsuaJNI.csipsimple_config_extra_aud_codecs_set(swigCPtr, this, dynamic_factory.cArrayUnwrap(value));
+  }
+
+  public dynamic_factory[] getExtra_aud_codecs() {
+    return dynamic_factory.cArrayWrap(pjsuaJNI.csipsimple_config_extra_aud_codecs_get(swigCPtr, this), false);
+  }
+
+  public void setExtra_vid_codecs_cnt(long value) {
+    pjsuaJNI.csipsimple_config_extra_vid_codecs_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getExtra_vid_codecs_cnt() {
+    return pjsuaJNI.csipsimple_config_extra_vid_codecs_cnt_get(swigCPtr, this);
+  }
+
+  public void setExtra_vid_codecs(dynamic_factory[] value) {
+    pjsuaJNI.csipsimple_config_extra_vid_codecs_set(swigCPtr, this, dynamic_factory.cArrayUnwrap(value));
+  }
+
+  public dynamic_factory[] getExtra_vid_codecs() {
+    return dynamic_factory.cArrayWrap(pjsuaJNI.csipsimple_config_extra_vid_codecs_get(swigCPtr, this), false);
+  }
+
+  public void setExtra_vid_codecs_destroy(dynamic_factory[] value) {
+    pjsuaJNI.csipsimple_config_extra_vid_codecs_destroy_set(swigCPtr, this, dynamic_factory.cArrayUnwrap(value));
+  }
+
+  public dynamic_factory[] getExtra_vid_codecs_destroy() {
+    return dynamic_factory.cArrayWrap(pjsuaJNI.csipsimple_config_extra_vid_codecs_destroy_get(swigCPtr, this), false);
+  }
+
+  public void setVid_converter(dynamic_factory value) {
+    pjsuaJNI.csipsimple_config_vid_converter_set(swigCPtr, this, dynamic_factory.getCPtr(value), value);
+  }
+
+  public dynamic_factory getVid_converter() {
+    long cPtr = pjsuaJNI.csipsimple_config_vid_converter_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new dynamic_factory(cPtr, false);
+  }
+
+  public void setStorage_folder(pj_str_t value) {
+    pjsuaJNI.csipsimple_config_storage_folder_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getStorage_folder() {
+    long cPtr = pjsuaJNI.csipsimple_config_storage_folder_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setAudio_implementation(dynamic_factory value) {
+    pjsuaJNI.csipsimple_config_audio_implementation_set(swigCPtr, this, dynamic_factory.getCPtr(value), value);
+  }
+
+  public dynamic_factory getAudio_implementation() {
+    long cPtr = pjsuaJNI.csipsimple_config_audio_implementation_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new dynamic_factory(cPtr, false);
+  }
+
+  public void setVideo_render_implementation(dynamic_factory value) {
+    pjsuaJNI.csipsimple_config_video_render_implementation_set(swigCPtr, this, dynamic_factory.getCPtr(value), value);
+  }
+
+  public dynamic_factory getVideo_render_implementation() {
+    long cPtr = pjsuaJNI.csipsimple_config_video_render_implementation_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new dynamic_factory(cPtr, false);
+  }
+
+  public void setVideo_capture_implementation(dynamic_factory value) {
+    pjsuaJNI.csipsimple_config_video_capture_implementation_set(swigCPtr, this, dynamic_factory.getCPtr(value), value);
+  }
+
+  public dynamic_factory getVideo_capture_implementation() {
+    long cPtr = pjsuaJNI.csipsimple_config_video_capture_implementation_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new dynamic_factory(cPtr, false);
+  }
+
+  public void setTcp_keep_alive_interval(int value) {
+    pjsuaJNI.csipsimple_config_tcp_keep_alive_interval_set(swigCPtr, this, value);
+  }
+
+  public int getTcp_keep_alive_interval() {
+    return pjsuaJNI.csipsimple_config_tcp_keep_alive_interval_get(swigCPtr, this);
+  }
+
+  public void setTls_keep_alive_interval(int value) {
+    pjsuaJNI.csipsimple_config_tls_keep_alive_interval_set(swigCPtr, this, value);
+  }
+
+  public int getTls_keep_alive_interval() {
+    return pjsuaJNI.csipsimple_config_tls_keep_alive_interval_get(swigCPtr, this);
+  }
+
+  public void setTsx_t1_timeout(int value) {
+    pjsuaJNI.csipsimple_config_tsx_t1_timeout_set(swigCPtr, this, value);
+  }
+
+  public int getTsx_t1_timeout() {
+    return pjsuaJNI.csipsimple_config_tsx_t1_timeout_get(swigCPtr, this);
+  }
+
+  public void setTsx_t2_timeout(int value) {
+    pjsuaJNI.csipsimple_config_tsx_t2_timeout_set(swigCPtr, this, value);
+  }
+
+  public int getTsx_t2_timeout() {
+    return pjsuaJNI.csipsimple_config_tsx_t2_timeout_get(swigCPtr, this);
+  }
+
+  public void setTsx_t4_timeout(int value) {
+    pjsuaJNI.csipsimple_config_tsx_t4_timeout_set(swigCPtr, this, value);
+  }
+
+  public int getTsx_t4_timeout() {
+    return pjsuaJNI.csipsimple_config_tsx_t4_timeout_get(swigCPtr, this);
+  }
+
+  public void setTsx_td_timeout(int value) {
+    pjsuaJNI.csipsimple_config_tsx_td_timeout_set(swigCPtr, this, value);
+  }
+
+  public int getTsx_td_timeout() {
+    return pjsuaJNI.csipsimple_config_tsx_td_timeout_get(swigCPtr, this);
+  }
+
+  public void setDisable_tcp_switch(int value) {
+    pjsuaJNI.csipsimple_config_disable_tcp_switch_set(swigCPtr, this, value);
+  }
+
+  public int getDisable_tcp_switch() {
+    return pjsuaJNI.csipsimple_config_disable_tcp_switch_get(swigCPtr, this);
+  }
+
+  public void setDisable_rport(int value) {
+    pjsuaJNI.csipsimple_config_disable_rport_set(swigCPtr, this, value);
+  }
+
+  public int getDisable_rport() {
+    return pjsuaJNI.csipsimple_config_disable_rport_get(swigCPtr, this);
+  }
+
+  public void setUse_noise_suppressor(int value) {
+    pjsuaJNI.csipsimple_config_use_noise_suppressor_set(swigCPtr, this, value);
+  }
+
+  public int getUse_noise_suppressor() {
+    return pjsuaJNI.csipsimple_config_use_noise_suppressor_get(swigCPtr, this);
+  }
+
+  public csipsimple_config() {
+    this(pjsuaJNI.new_csipsimple_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/dynamic_factory.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/dynamic_factory.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/dynamic_factory.java	(working copy)
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class dynamic_factory {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected dynamic_factory(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(dynamic_factory obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_dynamic_factory(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  protected static long[] cArrayUnwrap(dynamic_factory[] arrayWrapper) {
+      long[] cArray = new long[arrayWrapper.length];
+      for (int i=0; i<arrayWrapper.length; i++)
+        cArray[i] = dynamic_factory.getCPtr(arrayWrapper[i]);
+      return cArray;
+  }
+
+  protected static dynamic_factory[] cArrayWrap(long[] cArray, boolean cMemoryOwn) {
+    dynamic_factory[] arrayWrapper = new dynamic_factory[cArray.length];
+    for (int i=0; i<cArray.length; i++)
+      arrayWrapper[i] = new dynamic_factory(cArray[i], cMemoryOwn);
+    return arrayWrapper;
+  }
+
+  public void setShared_lib_path(pj_str_t value) {
+    pjsuaJNI.dynamic_factory_shared_lib_path_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getShared_lib_path() {
+    long cPtr = pjsuaJNI.dynamic_factory_shared_lib_path_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setInit_factory_name(pj_str_t value) {
+    pjsuaJNI.dynamic_factory_init_factory_name_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getInit_factory_name() {
+    long cPtr = pjsuaJNI.dynamic_factory_init_factory_name_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public dynamic_factory() {
+    this(pjsuaJNI.new_dynamic_factory(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/EarlyLockCallback.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/EarlyLockCallback.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/EarlyLockCallback.java	(working copy)
@@ -0,0 +1,63 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class EarlyLockCallback {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected EarlyLockCallback(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(EarlyLockCallback obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_EarlyLockCallback(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  protected void swigDirectorDisconnect() {
+    swigCMemOwn = false;
+    delete();
+  }
+
+  public void swigReleaseOwnership() {
+    swigCMemOwn = false;
+    pjsuaJNI.EarlyLockCallback_change_ownership(this, swigCPtr, false);
+  }
+
+  public void swigTakeOwnership() {
+    swigCMemOwn = true;
+    pjsuaJNI.EarlyLockCallback_change_ownership(this, swigCPtr, true);
+  }
+
+  public void on_create_early_lock() {
+    if (getClass() == EarlyLockCallback.class) pjsuaJNI.EarlyLockCallback_on_create_early_lock(swigCPtr, this); else pjsuaJNI.EarlyLockCallback_on_create_early_lockSwigExplicitEarlyLockCallback(swigCPtr, this);
+  }
+
+  public EarlyLockCallback() {
+    this(pjsuaJNI.new_EarlyLockCallback(), true);
+    pjsuaJNI.EarlyLockCallback_director_connect(this, swigCPtr, swigCMemOwn, false);
+  }
+
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/MobileRegHandlerCallback.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/MobileRegHandlerCallback.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/MobileRegHandlerCallback.java	(working copy)
@@ -0,0 +1,67 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class MobileRegHandlerCallback {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected MobileRegHandlerCallback(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(MobileRegHandlerCallback obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_MobileRegHandlerCallback(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  protected void swigDirectorDisconnect() {
+    swigCMemOwn = false;
+    delete();
+  }
+
+  public void swigReleaseOwnership() {
+    swigCMemOwn = false;
+    pjsuaJNI.MobileRegHandlerCallback_change_ownership(this, swigCPtr, false);
+  }
+
+  public void swigTakeOwnership() {
+    swigCMemOwn = true;
+    pjsuaJNI.MobileRegHandlerCallback_change_ownership(this, swigCPtr, true);
+  }
+
+  public void on_save_contact(int acc_id, pj_str_t contact, int expires) {
+    if (getClass() == MobileRegHandlerCallback.class) pjsuaJNI.MobileRegHandlerCallback_on_save_contact(swigCPtr, this, acc_id, pj_str_t.getCPtr(contact), contact, expires); else pjsuaJNI.MobileRegHandlerCallback_on_save_contactSwigExplicitMobileRegHandlerCallback(swigCPtr, this, acc_id, pj_str_t.getCPtr(contact), contact, expires);
+  }
+
+  public pj_str_t on_restore_contact(int acc_id) {
+    return new pj_str_t((getClass() == MobileRegHandlerCallback.class) ? pjsuaJNI.MobileRegHandlerCallback_on_restore_contact(swigCPtr, this, acc_id) : pjsuaJNI.MobileRegHandlerCallback_on_restore_contactSwigExplicitMobileRegHandlerCallback(swigCPtr, this, acc_id), true);
+  }
+
+  public MobileRegHandlerCallback() {
+    this(pjsuaJNI.new_MobileRegHandlerCallback(), true);
+    pjsuaJNI.MobileRegHandlerCallback_director_connect(this, swigCPtr, swigCMemOwn, false);
+  }
+
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pj_ice_sess_options.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_ice_sess_options.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_ice_sess_options.java	(working copy)
@@ -0,0 +1,66 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pj_ice_sess_options {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pj_ice_sess_options(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pj_ice_sess_options obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pj_ice_sess_options(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setAggressive(int value) {
+    pjsuaJNI.pj_ice_sess_options_aggressive_set(swigCPtr, this, value);
+  }
+
+  public int getAggressive() {
+    return pjsuaJNI.pj_ice_sess_options_aggressive_get(swigCPtr, this);
+  }
+
+  public void setNominated_check_delay(long value) {
+    pjsuaJNI.pj_ice_sess_options_nominated_check_delay_set(swigCPtr, this, value);
+  }
+
+  public long getNominated_check_delay() {
+    return pjsuaJNI.pj_ice_sess_options_nominated_check_delay_get(swigCPtr, this);
+  }
+
+  public void setControlled_agent_want_nom_timeout(int value) {
+    pjsuaJNI.pj_ice_sess_options_controlled_agent_want_nom_timeout_set(swigCPtr, this, value);
+  }
+
+  public int getControlled_agent_want_nom_timeout() {
+    return pjsuaJNI.pj_ice_sess_options_controlled_agent_want_nom_timeout_get(swigCPtr, this);
+  }
+
+  public pj_ice_sess_options() {
+    this(pjsuaJNI.new_pj_ice_sess_options(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pj_pool_t.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_pool_t.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_pool_t.java	(working copy)
@@ -0,0 +1,100 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pj_pool_t {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pj_pool_t(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pj_pool_t obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pj_pool_t(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setObj_name(String value) {
+    pjsuaJNI.pj_pool_t_obj_name_set(swigCPtr, this, value);
+  }
+
+  public String getObj_name() {
+    return pjsuaJNI.pj_pool_t_obj_name_get(swigCPtr, this);
+  }
+
+  public void setFactory(SWIGTYPE_p_pj_pool_factory value) {
+    pjsuaJNI.pj_pool_t_factory_set(swigCPtr, this, SWIGTYPE_p_pj_pool_factory.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_pool_factory getFactory() {
+    long cPtr = pjsuaJNI.pj_pool_t_factory_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pj_pool_factory(cPtr, false);
+  }
+
+  public void setFactory_data(byte[] value) {
+    pjsuaJNI.pj_pool_t_factory_data_set(swigCPtr, this, value);
+  }
+
+  public byte[] getFactory_data() {
+	return pjsuaJNI.pj_pool_t_factory_data_get(swigCPtr, this);
+}
+
+  public void setCapacity(long value) {
+    pjsuaJNI.pj_pool_t_capacity_set(swigCPtr, this, value);
+  }
+
+  public long getCapacity() {
+    return pjsuaJNI.pj_pool_t_capacity_get(swigCPtr, this);
+  }
+
+  public void setIncrement_size(long value) {
+    pjsuaJNI.pj_pool_t_increment_size_set(swigCPtr, this, value);
+  }
+
+  public long getIncrement_size() {
+    return pjsuaJNI.pj_pool_t_increment_size_get(swigCPtr, this);
+  }
+
+  public void setBlock_list(SWIGTYPE_p_pj_pool_block value) {
+    pjsuaJNI.pj_pool_t_block_list_set(swigCPtr, this, SWIGTYPE_p_pj_pool_block.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_pool_block getBlock_list() {
+    return new SWIGTYPE_p_pj_pool_block(pjsuaJNI.pj_pool_t_block_list_get(swigCPtr, this), true);
+  }
+
+  public void setCallback(SWIGTYPE_p_pj_pool_callback value) {
+    pjsuaJNI.pj_pool_t_callback_set(swigCPtr, this, SWIGTYPE_p_pj_pool_callback.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_pool_callback getCallback() {
+    long cPtr = pjsuaJNI.pj_pool_t_callback_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pj_pool_callback(cPtr, false);
+  }
+
+  public pj_pool_t() {
+    this(pjsuaJNI.new_pj_pool_t(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pj_qos_params.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_qos_params.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_qos_params.java	(working copy)
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pj_qos_params {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pj_qos_params(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pj_qos_params obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pj_qos_params(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setFlags(short value) {
+    pjsuaJNI.pj_qos_params_flags_set(swigCPtr, this, value);
+  }
+
+  public short getFlags() {
+    return pjsuaJNI.pj_qos_params_flags_get(swigCPtr, this);
+  }
+
+  public void setDscp_val(short value) {
+    pjsuaJNI.pj_qos_params_dscp_val_set(swigCPtr, this, value);
+  }
+
+  public short getDscp_val() {
+    return pjsuaJNI.pj_qos_params_dscp_val_get(swigCPtr, this);
+  }
+
+  public void setSo_prio(short value) {
+    pjsuaJNI.pj_qos_params_so_prio_set(swigCPtr, this, value);
+  }
+
+  public short getSo_prio() {
+    return pjsuaJNI.pj_qos_params_so_prio_get(swigCPtr, this);
+  }
+
+  public void setWmm_prio(SWIGTYPE_p_pj_qos_wmm_prio value) {
+    pjsuaJNI.pj_qos_params_wmm_prio_set(swigCPtr, this, SWIGTYPE_p_pj_qos_wmm_prio.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_qos_wmm_prio getWmm_prio() {
+    return new SWIGTYPE_p_pj_qos_wmm_prio(pjsuaJNI.pj_qos_params_wmm_prio_get(swigCPtr, this), true);
+  }
+
+  public pj_qos_params() {
+    this(pjsuaJNI.new_pj_qos_params(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pj_qos_type.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_qos_type.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_qos_type.java	(working copy)
@@ -0,0 +1,55 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pj_qos_type {
+  PJ_QOS_TYPE_BEST_EFFORT,
+  PJ_QOS_TYPE_BACKGROUND,
+  PJ_QOS_TYPE_VIDEO,
+  PJ_QOS_TYPE_VOICE,
+  PJ_QOS_TYPE_CONTROL;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pj_qos_type swigToEnum(int swigValue) {
+    pj_qos_type[] swigValues = pj_qos_type.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pj_qos_type swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pj_qos_type.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pj_qos_type() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pj_qos_type(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pj_qos_type(pj_qos_type swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pj_str_t.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_str_t.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_str_t.java	(working copy)
@@ -0,0 +1,72 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pj_str_t {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pj_str_t(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pj_str_t obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pj_str_t(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  protected static long[] cArrayUnwrap(pj_str_t[] arrayWrapper) {
+      long[] cArray = new long[arrayWrapper.length];
+      for (int i=0; i<arrayWrapper.length; i++)
+        cArray[i] = pj_str_t.getCPtr(arrayWrapper[i]);
+      return cArray;
+  }
+
+  protected static pj_str_t[] cArrayWrap(long[] cArray, boolean cMemoryOwn) {
+    pj_str_t[] arrayWrapper = new pj_str_t[cArray.length];
+    for (int i=0; i<cArray.length; i++)
+      arrayWrapper[i] = new pj_str_t(cArray[i], cMemoryOwn);
+    return arrayWrapper;
+  }
+
+  public void setPtr(String value) {
+    pjsuaJNI.pj_str_t_ptr_set(swigCPtr, this, value);
+  }
+
+  public String getPtr() {
+    return pjsuaJNI.pj_str_t_ptr_get(swigCPtr, this);
+  }
+
+  public void setSlen(int value) {
+    pjsuaJNI.pj_str_t_slen_set(swigCPtr, this, value);
+  }
+
+  public int getSlen() {
+    return pjsuaJNI.pj_str_t_slen_get(swigCPtr, this);
+  }
+
+  public pj_str_t() {
+    this(pjsuaJNI.new_pj_str_t(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pj_stun_nat_detect_result.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_stun_nat_detect_result.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_stun_nat_detect_result.java	(working copy)
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pj_stun_nat_detect_result {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pj_stun_nat_detect_result(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pj_stun_nat_detect_result obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pj_stun_nat_detect_result(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setStatus(int value) {
+    pjsuaJNI.pj_stun_nat_detect_result_status_set(swigCPtr, this, value);
+  }
+
+  public int getStatus() {
+    return pjsuaJNI.pj_stun_nat_detect_result_status_get(swigCPtr, this);
+  }
+
+  public void setStatus_text(String value) {
+    pjsuaJNI.pj_stun_nat_detect_result_status_text_set(swigCPtr, this, value);
+  }
+
+  public String getStatus_text() {
+    return pjsuaJNI.pj_stun_nat_detect_result_status_text_get(swigCPtr, this);
+  }
+
+  public void setNat_type(pj_stun_nat_type value) {
+    pjsuaJNI.pj_stun_nat_detect_result_nat_type_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pj_stun_nat_type getNat_type() {
+    return pj_stun_nat_type.swigToEnum(pjsuaJNI.pj_stun_nat_detect_result_nat_type_get(swigCPtr, this));
+  }
+
+  public void setNat_type_name(String value) {
+    pjsuaJNI.pj_stun_nat_detect_result_nat_type_name_set(swigCPtr, this, value);
+  }
+
+  public String getNat_type_name() {
+    return pjsuaJNI.pj_stun_nat_detect_result_nat_type_name_get(swigCPtr, this);
+  }
+
+  public pj_stun_nat_detect_result() {
+    this(pjsuaJNI.new_pj_stun_nat_detect_result(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pj_stun_nat_type.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_stun_nat_type.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_stun_nat_type.java	(working copy)
@@ -0,0 +1,59 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pj_stun_nat_type {
+  PJ_STUN_NAT_TYPE_UNKNOWN,
+  PJ_STUN_NAT_TYPE_ERR_UNKNOWN,
+  PJ_STUN_NAT_TYPE_OPEN,
+  PJ_STUN_NAT_TYPE_BLOCKED,
+  PJ_STUN_NAT_TYPE_SYMMETRIC_UDP,
+  PJ_STUN_NAT_TYPE_FULL_CONE,
+  PJ_STUN_NAT_TYPE_SYMMETRIC,
+  PJ_STUN_NAT_TYPE_RESTRICTED,
+  PJ_STUN_NAT_TYPE_PORT_RESTRICTED;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pj_stun_nat_type swigToEnum(int swigValue) {
+    pj_stun_nat_type[] swigValues = pj_stun_nat_type.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pj_stun_nat_type swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pj_stun_nat_type.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pj_stun_nat_type() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pj_stun_nat_type(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pj_stun_nat_type(pj_stun_nat_type swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pj_stun_resolve_result.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_stun_resolve_result.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_stun_resolve_result.java	(working copy)
@@ -0,0 +1,75 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pj_stun_resolve_result {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pj_stun_resolve_result(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pj_stun_resolve_result obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pj_stun_resolve_result(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setToken(byte[] value) {
+    pjsuaJNI.pj_stun_resolve_result_token_set(swigCPtr, this, value);
+  }
+
+  public byte[] getToken() {
+	return pjsuaJNI.pj_stun_resolve_result_token_get(swigCPtr, this);
+}
+
+  public void setStatus(int value) {
+    pjsuaJNI.pj_stun_resolve_result_status_set(swigCPtr, this, value);
+  }
+
+  public int getStatus() {
+    return pjsuaJNI.pj_stun_resolve_result_status_get(swigCPtr, this);
+  }
+
+  public void setName(pj_str_t value) {
+    pjsuaJNI.pj_stun_resolve_result_name_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getName() {
+    long cPtr = pjsuaJNI.pj_stun_resolve_result_name_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setAddr(SWIGTYPE_p_pj_sockaddr value) {
+    pjsuaJNI.pj_stun_resolve_result_addr_set(swigCPtr, this, SWIGTYPE_p_pj_sockaddr.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_sockaddr getAddr() {
+    return new SWIGTYPE_p_pj_sockaddr(pjsuaJNI.pj_stun_resolve_result_addr_get(swigCPtr, this), true);
+  }
+
+  public pj_stun_resolve_result() {
+    this(pjsuaJNI.new_pj_stun_resolve_result(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pj_time_val.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_time_val.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_time_val.java	(working copy)
@@ -0,0 +1,58 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pj_time_val {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pj_time_val(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pj_time_val obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pj_time_val(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setSec(int value) {
+    pjsuaJNI.pj_time_val_sec_set(swigCPtr, this, value);
+  }
+
+  public int getSec() {
+    return pjsuaJNI.pj_time_val_sec_get(swigCPtr, this);
+  }
+
+  public void setMsec(int value) {
+    pjsuaJNI.pj_time_val_msec_set(swigCPtr, this, value);
+  }
+
+  public int getMsec() {
+    return pjsuaJNI.pj_time_val_msec_get(swigCPtr, this);
+  }
+
+  public pj_time_val() {
+    this(pjsuaJNI.new_pj_time_val(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pj_turn_tp_type.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pj_turn_tp_type.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pj_turn_tp_type.java	(working copy)
@@ -0,0 +1,53 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pj_turn_tp_type {
+  PJ_TURN_TP_UDP(pjsuaJNI.PJ_TURN_TP_UDP_get()),
+  PJ_TURN_TP_TCP(pjsuaJNI.PJ_TURN_TP_TCP_get()),
+  PJ_TURN_TP_TLS(pjsuaJNI.PJ_TURN_TP_TLS_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pj_turn_tp_type swigToEnum(int swigValue) {
+    pj_turn_tp_type[] swigValues = pj_turn_tp_type.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pj_turn_tp_type swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pj_turn_tp_type.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pj_turn_tp_type() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pj_turn_tp_type(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pj_turn_tp_type(pj_turn_tp_type swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjmedia_dir.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjmedia_dir.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjmedia_dir.java	(working copy)
@@ -0,0 +1,59 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjmedia_dir {
+  PJMEDIA_DIR_NONE(pjsuaJNI.PJMEDIA_DIR_NONE_get()),
+  PJMEDIA_DIR_ENCODING(pjsuaJNI.PJMEDIA_DIR_ENCODING_get()),
+  PJMEDIA_DIR_CAPTURE(pjsuaJNI.PJMEDIA_DIR_CAPTURE_get()),
+  PJMEDIA_DIR_DECODING(pjsuaJNI.PJMEDIA_DIR_DECODING_get()),
+  PJMEDIA_DIR_PLAYBACK(pjsuaJNI.PJMEDIA_DIR_PLAYBACK_get()),
+  PJMEDIA_DIR_RENDER(pjsuaJNI.PJMEDIA_DIR_RENDER_get()),
+  PJMEDIA_DIR_ENCODING_DECODING(pjsuaJNI.PJMEDIA_DIR_ENCODING_DECODING_get()),
+  PJMEDIA_DIR_CAPTURE_PLAYBACK(pjsuaJNI.PJMEDIA_DIR_CAPTURE_PLAYBACK_get()),
+  PJMEDIA_DIR_CAPTURE_RENDER(pjsuaJNI.PJMEDIA_DIR_CAPTURE_RENDER_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjmedia_dir swigToEnum(int swigValue) {
+    pjmedia_dir[] swigValues = pjmedia_dir.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjmedia_dir swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjmedia_dir.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjmedia_dir() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjmedia_dir(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjmedia_dir(pjmedia_dir swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjmedia_port.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjmedia_port.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjmedia_port.java	(working copy)
@@ -0,0 +1,84 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjmedia_port {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjmedia_port(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjmedia_port obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        throw new UnsupportedOperationException("C++ destructor does not have public access");
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  /** This constructor creates the proxy which initially does not create nor own any C memory */
+  public pjmedia_port() {
+    this(0, false);
+  }
+
+  public void setInfo(pjmedia_port_info value) {
+    pjsuaJNI.pjmedia_port_info_set(swigCPtr, this, pjmedia_port_info.getCPtr(value), value);
+  }
+
+  public pjmedia_port_info getInfo() {
+    long cPtr = pjsuaJNI.pjmedia_port_info_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjmedia_port_info(cPtr, false);
+  }
+
+  public void setGet_clock_src(SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src value) {
+    pjsuaJNI.pjmedia_port_get_clock_src_set(swigCPtr, this, SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src getGet_clock_src() {
+    long cPtr = pjsuaJNI.pjmedia_port_get_clock_src_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src(cPtr, false);
+  }
+
+  public void setPut_frame(SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int value) {
+    pjsuaJNI.pjmedia_port_put_frame_set(swigCPtr, this, SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int getPut_frame() {
+    long cPtr = pjsuaJNI.pjmedia_port_put_frame_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int(cPtr, false);
+  }
+
+  public void setGet_frame(SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int value) {
+    pjsuaJNI.pjmedia_port_get_frame_set(swigCPtr, this, SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int getGet_frame() {
+    long cPtr = pjsuaJNI.pjmedia_port_get_frame_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int(cPtr, false);
+  }
+
+  public void setOn_destroy(SWIGTYPE_p_f_p_pjmedia_port__int value) {
+    pjsuaJNI.pjmedia_port_on_destroy_set(swigCPtr, this, SWIGTYPE_p_f_p_pjmedia_port__int.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_p_pjmedia_port__int getOn_destroy() {
+    long cPtr = pjsuaJNI.pjmedia_port_on_destroy_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_p_pjmedia_port__int(cPtr, false);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjmedia_port_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjmedia_port_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjmedia_port_info.java	(working copy)
@@ -0,0 +1,75 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjmedia_port_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjmedia_port_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjmedia_port_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjmedia_port_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setName(pj_str_t value) {
+    pjsuaJNI.pjmedia_port_info_name_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getName() {
+    long cPtr = pjsuaJNI.pjmedia_port_info_name_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setSignature(long value) {
+    pjsuaJNI.pjmedia_port_info_signature_set(swigCPtr, this, value);
+  }
+
+  public long getSignature() {
+    return pjsuaJNI.pjmedia_port_info_signature_get(swigCPtr, this);
+  }
+
+  public void setDir(pjmedia_dir value) {
+    pjsuaJNI.pjmedia_port_info_dir_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjmedia_dir getDir() {
+    return pjmedia_dir.swigToEnum(pjsuaJNI.pjmedia_port_info_dir_get(swigCPtr, this));
+  }
+
+  public void setFmt(SWIGTYPE_p_pjmedia_format value) {
+    pjsuaJNI.pjmedia_port_info_fmt_set(swigCPtr, this, SWIGTYPE_p_pjmedia_format.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_format getFmt() {
+    return new SWIGTYPE_p_pjmedia_format(pjsuaJNI.pjmedia_port_info_fmt_get(swigCPtr, this), true);
+  }
+
+  public pjmedia_port_info() {
+    this(pjsuaJNI.new_pjmedia_port_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjmedia_snd_dev_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjmedia_snd_dev_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjmedia_snd_dev_info.java	(working copy)
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjmedia_snd_dev_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjmedia_snd_dev_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjmedia_snd_dev_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjmedia_snd_dev_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setName(String value) {
+    pjsuaJNI.pjmedia_snd_dev_info_name_set(swigCPtr, this, value);
+  }
+
+  public String getName() {
+    return pjsuaJNI.pjmedia_snd_dev_info_name_get(swigCPtr, this);
+  }
+
+  public void setInput_count(long value) {
+    pjsuaJNI.pjmedia_snd_dev_info_input_count_set(swigCPtr, this, value);
+  }
+
+  public long getInput_count() {
+    return pjsuaJNI.pjmedia_snd_dev_info_input_count_get(swigCPtr, this);
+  }
+
+  public void setOutput_count(long value) {
+    pjsuaJNI.pjmedia_snd_dev_info_output_count_set(swigCPtr, this, value);
+  }
+
+  public long getOutput_count() {
+    return pjsuaJNI.pjmedia_snd_dev_info_output_count_get(swigCPtr, this);
+  }
+
+  public void setDefault_samples_per_sec(long value) {
+    pjsuaJNI.pjmedia_snd_dev_info_default_samples_per_sec_set(swigCPtr, this, value);
+  }
+
+  public long getDefault_samples_per_sec() {
+    return pjsuaJNI.pjmedia_snd_dev_info_default_samples_per_sec_get(swigCPtr, this);
+  }
+
+  public pjmedia_snd_dev_info() {
+    this(pjsuaJNI.new_pjmedia_snd_dev_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjmedia_srtp_use.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjmedia_srtp_use.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjmedia_srtp_use.java	(working copy)
@@ -0,0 +1,53 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjmedia_srtp_use {
+  PJMEDIA_SRTP_DISABLED,
+  PJMEDIA_SRTP_OPTIONAL,
+  PJMEDIA_SRTP_MANDATORY;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjmedia_srtp_use swigToEnum(int swigValue) {
+    pjmedia_srtp_use[] swigValues = pjmedia_srtp_use.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjmedia_srtp_use swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjmedia_srtp_use.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjmedia_srtp_use() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjmedia_srtp_use(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjmedia_srtp_use(pjmedia_srtp_use swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjmedia_tone_desc.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjmedia_tone_desc.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjmedia_tone_desc.java	(working copy)
@@ -0,0 +1,104 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjmedia_tone_desc {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjmedia_tone_desc(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjmedia_tone_desc obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjmedia_tone_desc(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  protected static long[] cArrayUnwrap(pjmedia_tone_desc[] arrayWrapper) {
+      long[] cArray = new long[arrayWrapper.length];
+      for (int i=0; i<arrayWrapper.length; i++)
+        cArray[i] = pjmedia_tone_desc.getCPtr(arrayWrapper[i]);
+      return cArray;
+  }
+
+  protected static pjmedia_tone_desc[] cArrayWrap(long[] cArray, boolean cMemoryOwn) {
+    pjmedia_tone_desc[] arrayWrapper = new pjmedia_tone_desc[cArray.length];
+    for (int i=0; i<cArray.length; i++)
+      arrayWrapper[i] = new pjmedia_tone_desc(cArray[i], cMemoryOwn);
+    return arrayWrapper;
+  }
+
+  public void setFreq1(short value) {
+    pjsuaJNI.pjmedia_tone_desc_freq1_set(swigCPtr, this, value);
+  }
+
+  public short getFreq1() {
+    return pjsuaJNI.pjmedia_tone_desc_freq1_get(swigCPtr, this);
+  }
+
+  public void setFreq2(short value) {
+    pjsuaJNI.pjmedia_tone_desc_freq2_set(swigCPtr, this, value);
+  }
+
+  public short getFreq2() {
+    return pjsuaJNI.pjmedia_tone_desc_freq2_get(swigCPtr, this);
+  }
+
+  public void setOn_msec(short value) {
+    pjsuaJNI.pjmedia_tone_desc_on_msec_set(swigCPtr, this, value);
+  }
+
+  public short getOn_msec() {
+    return pjsuaJNI.pjmedia_tone_desc_on_msec_get(swigCPtr, this);
+  }
+
+  public void setOff_msec(short value) {
+    pjsuaJNI.pjmedia_tone_desc_off_msec_set(swigCPtr, this, value);
+  }
+
+  public short getOff_msec() {
+    return pjsuaJNI.pjmedia_tone_desc_off_msec_get(swigCPtr, this);
+  }
+
+  public void setVolume(short value) {
+    pjsuaJNI.pjmedia_tone_desc_volume_set(swigCPtr, this, value);
+  }
+
+  public short getVolume() {
+    return pjsuaJNI.pjmedia_tone_desc_volume_get(swigCPtr, this);
+  }
+
+  public void setFlags(short value) {
+    pjsuaJNI.pjmedia_tone_desc_flags_set(swigCPtr, this, value);
+  }
+
+  public short getFlags() {
+    return pjsuaJNI.pjmedia_tone_desc_flags_get(swigCPtr, this);
+  }
+
+  public pjmedia_tone_desc() {
+    this(pjsuaJNI.new_pjmedia_tone_desc(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjmedia_tone_digit.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjmedia_tone_digit.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjmedia_tone_digit.java	(working copy)
@@ -0,0 +1,88 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjmedia_tone_digit {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjmedia_tone_digit(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjmedia_tone_digit obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjmedia_tone_digit(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  protected static long[] cArrayUnwrap(pjmedia_tone_digit[] arrayWrapper) {
+      long[] cArray = new long[arrayWrapper.length];
+      for (int i=0; i<arrayWrapper.length; i++)
+        cArray[i] = pjmedia_tone_digit.getCPtr(arrayWrapper[i]);
+      return cArray;
+  }
+
+  protected static pjmedia_tone_digit[] cArrayWrap(long[] cArray, boolean cMemoryOwn) {
+    pjmedia_tone_digit[] arrayWrapper = new pjmedia_tone_digit[cArray.length];
+    for (int i=0; i<cArray.length; i++)
+      arrayWrapper[i] = new pjmedia_tone_digit(cArray[i], cMemoryOwn);
+    return arrayWrapper;
+  }
+
+  public void setDigit(char value) {
+    pjsuaJNI.pjmedia_tone_digit_digit_set(swigCPtr, this, value);
+  }
+
+  public char getDigit() {
+    return pjsuaJNI.pjmedia_tone_digit_digit_get(swigCPtr, this);
+  }
+
+  public void setOn_msec(short value) {
+    pjsuaJNI.pjmedia_tone_digit_on_msec_set(swigCPtr, this, value);
+  }
+
+  public short getOn_msec() {
+    return pjsuaJNI.pjmedia_tone_digit_on_msec_get(swigCPtr, this);
+  }
+
+  public void setOff_msec(short value) {
+    pjsuaJNI.pjmedia_tone_digit_off_msec_set(swigCPtr, this, value);
+  }
+
+  public short getOff_msec() {
+    return pjsuaJNI.pjmedia_tone_digit_off_msec_get(swigCPtr, this);
+  }
+
+  public void setVolume(short value) {
+    pjsuaJNI.pjmedia_tone_digit_volume_set(swigCPtr, this, value);
+  }
+
+  public short getVolume() {
+    return pjsuaJNI.pjmedia_tone_digit_volume_get(swigCPtr, this);
+  }
+
+  public pjmedia_tone_digit() {
+    this(pjsuaJNI.new_pjmedia_tone_digit(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjrpid_activity.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjrpid_activity.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjrpid_activity.java	(working copy)
@@ -0,0 +1,53 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjrpid_activity {
+  PJRPID_ACTIVITY_UNKNOWN,
+  PJRPID_ACTIVITY_AWAY,
+  PJRPID_ACTIVITY_BUSY;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjrpid_activity swigToEnum(int swigValue) {
+    pjrpid_activity[] swigValues = pjrpid_activity.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjrpid_activity swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjrpid_activity.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjrpid_activity() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjrpid_activity(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjrpid_activity(pjrpid_activity swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjrpid_element.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjrpid_element.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjrpid_element.java	(working copy)
@@ -0,0 +1,76 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjrpid_element {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjrpid_element(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjrpid_element obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjrpid_element(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setType(SWIGTYPE_p_pjrpid_element_type value) {
+    pjsuaJNI.pjrpid_element_type_set(swigCPtr, this, SWIGTYPE_p_pjrpid_element_type.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjrpid_element_type getType() {
+    return new SWIGTYPE_p_pjrpid_element_type(pjsuaJNI.pjrpid_element_type_get(swigCPtr, this), true);
+  }
+
+  public void setId(pj_str_t value) {
+    pjsuaJNI.pjrpid_element_id_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getId() {
+    long cPtr = pjsuaJNI.pjrpid_element_id_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setActivity(pjrpid_activity value) {
+    pjsuaJNI.pjrpid_element_activity_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjrpid_activity getActivity() {
+    return pjrpid_activity.swigToEnum(pjsuaJNI.pjrpid_element_activity_get(swigCPtr, this));
+  }
+
+  public void setNote(pj_str_t value) {
+    pjsuaJNI.pjrpid_element_note_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getNote() {
+    long cPtr = pjsuaJNI.pjrpid_element_note_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public pjrpid_element() {
+    this(pjsuaJNI.new_pjrpid_element(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_auth_clt_pref.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_auth_clt_pref.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_auth_clt_pref.java	(working copy)
@@ -0,0 +1,59 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsip_auth_clt_pref {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsip_auth_clt_pref(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsip_auth_clt_pref obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsip_auth_clt_pref(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setInitial_auth(int value) {
+    pjsuaJNI.pjsip_auth_clt_pref_initial_auth_set(swigCPtr, this, value);
+  }
+
+  public int getInitial_auth() {
+    return pjsuaJNI.pjsip_auth_clt_pref_initial_auth_get(swigCPtr, this);
+  }
+
+  public void setAlgorithm(pj_str_t value) {
+    pjsuaJNI.pjsip_auth_clt_pref_algorithm_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getAlgorithm() {
+    long cPtr = pjsuaJNI.pjsip_auth_clt_pref_algorithm_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public pjsip_auth_clt_pref() {
+    this(pjsuaJNI.new_pjsip_auth_clt_pref(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_cred_data_type.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_cred_data_type.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_cred_data_type.java	(working copy)
@@ -0,0 +1,53 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsip_cred_data_type {
+  PJSIP_CRED_DATA_PLAIN_PASSWD(pjsuaJNI.PJSIP_CRED_DATA_PLAIN_PASSWD_get()),
+  PJSIP_CRED_DATA_DIGEST(pjsuaJNI.PJSIP_CRED_DATA_DIGEST_get()),
+  PJSIP_CRED_DATA_EXT_AKA(pjsuaJNI.PJSIP_CRED_DATA_EXT_AKA_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsip_cred_data_type swigToEnum(int swigValue) {
+    pjsip_cred_data_type[] swigValues = pjsip_cred_data_type.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsip_cred_data_type swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsip_cred_data_type.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_cred_data_type() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_cred_data_type(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_cred_data_type(pjsip_cred_data_type swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_cred_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_cred_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_cred_info.java	(working copy)
@@ -0,0 +1,86 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsip_cred_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsip_cred_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsip_cred_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsip_cred_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setRealm(pj_str_t value) {
+    pjsuaJNI.pjsip_cred_info_realm_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getRealm() {
+    long cPtr = pjsuaJNI.pjsip_cred_info_realm_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setScheme(pj_str_t value) {
+    pjsuaJNI.pjsip_cred_info_scheme_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getScheme() {
+    long cPtr = pjsuaJNI.pjsip_cred_info_scheme_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setUsername(pj_str_t value) {
+    pjsuaJNI.pjsip_cred_info_username_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getUsername() {
+    long cPtr = pjsuaJNI.pjsip_cred_info_username_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setData_type(int value) {
+    pjsuaJNI.pjsip_cred_info_data_type_set(swigCPtr, this, value);
+  }
+
+  public int getData_type() {
+    return pjsuaJNI.pjsip_cred_info_data_type_get(swigCPtr, this);
+  }
+
+  public void setData(pj_str_t value) {
+    pjsuaJNI.pjsip_cred_info_data_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getData() {
+    long cPtr = pjsuaJNI.pjsip_cred_info_data_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public pjsip_cred_info() {
+    this(pjsuaJNI.new_pjsip_cred_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_event.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_event.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_event.java	(working copy)
@@ -0,0 +1,50 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsip_event {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsip_event(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsip_event obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsip_event(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setType(pjsip_event_id_e value) {
+    pjsuaJNI.pjsip_event_type_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsip_event_id_e getType() {
+    return pjsip_event_id_e.swigToEnum(pjsuaJNI.pjsip_event_type_get(swigCPtr, this));
+  }
+
+  public pjsip_event() {
+    this(pjsuaJNI.new_pjsip_event(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_event_id_e.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_event_id_e.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_event_id_e.java	(working copy)
@@ -0,0 +1,57 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsip_event_id_e {
+  PJSIP_EVENT_UNKNOWN,
+  PJSIP_EVENT_TIMER,
+  PJSIP_EVENT_TX_MSG,
+  PJSIP_EVENT_RX_MSG,
+  PJSIP_EVENT_TRANSPORT_ERROR,
+  PJSIP_EVENT_TSX_STATE,
+  PJSIP_EVENT_USER;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsip_event_id_e swigToEnum(int swigValue) {
+    pjsip_event_id_e[] swigValues = pjsip_event_id_e.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsip_event_id_e swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsip_event_id_e.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_event_id_e() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_event_id_e(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_event_id_e(pjsip_event_id_e swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_inv_state.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_inv_state.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_inv_state.java	(working copy)
@@ -0,0 +1,57 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsip_inv_state {
+  PJSIP_INV_STATE_NULL,
+  PJSIP_INV_STATE_CALLING,
+  PJSIP_INV_STATE_INCOMING,
+  PJSIP_INV_STATE_EARLY,
+  PJSIP_INV_STATE_CONNECTING,
+  PJSIP_INV_STATE_CONFIRMED,
+  PJSIP_INV_STATE_DISCONNECTED;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsip_inv_state swigToEnum(int swigValue) {
+    pjsip_inv_state[] swigValues = pjsip_inv_state.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsip_inv_state swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsip_inv_state.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_inv_state() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_inv_state(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_inv_state(pjsip_inv_state swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_redirect_op.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_redirect_op.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_redirect_op.java	(working copy)
@@ -0,0 +1,55 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsip_redirect_op {
+  PJSIP_REDIRECT_REJECT,
+  PJSIP_REDIRECT_ACCEPT_REPLACE,
+  PJSIP_REDIRECT_ACCEPT,
+  PJSIP_REDIRECT_PENDING,
+  PJSIP_REDIRECT_STOP;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsip_redirect_op swigToEnum(int swigValue) {
+    pjsip_redirect_op[] swigValues = pjsip_redirect_op.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsip_redirect_op swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsip_redirect_op.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_redirect_op() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_redirect_op(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_redirect_op(pjsip_redirect_op swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_ssl_method.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_ssl_method.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_ssl_method.java	(working copy)
@@ -0,0 +1,57 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsip_ssl_method {
+  PJSIP_SSL_UNSPECIFIED_METHOD(pjsuaJNI.PJSIP_SSL_UNSPECIFIED_METHOD_get()),
+  PJSIP_SSLV2_METHOD(pjsuaJNI.PJSIP_SSLV2_METHOD_get()),
+  PJSIP_SSLV3_METHOD(pjsuaJNI.PJSIP_SSLV3_METHOD_get()),
+  PJSIP_TLSV1_METHOD(pjsuaJNI.PJSIP_TLSV1_METHOD_get()),
+  PJSIP_TLSV1_1_METHOD(pjsuaJNI.PJSIP_TLSV1_1_METHOD_get()),
+  PJSIP_TLSV1_2_METHOD(pjsuaJNI.PJSIP_TLSV1_2_METHOD_get()),
+  PJSIP_SSLV23_METHOD(pjsuaJNI.PJSIP_SSLV23_METHOD_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsip_ssl_method swigToEnum(int swigValue) {
+    pjsip_ssl_method[] swigValues = pjsip_ssl_method.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsip_ssl_method swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsip_ssl_method.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_ssl_method() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_ssl_method(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_ssl_method(pjsip_ssl_method swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_status_code.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_status_code.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_status_code.java	(working copy)
@@ -0,0 +1,107 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsip_status_code {
+  PJSIP_SC_TRYING(pjsuaJNI.PJSIP_SC_TRYING_get()),
+  PJSIP_SC_RINGING(pjsuaJNI.PJSIP_SC_RINGING_get()),
+  PJSIP_SC_CALL_BEING_FORWARDED(pjsuaJNI.PJSIP_SC_CALL_BEING_FORWARDED_get()),
+  PJSIP_SC_QUEUED(pjsuaJNI.PJSIP_SC_QUEUED_get()),
+  PJSIP_SC_PROGRESS(pjsuaJNI.PJSIP_SC_PROGRESS_get()),
+  PJSIP_SC_OK(pjsuaJNI.PJSIP_SC_OK_get()),
+  PJSIP_SC_ACCEPTED(pjsuaJNI.PJSIP_SC_ACCEPTED_get()),
+  PJSIP_SC_MULTIPLE_CHOICES(pjsuaJNI.PJSIP_SC_MULTIPLE_CHOICES_get()),
+  PJSIP_SC_MOVED_PERMANENTLY(pjsuaJNI.PJSIP_SC_MOVED_PERMANENTLY_get()),
+  PJSIP_SC_MOVED_TEMPORARILY(pjsuaJNI.PJSIP_SC_MOVED_TEMPORARILY_get()),
+  PJSIP_SC_USE_PROXY(pjsuaJNI.PJSIP_SC_USE_PROXY_get()),
+  PJSIP_SC_ALTERNATIVE_SERVICE(pjsuaJNI.PJSIP_SC_ALTERNATIVE_SERVICE_get()),
+  PJSIP_SC_BAD_REQUEST(pjsuaJNI.PJSIP_SC_BAD_REQUEST_get()),
+  PJSIP_SC_UNAUTHORIZED(pjsuaJNI.PJSIP_SC_UNAUTHORIZED_get()),
+  PJSIP_SC_PAYMENT_REQUIRED(pjsuaJNI.PJSIP_SC_PAYMENT_REQUIRED_get()),
+  PJSIP_SC_FORBIDDEN(pjsuaJNI.PJSIP_SC_FORBIDDEN_get()),
+  PJSIP_SC_NOT_FOUND(pjsuaJNI.PJSIP_SC_NOT_FOUND_get()),
+  PJSIP_SC_METHOD_NOT_ALLOWED(pjsuaJNI.PJSIP_SC_METHOD_NOT_ALLOWED_get()),
+  PJSIP_SC_NOT_ACCEPTABLE(pjsuaJNI.PJSIP_SC_NOT_ACCEPTABLE_get()),
+  PJSIP_SC_PROXY_AUTHENTICATION_REQUIRED(pjsuaJNI.PJSIP_SC_PROXY_AUTHENTICATION_REQUIRED_get()),
+  PJSIP_SC_REQUEST_TIMEOUT(pjsuaJNI.PJSIP_SC_REQUEST_TIMEOUT_get()),
+  PJSIP_SC_GONE(pjsuaJNI.PJSIP_SC_GONE_get()),
+  PJSIP_SC_REQUEST_ENTITY_TOO_LARGE(pjsuaJNI.PJSIP_SC_REQUEST_ENTITY_TOO_LARGE_get()),
+  PJSIP_SC_REQUEST_URI_TOO_LONG(pjsuaJNI.PJSIP_SC_REQUEST_URI_TOO_LONG_get()),
+  PJSIP_SC_UNSUPPORTED_MEDIA_TYPE(pjsuaJNI.PJSIP_SC_UNSUPPORTED_MEDIA_TYPE_get()),
+  PJSIP_SC_UNSUPPORTED_URI_SCHEME(pjsuaJNI.PJSIP_SC_UNSUPPORTED_URI_SCHEME_get()),
+  PJSIP_SC_BAD_EXTENSION(pjsuaJNI.PJSIP_SC_BAD_EXTENSION_get()),
+  PJSIP_SC_EXTENSION_REQUIRED(pjsuaJNI.PJSIP_SC_EXTENSION_REQUIRED_get()),
+  PJSIP_SC_SESSION_TIMER_TOO_SMALL(pjsuaJNI.PJSIP_SC_SESSION_TIMER_TOO_SMALL_get()),
+  PJSIP_SC_INTERVAL_TOO_BRIEF(pjsuaJNI.PJSIP_SC_INTERVAL_TOO_BRIEF_get()),
+  PJSIP_SC_TEMPORARILY_UNAVAILABLE(pjsuaJNI.PJSIP_SC_TEMPORARILY_UNAVAILABLE_get()),
+  PJSIP_SC_CALL_TSX_DOES_NOT_EXIST(pjsuaJNI.PJSIP_SC_CALL_TSX_DOES_NOT_EXIST_get()),
+  PJSIP_SC_LOOP_DETECTED(pjsuaJNI.PJSIP_SC_LOOP_DETECTED_get()),
+  PJSIP_SC_TOO_MANY_HOPS(pjsuaJNI.PJSIP_SC_TOO_MANY_HOPS_get()),
+  PJSIP_SC_ADDRESS_INCOMPLETE(pjsuaJNI.PJSIP_SC_ADDRESS_INCOMPLETE_get()),
+  PJSIP_AC_AMBIGUOUS(pjsuaJNI.PJSIP_AC_AMBIGUOUS_get()),
+  PJSIP_SC_BUSY_HERE(pjsuaJNI.PJSIP_SC_BUSY_HERE_get()),
+  PJSIP_SC_REQUEST_TERMINATED(pjsuaJNI.PJSIP_SC_REQUEST_TERMINATED_get()),
+  PJSIP_SC_NOT_ACCEPTABLE_HERE(pjsuaJNI.PJSIP_SC_NOT_ACCEPTABLE_HERE_get()),
+  PJSIP_SC_BAD_EVENT(pjsuaJNI.PJSIP_SC_BAD_EVENT_get()),
+  PJSIP_SC_REQUEST_UPDATED(pjsuaJNI.PJSIP_SC_REQUEST_UPDATED_get()),
+  PJSIP_SC_REQUEST_PENDING(pjsuaJNI.PJSIP_SC_REQUEST_PENDING_get()),
+  PJSIP_SC_UNDECIPHERABLE(pjsuaJNI.PJSIP_SC_UNDECIPHERABLE_get()),
+  PJSIP_SC_INTERNAL_SERVER_ERROR(pjsuaJNI.PJSIP_SC_INTERNAL_SERVER_ERROR_get()),
+  PJSIP_SC_NOT_IMPLEMENTED(pjsuaJNI.PJSIP_SC_NOT_IMPLEMENTED_get()),
+  PJSIP_SC_BAD_GATEWAY(pjsuaJNI.PJSIP_SC_BAD_GATEWAY_get()),
+  PJSIP_SC_SERVICE_UNAVAILABLE(pjsuaJNI.PJSIP_SC_SERVICE_UNAVAILABLE_get()),
+  PJSIP_SC_SERVER_TIMEOUT(pjsuaJNI.PJSIP_SC_SERVER_TIMEOUT_get()),
+  PJSIP_SC_VERSION_NOT_SUPPORTED(pjsuaJNI.PJSIP_SC_VERSION_NOT_SUPPORTED_get()),
+  PJSIP_SC_MESSAGE_TOO_LARGE(pjsuaJNI.PJSIP_SC_MESSAGE_TOO_LARGE_get()),
+  PJSIP_SC_PRECONDITION_FAILURE(pjsuaJNI.PJSIP_SC_PRECONDITION_FAILURE_get()),
+  PJSIP_SC_BUSY_EVERYWHERE(pjsuaJNI.PJSIP_SC_BUSY_EVERYWHERE_get()),
+  PJSIP_SC_DECLINE(pjsuaJNI.PJSIP_SC_DECLINE_get()),
+  PJSIP_SC_DOES_NOT_EXIST_ANYWHERE(pjsuaJNI.PJSIP_SC_DOES_NOT_EXIST_ANYWHERE_get()),
+  PJSIP_SC_NOT_ACCEPTABLE_ANYWHERE(pjsuaJNI.PJSIP_SC_NOT_ACCEPTABLE_ANYWHERE_get()),
+  PJSIP_SC_TSX_TIMEOUT(pjsuaJNI.PJSIP_SC_TSX_TIMEOUT_get()),
+  PJSIP_SC_TSX_TRANSPORT_ERROR(pjsuaJNI.PJSIP_SC_TSX_TRANSPORT_ERROR_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsip_status_code swigToEnum(int swigValue) {
+    pjsip_status_code[] swigValues = pjsip_status_code.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsip_status_code swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsip_status_code.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_status_code() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_status_code(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_status_code(pjsip_status_code swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_timer_setting.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_timer_setting.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_timer_setting.java	(working copy)
@@ -0,0 +1,58 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsip_timer_setting {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsip_timer_setting(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsip_timer_setting obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsip_timer_setting(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setMin_se(long value) {
+    pjsuaJNI.pjsip_timer_setting_min_se_set(swigCPtr, this, value);
+  }
+
+  public long getMin_se() {
+    return pjsuaJNI.pjsip_timer_setting_min_se_get(swigCPtr, this);
+  }
+
+  public void setSess_expires(long value) {
+    pjsuaJNI.pjsip_timer_setting_sess_expires_set(swigCPtr, this, value);
+  }
+
+  public long getSess_expires() {
+    return pjsuaJNI.pjsip_timer_setting_sess_expires_get(swigCPtr, this);
+  }
+
+  public pjsip_timer_setting() {
+    this(pjsuaJNI.new_pjsip_timer_setting(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_tls_setting.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_tls_setting.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_tls_setting.java	(working copy)
@@ -0,0 +1,202 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsip_tls_setting {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsip_tls_setting(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsip_tls_setting obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsip_tls_setting(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setCa_list_file(pj_str_t value) {
+    pjsuaJNI.pjsip_tls_setting_ca_list_file_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getCa_list_file() {
+    long cPtr = pjsuaJNI.pjsip_tls_setting_ca_list_file_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setCa_list_path(pj_str_t value) {
+    pjsuaJNI.pjsip_tls_setting_ca_list_path_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getCa_list_path() {
+    long cPtr = pjsuaJNI.pjsip_tls_setting_ca_list_path_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setCert_file(pj_str_t value) {
+    pjsuaJNI.pjsip_tls_setting_cert_file_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getCert_file() {
+    long cPtr = pjsuaJNI.pjsip_tls_setting_cert_file_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setPrivkey_file(pj_str_t value) {
+    pjsuaJNI.pjsip_tls_setting_privkey_file_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getPrivkey_file() {
+    long cPtr = pjsuaJNI.pjsip_tls_setting_privkey_file_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setPassword(pj_str_t value) {
+    pjsuaJNI.pjsip_tls_setting_password_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getPassword() {
+    long cPtr = pjsuaJNI.pjsip_tls_setting_password_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setMethod(pjsip_ssl_method value) {
+    pjsuaJNI.pjsip_tls_setting_method_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsip_ssl_method getMethod() {
+    return pjsip_ssl_method.swigToEnum(pjsuaJNI.pjsip_tls_setting_method_get(swigCPtr, this));
+  }
+
+  public void setProto(long value) {
+    pjsuaJNI.pjsip_tls_setting_proto_set(swigCPtr, this, value);
+  }
+
+  public long getProto() {
+    return pjsuaJNI.pjsip_tls_setting_proto_get(swigCPtr, this);
+  }
+
+  public void setCiphers_num(long value) {
+    pjsuaJNI.pjsip_tls_setting_ciphers_num_set(swigCPtr, this, value);
+  }
+
+  public long getCiphers_num() {
+    return pjsuaJNI.pjsip_tls_setting_ciphers_num_get(swigCPtr, this);
+  }
+
+  public void setCiphers(SWIGTYPE_p_pj_ssl_cipher value) {
+    pjsuaJNI.pjsip_tls_setting_ciphers_set(swigCPtr, this, SWIGTYPE_p_pj_ssl_cipher.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_ssl_cipher getCiphers() {
+    long cPtr = pjsuaJNI.pjsip_tls_setting_ciphers_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pj_ssl_cipher(cPtr, false);
+  }
+
+  public void setVerify_server(int value) {
+    pjsuaJNI.pjsip_tls_setting_verify_server_set(swigCPtr, this, value);
+  }
+
+  public int getVerify_server() {
+    return pjsuaJNI.pjsip_tls_setting_verify_server_get(swigCPtr, this);
+  }
+
+  public void setVerify_client(int value) {
+    pjsuaJNI.pjsip_tls_setting_verify_client_set(swigCPtr, this, value);
+  }
+
+  public int getVerify_client() {
+    return pjsuaJNI.pjsip_tls_setting_verify_client_get(swigCPtr, this);
+  }
+
+  public void setRequire_client_cert(int value) {
+    pjsuaJNI.pjsip_tls_setting_require_client_cert_set(swigCPtr, this, value);
+  }
+
+  public int getRequire_client_cert() {
+    return pjsuaJNI.pjsip_tls_setting_require_client_cert_get(swigCPtr, this);
+  }
+
+  public void setTimeout(pj_time_val value) {
+    pjsuaJNI.pjsip_tls_setting_timeout_set(swigCPtr, this, pj_time_val.getCPtr(value), value);
+  }
+
+  public pj_time_val getTimeout() {
+    long cPtr = pjsuaJNI.pjsip_tls_setting_timeout_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_time_val(cPtr, false);
+  }
+
+  public void setReuse_addr(int value) {
+    pjsuaJNI.pjsip_tls_setting_reuse_addr_set(swigCPtr, this, value);
+  }
+
+  public int getReuse_addr() {
+    return pjsuaJNI.pjsip_tls_setting_reuse_addr_get(swigCPtr, this);
+  }
+
+  public void setQos_type(pj_qos_type value) {
+    pjsuaJNI.pjsip_tls_setting_qos_type_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pj_qos_type getQos_type() {
+    return pj_qos_type.swigToEnum(pjsuaJNI.pjsip_tls_setting_qos_type_get(swigCPtr, this));
+  }
+
+  public void setQos_params(pj_qos_params value) {
+    pjsuaJNI.pjsip_tls_setting_qos_params_set(swigCPtr, this, pj_qos_params.getCPtr(value), value);
+  }
+
+  public pj_qos_params getQos_params() {
+    long cPtr = pjsuaJNI.pjsip_tls_setting_qos_params_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_qos_params(cPtr, false);
+  }
+
+  public void setQos_ignore_error(int value) {
+    pjsuaJNI.pjsip_tls_setting_qos_ignore_error_set(swigCPtr, this, value);
+  }
+
+  public int getQos_ignore_error() {
+    return pjsuaJNI.pjsip_tls_setting_qos_ignore_error_get(swigCPtr, this);
+  }
+
+  public void setSockopt_params(SWIGTYPE_p_pj_sockopt_params value) {
+    pjsuaJNI.pjsip_tls_setting_sockopt_params_set(swigCPtr, this, SWIGTYPE_p_pj_sockopt_params.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_sockopt_params getSockopt_params() {
+    return new SWIGTYPE_p_pj_sockopt_params(pjsuaJNI.pjsip_tls_setting_sockopt_params_get(swigCPtr, this), true);
+  }
+
+  public void setSockopt_ignore_error(int value) {
+    pjsuaJNI.pjsip_tls_setting_sockopt_ignore_error_set(swigCPtr, this, value);
+  }
+
+  public int getSockopt_ignore_error() {
+    return pjsuaJNI.pjsip_tls_setting_sockopt_ignore_error_get(swigCPtr, this);
+  }
+
+  public pjsip_tls_setting() {
+    this(pjsuaJNI.new_pjsip_tls_setting(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsip_transport_type_e.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsip_transport_type_e.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsip_transport_type_e.java	(working copy)
@@ -0,0 +1,62 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsip_transport_type_e {
+  PJSIP_TRANSPORT_UNSPECIFIED,
+  PJSIP_TRANSPORT_UDP,
+  PJSIP_TRANSPORT_TCP,
+  PJSIP_TRANSPORT_TLS,
+  PJSIP_TRANSPORT_SCTP,
+  PJSIP_TRANSPORT_LOOP,
+  PJSIP_TRANSPORT_LOOP_DGRAM,
+  PJSIP_TRANSPORT_START_OTHER,
+  PJSIP_TRANSPORT_IPV6(pjsuaJNI.PJSIP_TRANSPORT_IPV6_get()),
+  PJSIP_TRANSPORT_UDP6(pjsuaJNI.PJSIP_TRANSPORT_UDP6_get()),
+  PJSIP_TRANSPORT_TCP6(pjsuaJNI.PJSIP_TRANSPORT_TCP6_get()),
+  PJSIP_TRANSPORT_TLS6(pjsuaJNI.PJSIP_TRANSPORT_TLS6_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsip_transport_type_e swigToEnum(int swigValue) {
+    pjsip_transport_type_e[] swigValues = pjsip_transport_type_e.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsip_transport_type_e swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsip_transport_type_e.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_transport_type_e() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_transport_type_e(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsip_transport_type_e(pjsip_transport_type_e swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua.java	(working copy)
@@ -0,0 +1,915 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua implements pjsuaConstants {
+  public static pj_str_t pj_str_copy(String str) {
+    return new pj_str_t(pjsuaJNI.pj_str_copy(str), true);
+  }
+
+  public static void setCallbackObject(Callback callback) {
+    pjsuaJNI.setCallbackObject(Callback.getCPtr(callback), callback);
+  }
+
+  public static pj_pool_t pjsua_pool_create(String name, long init_size, long increment) {
+    long cPtr = pjsuaJNI.pjsua_pool_create(name, init_size, increment);
+    return (cPtr == 0) ? null : new pj_pool_t(cPtr, false);
+  }
+
+  public static void pj_pool_release(pj_pool_t pool) {
+    pjsuaJNI.pj_pool_release(pj_pool_t.getCPtr(pool), pool);
+  }
+
+  public static int pjmedia_tonegen_create2(pj_pool_t pool, pj_str_t name, long clock_rate, long channel_count, long samples_per_frame, long bits_per_sample, long options, pjmedia_port pp_port) {
+    return pjsuaJNI.pjmedia_tonegen_create2(pj_pool_t.getCPtr(pool), pool, pj_str_t.getCPtr(name), name, clock_rate, channel_count, samples_per_frame, bits_per_sample, options, pp_port);
+  }
+
+  public static int pjmedia_tonegen_play(pjmedia_port tonegen, long count, pjmedia_tone_desc[] tones, long options) {
+    return pjsuaJNI.pjmedia_tonegen_play(pjmedia_port.getCPtr(tonegen), tonegen, count, pjmedia_tone_desc.cArrayUnwrap(tones), options);
+  }
+
+  public static int pjmedia_tonegen_play_digits(pjmedia_port tonegen, long count, pjmedia_tone_digit[] digits, long options) {
+    return pjsuaJNI.pjmedia_tonegen_play_digits(pjmedia_port.getCPtr(tonegen), tonegen, count, pjmedia_tone_digit.cArrayUnwrap(digits), options);
+  }
+
+  public static int pjmedia_tonegen_rewind(pjmedia_port tonegen) {
+    return pjsuaJNI.pjmedia_tonegen_rewind(pjmedia_port.getCPtr(tonegen), tonegen);
+  }
+
+  public static int pjmedia_tonegen_stop(pjmedia_port tonegen) {
+    return pjsuaJNI.pjmedia_tonegen_stop(pjmedia_port.getCPtr(tonegen), tonegen);
+  }
+
+  public static int pjmedia_port_destroy(pjmedia_port port) {
+    return pjsuaJNI.pjmedia_port_destroy(pjmedia_port.getCPtr(port), port);
+  }
+
+  public static void setZrtpCallbackObject(ZrtpCallback callback) {
+    pjsuaJNI.setZrtpCallbackObject(ZrtpCallback.getCPtr(callback), callback);
+  }
+
+  public static int mobile_reg_handler_init() {
+    return pjsuaJNI.mobile_reg_handler_init();
+  }
+
+  public static void mobile_reg_handler_set_callback(MobileRegHandlerCallback callback) {
+    pjsuaJNI.mobile_reg_handler_set_callback(MobileRegHandlerCallback.getCPtr(callback), callback);
+  }
+
+  public static int sipclf_mod_init() {
+    return pjsuaJNI.sipclf_mod_init();
+  }
+
+  public static int mod_earlylock_init() {
+    return pjsuaJNI.mod_earlylock_init();
+  }
+
+  public static void mod_earlylock_set_callback(EarlyLockCallback callback) {
+    pjsuaJNI.mod_earlylock_set_callback(EarlyLockCallback.getCPtr(callback), callback);
+  }
+
+  public synchronized static void logging_config_default(pjsua_logging_config cfg) {
+    pjsuaJNI.logging_config_default(pjsua_logging_config.getCPtr(cfg), cfg);
+  }
+
+  public synchronized static void logging_config_dup(pj_pool_t pool, pjsua_logging_config dst, pjsua_logging_config src) {
+    pjsuaJNI.logging_config_dup(pj_pool_t.getCPtr(pool), pool, pjsua_logging_config.getCPtr(dst), dst, pjsua_logging_config.getCPtr(src), src);
+  }
+
+  public synchronized static void config_default(pjsua_config cfg) {
+    pjsuaJNI.config_default(pjsua_config.getCPtr(cfg), cfg);
+  }
+
+  public synchronized static void config_dup(pj_pool_t pool, pjsua_config dst, pjsua_config src) {
+    pjsuaJNI.config_dup(pj_pool_t.getCPtr(pool), pool, pjsua_config.getCPtr(dst), dst, pjsua_config.getCPtr(src), src);
+  }
+
+  public synchronized static void msg_data_init(pjsua_msg_data msg_data) {
+    pjsuaJNI.msg_data_init(pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static pjsua_msg_data msg_data_clone(pj_pool_t pool, pjsua_msg_data rhs) {
+    long cPtr = pjsuaJNI.msg_data_clone(pj_pool_t.getCPtr(pool), pool, pjsua_msg_data.getCPtr(rhs), rhs);
+    return (cPtr == 0) ? null : new pjsua_msg_data(cPtr, false);
+  }
+
+  public synchronized static int create() {
+    return pjsuaJNI.create();
+  }
+
+  public synchronized static int start() {
+    return pjsuaJNI.start();
+  }
+
+  public synchronized static pjsua_state get_state() {
+    return pjsua_state.swigToEnum(pjsuaJNI.get_state());
+  }
+
+  public synchronized static int handle_events(long msec_timeout) {
+    return pjsuaJNI.handle_events(msec_timeout);
+  }
+
+  public synchronized static void stop_worker_threads() {
+    pjsuaJNI.stop_worker_threads();
+  }
+
+  public synchronized static pj_pool_t pool_create(String name, long init_size, long increment) {
+    long cPtr = pjsuaJNI.pool_create(name, init_size, increment);
+    return (cPtr == 0) ? null : new pj_pool_t(cPtr, false);
+  }
+
+  public synchronized static int reconfigure_logging(pjsua_logging_config c) {
+    return pjsuaJNI.reconfigure_logging(pjsua_logging_config.getCPtr(c), c);
+  }
+
+  public synchronized static SWIGTYPE_p_pjsip_endpoint get_pjsip_endpt() {
+    long cPtr = pjsuaJNI.get_pjsip_endpt();
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pjsip_endpoint(cPtr, false);
+  }
+
+  public synchronized static SWIGTYPE_p_pjmedia_endpt get_pjmedia_endpt() {
+    long cPtr = pjsuaJNI.get_pjmedia_endpt();
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pjmedia_endpt(cPtr, false);
+  }
+
+  public synchronized static SWIGTYPE_p_pj_pool_factory get_pool_factory() {
+    long cPtr = pjsuaJNI.get_pool_factory();
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pj_pool_factory(cPtr, false);
+  }
+
+  public synchronized static int detect_nat_type() {
+    return pjsuaJNI.detect_nat_type();
+  }
+
+  public synchronized static int get_nat_type(int[] type) {
+    return pjsuaJNI.get_nat_type(type);
+  }
+
+  public synchronized static int resolve_stun_servers(long count, pj_str_t[] srv, int wait, byte[] token, SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void cb) {
+    return pjsuaJNI.resolve_stun_servers(count, pj_str_t.cArrayUnwrap(srv), wait, token, SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void.getCPtr(cb));
+  }
+
+  public synchronized static int cancel_stun_resolution(byte[] token, int notify_cb) {
+    return pjsuaJNI.cancel_stun_resolution(token, notify_cb);
+  }
+
+  public synchronized static int verify_sip_url(String url) {
+    return pjsuaJNI.verify_sip_url(url);
+  }
+
+  public synchronized static int verify_url(String url) {
+    return pjsuaJNI.verify_url(url);
+  }
+
+  public synchronized static int schedule_timer(SWIGTYPE_p_pj_timer_entry entry, pj_time_val delay) {
+    return pjsuaJNI.schedule_timer(SWIGTYPE_p_pj_timer_entry.getCPtr(entry), pj_time_val.getCPtr(delay), delay);
+  }
+
+  public static int pjsua_schedule_timer2(SWIGTYPE_p_f_p_void__void cb, byte[] user_data, long msec_delay) {
+    return pjsuaJNI.pjsua_schedule_timer2(SWIGTYPE_p_f_p_void__void.getCPtr(cb), user_data, msec_delay);
+  }
+
+  public synchronized static void cancel_timer(SWIGTYPE_p_pj_timer_entry entry) {
+    pjsuaJNI.cancel_timer(SWIGTYPE_p_pj_timer_entry.getCPtr(entry));
+  }
+
+  public synchronized static void perror(String sender, String title, int status) {
+    pjsuaJNI.perror(sender, title, status);
+  }
+
+  public synchronized static void dump(int detail) {
+    pjsuaJNI.dump(detail);
+  }
+
+  public synchronized static void transport_config_default(pjsua_transport_config cfg) {
+    pjsuaJNI.transport_config_default(pjsua_transport_config.getCPtr(cfg), cfg);
+  }
+
+  public synchronized static void transport_config_dup(pj_pool_t pool, pjsua_transport_config dst, pjsua_transport_config src) {
+    pjsuaJNI.transport_config_dup(pj_pool_t.getCPtr(pool), pool, pjsua_transport_config.getCPtr(dst), dst, pjsua_transport_config.getCPtr(src), src);
+  }
+
+  public synchronized static int transport_create(pjsip_transport_type_e type, pjsua_transport_config cfg, int[] p_id) {
+    return pjsuaJNI.transport_create(type.swigValue(), pjsua_transport_config.getCPtr(cfg), cfg, p_id);
+  }
+
+  public synchronized static int transport_register(SWIGTYPE_p_pjsip_transport tp, int[] p_id) {
+    return pjsuaJNI.transport_register(SWIGTYPE_p_pjsip_transport.getCPtr(tp), p_id);
+  }
+
+  public synchronized static int enum_transports(int[] id, long[] count) {
+    return pjsuaJNI.enum_transports(id, count);
+  }
+
+  public synchronized static int transport_get_info(int id, pjsua_transport_info info) {
+    return pjsuaJNI.transport_get_info(id, pjsua_transport_info.getCPtr(info), info);
+  }
+
+  public synchronized static int transport_set_enable(int id, int enabled) {
+    return pjsuaJNI.transport_set_enable(id, enabled);
+  }
+
+  public synchronized static int transport_close(int id, int force) {
+    return pjsuaJNI.transport_close(id, force);
+  }
+
+  public synchronized static void ice_config_from_media_config(pj_pool_t pool, pjsua_ice_config dst, pjsua_media_config src) {
+    pjsuaJNI.ice_config_from_media_config(pj_pool_t.getCPtr(pool), pool, pjsua_ice_config.getCPtr(dst), dst, pjsua_media_config.getCPtr(src), src);
+  }
+
+  public synchronized static void ice_config_dup(pj_pool_t pool, pjsua_ice_config dst, pjsua_ice_config src) {
+    pjsuaJNI.ice_config_dup(pj_pool_t.getCPtr(pool), pool, pjsua_ice_config.getCPtr(dst), dst, pjsua_ice_config.getCPtr(src), src);
+  }
+
+  public synchronized static void turn_config_from_media_config(pj_pool_t pool, pjsua_turn_config dst, pjsua_media_config src) {
+    pjsuaJNI.turn_config_from_media_config(pj_pool_t.getCPtr(pool), pool, pjsua_turn_config.getCPtr(dst), dst, pjsua_media_config.getCPtr(src), src);
+  }
+
+  public synchronized static void turn_config_dup(pj_pool_t pool, pjsua_turn_config dst, pjsua_turn_config src) {
+    pjsuaJNI.turn_config_dup(pj_pool_t.getCPtr(pool), pool, pjsua_turn_config.getCPtr(dst), dst, pjsua_turn_config.getCPtr(src), src);
+  }
+
+  public synchronized static void acc_config_default(pjsua_acc_config cfg) {
+    pjsuaJNI.acc_config_default(pjsua_acc_config.getCPtr(cfg), cfg);
+  }
+
+  public synchronized static void acc_config_dup(pj_pool_t pool, pjsua_acc_config dst, pjsua_acc_config src) {
+    pjsuaJNI.acc_config_dup(pj_pool_t.getCPtr(pool), pool, pjsua_acc_config.getCPtr(dst), dst, pjsua_acc_config.getCPtr(src), src);
+  }
+
+  public synchronized static long acc_get_count() {
+    return pjsuaJNI.acc_get_count();
+  }
+
+  public synchronized static int acc_is_valid(int acc_id) {
+    return pjsuaJNI.acc_is_valid(acc_id);
+  }
+
+  public synchronized static int acc_set_default(int acc_id) {
+    return pjsuaJNI.acc_set_default(acc_id);
+  }
+
+  public synchronized static int acc_get_default() {
+    return pjsuaJNI.acc_get_default();
+  }
+
+  public synchronized static int acc_add(pjsua_acc_config acc_cfg, int is_default, int[] p_acc_id) {
+    return pjsuaJNI.acc_add(pjsua_acc_config.getCPtr(acc_cfg), acc_cfg, is_default, p_acc_id);
+  }
+
+  public synchronized static int acc_add_local(int tid, int is_default, int[] p_acc_id) {
+    return pjsuaJNI.acc_add_local(tid, is_default, p_acc_id);
+  }
+
+  public synchronized static int acc_set_user_data(int acc_id, byte[] user_data) {
+    return pjsuaJNI.acc_set_user_data(acc_id, user_data);
+  }
+
+  public synchronized static byte[] acc_get_user_data(int acc_id) {
+	return pjsuaJNI.acc_get_user_data(acc_id);
+}
+
+  public synchronized static int acc_del(int acc_id) {
+    return pjsuaJNI.acc_del(acc_id);
+  }
+
+  public synchronized static int acc_get_config(int acc_id, pj_pool_t pool, pjsua_acc_config acc_cfg) {
+    return pjsuaJNI.acc_get_config(acc_id, pj_pool_t.getCPtr(pool), pool, pjsua_acc_config.getCPtr(acc_cfg), acc_cfg);
+  }
+
+  public synchronized static int acc_modify(int acc_id, pjsua_acc_config acc_cfg) {
+    return pjsuaJNI.acc_modify(acc_id, pjsua_acc_config.getCPtr(acc_cfg), acc_cfg);
+  }
+
+  public synchronized static int acc_set_online_status(int acc_id, int is_online) {
+    return pjsuaJNI.acc_set_online_status(acc_id, is_online);
+  }
+
+  public synchronized static int acc_set_online_status2(int acc_id, int is_online, pjrpid_element pr) {
+    return pjsuaJNI.acc_set_online_status2(acc_id, is_online, pjrpid_element.getCPtr(pr), pr);
+  }
+
+  public synchronized static int acc_set_registration(int acc_id, int renew) {
+    return pjsuaJNI.acc_set_registration(acc_id, renew);
+  }
+
+  public synchronized static int acc_get_info(int acc_id, pjsua_acc_info info) {
+    return pjsuaJNI.acc_get_info(acc_id, pjsua_acc_info.getCPtr(info), info);
+  }
+
+  public synchronized static int enum_accs(int[] ids, long[] count) {
+    return pjsuaJNI.enum_accs(ids, count);
+  }
+
+  public synchronized static int acc_enum_info(pjsua_acc_info info, long[] count) {
+    return pjsuaJNI.acc_enum_info(pjsua_acc_info.getCPtr(info), info, count);
+  }
+
+  public synchronized static int acc_find_for_outgoing(pj_str_t url) {
+    return pjsuaJNI.acc_find_for_outgoing(pj_str_t.getCPtr(url), url);
+  }
+
+  public synchronized static int acc_find_for_incoming(SWIGTYPE_p_pjsip_rx_data rdata) {
+    return pjsuaJNI.acc_find_for_incoming(SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata));
+  }
+
+  public synchronized static int acc_create_request(int acc_id, SWIGTYPE_p_pjsip_method method, pj_str_t target, SWIGTYPE_p_p_pjsip_tx_data p_tdata) {
+    return pjsuaJNI.acc_create_request(acc_id, SWIGTYPE_p_pjsip_method.getCPtr(method), pj_str_t.getCPtr(target), target, SWIGTYPE_p_p_pjsip_tx_data.getCPtr(p_tdata));
+  }
+
+  public synchronized static int acc_create_uac_contact(pj_pool_t pool, pj_str_t contact, int acc_id, pj_str_t uri) {
+    return pjsuaJNI.acc_create_uac_contact(pj_pool_t.getCPtr(pool), pool, pj_str_t.getCPtr(contact), contact, acc_id, pj_str_t.getCPtr(uri), uri);
+  }
+
+  public synchronized static int acc_create_uas_contact(pj_pool_t pool, pj_str_t contact, int acc_id, SWIGTYPE_p_pjsip_rx_data rdata) {
+    return pjsuaJNI.acc_create_uas_contact(pj_pool_t.getCPtr(pool), pool, pj_str_t.getCPtr(contact), contact, acc_id, SWIGTYPE_p_pjsip_rx_data.getCPtr(rdata));
+  }
+
+  public synchronized static int acc_set_transport(int acc_id, int tp_id) {
+    return pjsuaJNI.acc_set_transport(acc_id, tp_id);
+  }
+
+  public synchronized static void call_setting_default(pjsua_call_setting opt) {
+    pjsuaJNI.call_setting_default(pjsua_call_setting.getCPtr(opt), opt);
+  }
+
+  public synchronized static void call_vid_strm_op_param_default(pjsua_call_vid_strm_op_param param) {
+    pjsuaJNI.call_vid_strm_op_param_default(pjsua_call_vid_strm_op_param.getCPtr(param), param);
+  }
+
+  public synchronized static long call_get_max_count() {
+    return pjsuaJNI.call_get_max_count();
+  }
+
+  public synchronized static long call_get_count() {
+    return pjsuaJNI.call_get_count();
+  }
+
+  public synchronized static int enum_calls(int[] ids, long[] count) {
+    return pjsuaJNI.enum_calls(ids, count);
+  }
+
+  public synchronized static int call_make_call(int acc_id, pj_str_t dst_uri, pjsua_call_setting opt, byte[] user_data, pjsua_msg_data msg_data, int[] p_call_id) {
+    return pjsuaJNI.call_make_call(acc_id, pj_str_t.getCPtr(dst_uri), dst_uri, pjsua_call_setting.getCPtr(opt), opt, user_data, pjsua_msg_data.getCPtr(msg_data), msg_data, p_call_id);
+  }
+
+  public synchronized static int call_is_active(int call_id) {
+    return pjsuaJNI.call_is_active(call_id);
+  }
+
+  public synchronized static int call_has_media(int call_id) {
+    return pjsuaJNI.call_has_media(call_id);
+  }
+
+  public synchronized static int call_get_conf_port(int call_id) {
+    return pjsuaJNI.call_get_conf_port(call_id);
+  }
+
+  public synchronized static int call_get_info(int call_id, pjsua_call_info info) {
+    return pjsuaJNI.call_get_info(call_id, pjsua_call_info.getCPtr(info), info);
+  }
+
+  public synchronized static SWIGTYPE_p_pjsip_dialog_cap_status call_remote_has_cap(int call_id, int htype, pj_str_t hname, pj_str_t token) {
+    return new SWIGTYPE_p_pjsip_dialog_cap_status(pjsuaJNI.call_remote_has_cap(call_id, htype, pj_str_t.getCPtr(hname), hname, pj_str_t.getCPtr(token), token), true);
+  }
+
+  public synchronized static int call_set_user_data(int call_id, byte[] user_data) {
+    return pjsuaJNI.call_set_user_data(call_id, user_data);
+  }
+
+  public synchronized static byte[] call_get_user_data(int call_id) {
+	return pjsuaJNI.call_get_user_data(call_id);
+}
+
+  public synchronized static int call_get_rem_nat_type(int call_id, int[] p_type) {
+    return pjsuaJNI.call_get_rem_nat_type(call_id, p_type);
+  }
+
+  public synchronized static int call_answer(int call_id, long code, pj_str_t reason, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_answer(call_id, code, pj_str_t.getCPtr(reason), reason, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_answer2(int call_id, pjsua_call_setting opt, long code, pj_str_t reason, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_answer2(call_id, pjsua_call_setting.getCPtr(opt), opt, code, pj_str_t.getCPtr(reason), reason, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_hangup(int call_id, long code, pj_str_t reason, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_hangup(call_id, code, pj_str_t.getCPtr(reason), reason, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_process_redirect(int call_id, pjsip_redirect_op cmd) {
+    return pjsuaJNI.call_process_redirect(call_id, cmd.swigValue());
+  }
+
+  public synchronized static int call_set_hold(int call_id, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_set_hold(call_id, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_set_hold2(int call_id, long options, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_set_hold2(call_id, options, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_reinvite(int call_id, long options, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_reinvite(call_id, options, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_reinvite2(int call_id, pjsua_call_setting opt, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_reinvite2(call_id, pjsua_call_setting.getCPtr(opt), opt, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_update(int call_id, long options, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_update(call_id, options, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_update2(int call_id, pjsua_call_setting opt, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_update2(call_id, pjsua_call_setting.getCPtr(opt), opt, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_xfer(int call_id, pj_str_t dest, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_xfer(call_id, pj_str_t.getCPtr(dest), dest, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_xfer_replaces(int call_id, int dest_call_id, long options, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_xfer_replaces(call_id, dest_call_id, options, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_dial_dtmf(int call_id, pj_str_t digits) {
+    return pjsuaJNI.call_dial_dtmf(call_id, pj_str_t.getCPtr(digits), digits);
+  }
+
+  public synchronized static int call_send_im(int call_id, pj_str_t mime_type, pj_str_t content, pjsua_msg_data msg_data, byte[] user_data) {
+    return pjsuaJNI.call_send_im(call_id, pj_str_t.getCPtr(mime_type), mime_type, pj_str_t.getCPtr(content), content, pjsua_msg_data.getCPtr(msg_data), msg_data, user_data);
+  }
+
+  public synchronized static int call_send_typing_ind(int call_id, int is_typing, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_send_typing_ind(call_id, is_typing, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static int call_send_request(int call_id, pj_str_t method, pjsua_msg_data msg_data) {
+    return pjsuaJNI.call_send_request(call_id, pj_str_t.getCPtr(method), method, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static void call_hangup_all() {
+    pjsuaJNI.call_hangup_all();
+  }
+
+  public synchronized static int call_dump(int call_id, int with_media, String buffer, long maxlen, String indent) {
+    return pjsuaJNI.call_dump__SWIG_0(call_id, with_media, buffer, maxlen, indent);
+  }
+
+  public synchronized static int call_get_vid_stream_idx(int call_id) {
+    return pjsuaJNI.call_get_vid_stream_idx(call_id);
+  }
+
+  public synchronized static int call_vid_stream_is_running(int call_id, int med_idx, pjmedia_dir dir) {
+    return pjsuaJNI.call_vid_stream_is_running(call_id, med_idx, dir.swigValue());
+  }
+
+  public synchronized static int call_set_vid_strm(int call_id, pjsua_call_vid_strm_op op, pjsua_call_vid_strm_op_param param) {
+    return pjsuaJNI.call_set_vid_strm(call_id, op.swigValue(), pjsua_call_vid_strm_op_param.getCPtr(param), param);
+  }
+
+  public synchronized static int call_get_stream_info(int call_id, long med_idx, pjsua_stream_info psi) {
+    return pjsuaJNI.call_get_stream_info(call_id, med_idx, pjsua_stream_info.getCPtr(psi), psi);
+  }
+
+  public synchronized static int call_get_stream_stat(int call_id, long med_idx, pjsua_stream_stat stat) {
+    return pjsuaJNI.call_get_stream_stat(call_id, med_idx, pjsua_stream_stat.getCPtr(stat), stat);
+  }
+
+  public synchronized static int call_get_med_transport_info(int call_id, long med_idx, SWIGTYPE_p_pjmedia_transport_info t) {
+    return pjsuaJNI.call_get_med_transport_info(call_id, med_idx, SWIGTYPE_p_pjmedia_transport_info.getCPtr(t));
+  }
+
+  public synchronized static void buddy_config_default(pjsua_buddy_config cfg) {
+    pjsuaJNI.buddy_config_default(pjsua_buddy_config.getCPtr(cfg), cfg);
+  }
+
+  public synchronized static long get_buddy_count() {
+    return pjsuaJNI.get_buddy_count();
+  }
+
+  public synchronized static int buddy_is_valid(int buddy_id) {
+    return pjsuaJNI.buddy_is_valid(buddy_id);
+  }
+
+  public synchronized static int enum_buddies(int[] ids, long[] count) {
+    return pjsuaJNI.enum_buddies(ids, count);
+  }
+
+  public synchronized static int buddy_find(pj_str_t uri) {
+    return pjsuaJNI.buddy_find(pj_str_t.getCPtr(uri), uri);
+  }
+
+  public synchronized static int buddy_get_info(int buddy_id, pjsua_buddy_info info) {
+    return pjsuaJNI.buddy_get_info(buddy_id, pjsua_buddy_info.getCPtr(info), info);
+  }
+
+  public synchronized static int buddy_set_user_data(int buddy_id, byte[] user_data) {
+    return pjsuaJNI.buddy_set_user_data(buddy_id, user_data);
+  }
+
+  public synchronized static byte[] buddy_get_user_data(int buddy_id) {
+	return pjsuaJNI.buddy_get_user_data(buddy_id);
+}
+
+  public synchronized static int buddy_add(pjsua_buddy_config buddy_cfg, int[] p_buddy_id) {
+    return pjsuaJNI.buddy_add(pjsua_buddy_config.getCPtr(buddy_cfg), buddy_cfg, p_buddy_id);
+  }
+
+  public synchronized static int buddy_del(int buddy_id) {
+    return pjsuaJNI.buddy_del(buddy_id);
+  }
+
+  public synchronized static int buddy_subscribe_pres(int buddy_id, int subscribe) {
+    return pjsuaJNI.buddy_subscribe_pres(buddy_id, subscribe);
+  }
+
+  public synchronized static int buddy_update_pres(int buddy_id) {
+    return pjsuaJNI.buddy_update_pres(buddy_id);
+  }
+
+  public synchronized static int pres_notify(int acc_id, SWIGTYPE_p_pjsua_srv_pres srv_pres, SWIGTYPE_p_pjsip_evsub_state state, pj_str_t state_str, pj_str_t reason, int with_body, pjsua_msg_data msg_data) {
+    return pjsuaJNI.pres_notify(acc_id, SWIGTYPE_p_pjsua_srv_pres.getCPtr(srv_pres), SWIGTYPE_p_pjsip_evsub_state.getCPtr(state), pj_str_t.getCPtr(state_str), state_str, pj_str_t.getCPtr(reason), reason, with_body, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static void pres_dump(int verbose) {
+    pjsuaJNI.pres_dump(verbose);
+  }
+
+  public static SWIGTYPE_p_pjsip_method getPjsip_message_method() {
+    return new SWIGTYPE_p_pjsip_method(pjsuaJNI.pjsip_message_method_get(), true);
+  }
+
+  public static SWIGTYPE_p_pjsip_method getPjsip_info_method() {
+    return new SWIGTYPE_p_pjsip_method(pjsuaJNI.pjsip_info_method_get(), true);
+  }
+
+  public synchronized static int im_send(int acc_id, pj_str_t to, pj_str_t mime_type, pj_str_t content, pjsua_msg_data msg_data, byte[] user_data) {
+    return pjsuaJNI.im_send(acc_id, pj_str_t.getCPtr(to), to, pj_str_t.getCPtr(mime_type), mime_type, pj_str_t.getCPtr(content), content, pjsua_msg_data.getCPtr(msg_data), msg_data, user_data);
+  }
+
+  public synchronized static int im_typing(int acc_id, pj_str_t to, int is_typing, pjsua_msg_data msg_data) {
+    return pjsuaJNI.im_typing(acc_id, pj_str_t.getCPtr(to), to, is_typing, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public synchronized static void media_config_default(pjsua_media_config cfg) {
+    pjsuaJNI.media_config_default(pjsua_media_config.getCPtr(cfg), cfg);
+  }
+
+  public synchronized static long conf_get_max_ports() {
+    return pjsuaJNI.conf_get_max_ports();
+  }
+
+  public synchronized static long conf_get_active_ports() {
+    return pjsuaJNI.conf_get_active_ports();
+  }
+
+  public synchronized static int enum_conf_ports(int[] id, long[] count) {
+    return pjsuaJNI.enum_conf_ports(id, count);
+  }
+
+  public synchronized static int conf_get_port_info(int port_id, pjsua_conf_port_info info) {
+    return pjsuaJNI.conf_get_port_info(port_id, pjsua_conf_port_info.getCPtr(info), info);
+  }
+
+  public synchronized static int conf_add_port(pj_pool_t pool, pjmedia_port port, int[] p_id) {
+    return pjsuaJNI.conf_add_port(pj_pool_t.getCPtr(pool), pool, pjmedia_port.getCPtr(port), port, p_id);
+  }
+
+  public synchronized static int conf_remove_port(int port_id) {
+    return pjsuaJNI.conf_remove_port(port_id);
+  }
+
+  public synchronized static int conf_connect(int source, int sink) {
+    return pjsuaJNI.conf_connect(source, sink);
+  }
+
+  public synchronized static int conf_disconnect(int source, int sink) {
+    return pjsuaJNI.conf_disconnect(source, sink);
+  }
+
+  public synchronized static int conf_adjust_tx_level(int slot, float level) {
+    return pjsuaJNI.conf_adjust_tx_level(slot, level);
+  }
+
+  public synchronized static int conf_adjust_rx_level(int slot, float level) {
+    return pjsuaJNI.conf_adjust_rx_level(slot, level);
+  }
+
+  public synchronized static int conf_get_signal_level(int slot, long[] tx_level, long[] rx_level) {
+    return pjsuaJNI.conf_get_signal_level(slot, tx_level, rx_level);
+  }
+
+  public synchronized static int player_create(pj_str_t filename, long options, int[] p_id) {
+    return pjsuaJNI.player_create(pj_str_t.getCPtr(filename), filename, options, p_id);
+  }
+
+  public synchronized static int playlist_create(pj_str_t[] file_names, long file_count, pj_str_t label, long options, int[] p_id) {
+    return pjsuaJNI.playlist_create(pj_str_t.cArrayUnwrap(file_names), file_count, pj_str_t.getCPtr(label), label, options, p_id);
+  }
+
+  public synchronized static int player_get_conf_port(int id) {
+    return pjsuaJNI.player_get_conf_port(id);
+  }
+
+  public synchronized static int player_get_port(int id, SWIGTYPE_p_p_pjmedia_port p_port) {
+    return pjsuaJNI.player_get_port(id, SWIGTYPE_p_p_pjmedia_port.getCPtr(p_port));
+  }
+
+  public synchronized static int player_get_info(int id, SWIGTYPE_p_pjmedia_wav_player_info info) {
+    return pjsuaJNI.player_get_info(id, SWIGTYPE_p_pjmedia_wav_player_info.getCPtr(info));
+  }
+
+  public synchronized static int player_get_pos(int id) {
+    return pjsuaJNI.player_get_pos(id);
+  }
+
+  public synchronized static int player_set_pos(int id, long samples) {
+    return pjsuaJNI.player_set_pos(id, samples);
+  }
+
+  public synchronized static int player_destroy(int id) {
+    return pjsuaJNI.player_destroy(id);
+  }
+
+  public synchronized static int recorder_create(pj_str_t filename, long enc_type, byte[] enc_param, int max_size, long options, int[] p_id) {
+    return pjsuaJNI.recorder_create(pj_str_t.getCPtr(filename), filename, enc_type, enc_param, max_size, options, p_id);
+  }
+
+  public synchronized static int recorder_get_conf_port(int id) {
+    return pjsuaJNI.recorder_get_conf_port(id);
+  }
+
+  public synchronized static int recorder_get_port(int id, SWIGTYPE_p_p_pjmedia_port p_port) {
+    return pjsuaJNI.recorder_get_port(id, SWIGTYPE_p_p_pjmedia_port.getCPtr(p_port));
+  }
+
+  public synchronized static int recorder_destroy(int id) {
+    return pjsuaJNI.recorder_destroy(id);
+  }
+
+  public synchronized static int enum_aud_devs(SWIGTYPE_p_pjmedia_aud_dev_info info, long[] count) {
+    return pjsuaJNI.enum_aud_devs(SWIGTYPE_p_pjmedia_aud_dev_info.getCPtr(info), count);
+  }
+
+  public synchronized static int enum_snd_devs(pjmedia_snd_dev_info info, long[] count) {
+    return pjsuaJNI.enum_snd_devs(pjmedia_snd_dev_info.getCPtr(info), info, count);
+  }
+
+  public synchronized static int get_snd_dev(int[] capture_dev, int[] playback_dev) {
+    return pjsuaJNI.get_snd_dev(capture_dev, playback_dev);
+  }
+
+  public synchronized static int set_snd_dev(int capture_dev, int playback_dev) {
+    return pjsuaJNI.set_snd_dev(capture_dev, playback_dev);
+  }
+
+  public synchronized static int set_null_snd_dev() {
+    return pjsuaJNI.set_null_snd_dev();
+  }
+
+  public synchronized static pjmedia_port set_no_snd_dev() {
+    long cPtr = pjsuaJNI.set_no_snd_dev();
+    return (cPtr == 0) ? null : new pjmedia_port(cPtr, false);
+  }
+
+  public synchronized static int set_ec(long tail_ms, long options) {
+    return pjsuaJNI.set_ec(tail_ms, options);
+  }
+
+  public synchronized static int get_ec_tail(SWIGTYPE_p_unsigned_int p_tail_ms) {
+    return pjsuaJNI.get_ec_tail(SWIGTYPE_p_unsigned_int.getCPtr(p_tail_ms));
+  }
+
+  public synchronized static int snd_is_active() {
+    return pjsuaJNI.snd_is_active();
+  }
+
+  public synchronized static int snd_set_setting(SWIGTYPE_p_pjmedia_aud_dev_cap cap, byte[] pval, int keep) {
+    return pjsuaJNI.snd_set_setting(SWIGTYPE_p_pjmedia_aud_dev_cap.getCPtr(cap), pval, keep);
+  }
+
+  public synchronized static int snd_get_setting(SWIGTYPE_p_pjmedia_aud_dev_cap cap, byte[] pval) {
+    return pjsuaJNI.snd_get_setting(SWIGTYPE_p_pjmedia_aud_dev_cap.getCPtr(cap), pval);
+  }
+
+  public synchronized static int enum_codecs(pjsua_codec_info id, long[] count) {
+    return pjsuaJNI.enum_codecs(pjsua_codec_info.getCPtr(id), id, count);
+  }
+
+  public synchronized static int codec_set_priority(pj_str_t codec_id, short priority) {
+    return pjsuaJNI.codec_set_priority(pj_str_t.getCPtr(codec_id), codec_id, priority);
+  }
+
+  public synchronized static int codec_get_param(pj_str_t codec_id, SWIGTYPE_p_pjmedia_codec_param param) {
+    return pjsuaJNI.codec_get_param(pj_str_t.getCPtr(codec_id), codec_id, SWIGTYPE_p_pjmedia_codec_param.getCPtr(param));
+  }
+
+  public synchronized static int codec_set_param(pj_str_t codec_id, SWIGTYPE_p_pjmedia_codec_param param) {
+    return pjsuaJNI.codec_set_param(pj_str_t.getCPtr(codec_id), codec_id, SWIGTYPE_p_pjmedia_codec_param.getCPtr(param));
+  }
+
+  public synchronized static long vid_dev_count() {
+    return pjsuaJNI.vid_dev_count();
+  }
+
+  public synchronized static int vid_dev_get_info(SWIGTYPE_p_pjmedia_vid_dev_index id, SWIGTYPE_p_pjmedia_vid_dev_info vdi) {
+    return pjsuaJNI.vid_dev_get_info(SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(id), SWIGTYPE_p_pjmedia_vid_dev_info.getCPtr(vdi));
+  }
+
+  public synchronized static int vid_enum_devs(SWIGTYPE_p_pjmedia_vid_dev_info info, long[] count) {
+    return pjsuaJNI.vid_enum_devs(SWIGTYPE_p_pjmedia_vid_dev_info.getCPtr(info), count);
+  }
+
+  public synchronized static void vid_preview_param_default(pjsua_vid_preview_param p) {
+    pjsuaJNI.vid_preview_param_default(pjsua_vid_preview_param.getCPtr(p), p);
+  }
+
+  public synchronized static int vid_preview_has_native(SWIGTYPE_p_pjmedia_vid_dev_index id) {
+    return pjsuaJNI.vid_preview_has_native(SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(id));
+  }
+
+  public synchronized static int vid_preview_start(SWIGTYPE_p_pjmedia_vid_dev_index id, pjsua_vid_preview_param p) {
+    return pjsuaJNI.vid_preview_start(SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(id), pjsua_vid_preview_param.getCPtr(p), p);
+  }
+
+  public synchronized static int vid_preview_get_win(SWIGTYPE_p_pjmedia_vid_dev_index id) {
+    return pjsuaJNI.vid_preview_get_win(SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(id));
+  }
+
+  public synchronized static int vid_preview_stop(SWIGTYPE_p_pjmedia_vid_dev_index id) {
+    return pjsuaJNI.vid_preview_stop(SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(id));
+  }
+
+  public synchronized static int vid_enum_wins(int[] wids, long[] count) {
+    return pjsuaJNI.vid_enum_wins(wids, count);
+  }
+
+  public synchronized static int vid_win_get_info(int wid, pjsua_vid_win_info wi) {
+    return pjsuaJNI.vid_win_get_info(wid, pjsua_vid_win_info.getCPtr(wi), wi);
+  }
+
+  public synchronized static int vid_win_set_show(int wid, int show) {
+    return pjsuaJNI.vid_win_set_show(wid, show);
+  }
+
+  public synchronized static int vid_win_set_pos(int wid, SWIGTYPE_p_pjmedia_coord pos) {
+    return pjsuaJNI.vid_win_set_pos(wid, SWIGTYPE_p_pjmedia_coord.getCPtr(pos));
+  }
+
+  public synchronized static int vid_win_set_size(int wid, SWIGTYPE_p_pjmedia_rect_size size) {
+    return pjsuaJNI.vid_win_set_size(wid, SWIGTYPE_p_pjmedia_rect_size.getCPtr(size));
+  }
+
+  public synchronized static int vid_win_rotate(int wid, int angle) {
+    return pjsuaJNI.vid_win_rotate(wid, angle);
+  }
+
+  public synchronized static int vid_enum_codecs(pjsua_codec_info id, long[] count) {
+    return pjsuaJNI.vid_enum_codecs(pjsua_codec_info.getCPtr(id), id, count);
+  }
+
+  public synchronized static int vid_codec_set_priority(pj_str_t codec_id, short priority) {
+    return pjsuaJNI.vid_codec_set_priority(pj_str_t.getCPtr(codec_id), codec_id, priority);
+  }
+
+  public synchronized static int vid_codec_get_param(pj_str_t codec_id, SWIGTYPE_p_pjmedia_vid_codec_param param) {
+    return pjsuaJNI.vid_codec_get_param(pj_str_t.getCPtr(codec_id), codec_id, SWIGTYPE_p_pjmedia_vid_codec_param.getCPtr(param));
+  }
+
+  public synchronized static int vid_codec_set_param(pj_str_t codec_id, SWIGTYPE_p_pjmedia_vid_codec_param param) {
+    return pjsuaJNI.vid_codec_set_param(pj_str_t.getCPtr(codec_id), codec_id, SWIGTYPE_p_pjmedia_vid_codec_param.getCPtr(param));
+  }
+
+  public static int send_dtmf_info(int current_call, pj_str_t digits) {
+    return pjsuaJNI.send_dtmf_info(current_call, pj_str_t.getCPtr(digits), digits);
+  }
+
+  public static pj_str_t call_dump(int call_id, int with_media, String indent) {
+    return new pj_str_t(pjsuaJNI.call_dump__SWIG_1(call_id, with_media, indent), true);
+  }
+
+  public static pj_str_t call_secure_media_info(int call_id) {
+    return new pj_str_t(pjsuaJNI.call_secure_media_info(call_id), true);
+  }
+
+  public static int call_secure_sig_level(int call_id) {
+    return pjsuaJNI.call_secure_sig_level(call_id);
+  }
+
+  public static pj_str_t get_error_message(int status) {
+    return new pj_str_t(pjsuaJNI.get_error_message(status), true);
+  }
+
+  public static int get_event_status_code(pjsip_event e) {
+    return pjsuaJNI.get_event_status_code(pjsip_event.getCPtr(e), e);
+  }
+
+  public static int get_event_reason_code(pjsip_event e) {
+    return pjsuaJNI.get_event_reason_code(pjsip_event.getCPtr(e), e);
+  }
+
+  public static void csipsimple_config_default(csipsimple_config css_cfg) {
+    pjsuaJNI.csipsimple_config_default(csipsimple_config.getCPtr(css_cfg), css_cfg);
+  }
+
+  public static void csipsimple_acc_config_default(csipsimple_acc_config css_acc_cfg) {
+    pjsuaJNI.csipsimple_acc_config_default(csipsimple_acc_config.getCPtr(css_acc_cfg), css_acc_cfg);
+  }
+
+  public static int csipsimple_init(pjsua_config ua_cfg, pjsua_logging_config log_cfg, pjsua_media_config media_cfg, csipsimple_config css_cfg, Object context) {
+    return pjsuaJNI.csipsimple_init(pjsua_config.getCPtr(ua_cfg), ua_cfg, pjsua_logging_config.getCPtr(log_cfg), log_cfg, pjsua_media_config.getCPtr(media_cfg), media_cfg, csipsimple_config.getCPtr(css_cfg), css_cfg, context);
+  }
+
+  public static int csipsimple_destroy(long flags) {
+    return pjsuaJNI.csipsimple_destroy(flags);
+  }
+
+  public static int csipsimple_set_acc_user_data(int acc_id, csipsimple_acc_config css_acc_cfg) {
+    return pjsuaJNI.csipsimple_set_acc_user_data(acc_id, csipsimple_acc_config.getCPtr(css_acc_cfg), css_acc_cfg);
+  }
+
+  public static int csipsimple_init_acc_msg_data(pj_pool_t pool, int acc_id, pjsua_msg_data msg_data) {
+    return pjsuaJNI.csipsimple_init_acc_msg_data(pj_pool_t.getCPtr(pool), pool, acc_id, pjsua_msg_data.getCPtr(msg_data), msg_data);
+  }
+
+  public static int csipsimple_msg_data_add_string_hdr(pj_pool_t pool, pjsua_msg_data msg_data, pj_str_t hdr_name, pj_str_t hdr_value) {
+    return pjsuaJNI.csipsimple_msg_data_add_string_hdr(pj_pool_t.getCPtr(pool), pool, pjsua_msg_data.getCPtr(msg_data), msg_data, pj_str_t.getCPtr(hdr_name), hdr_name, pj_str_t.getCPtr(hdr_value), hdr_value);
+  }
+
+  public static int pj_timer_fire(int entry_id) {
+    return pjsuaJNI.pj_timer_fire(entry_id);
+  }
+
+  public static int update_transport(pj_str_t new_ip_addr) {
+    return pjsuaJNI.update_transport(pj_str_t.getCPtr(new_ip_addr), new_ip_addr);
+  }
+
+  public static int vid_set_android_renderer(int call_id, Object window) {
+    return pjsuaJNI.vid_set_android_renderer(call_id, window);
+  }
+
+  public static int vid_set_android_capturer(Object window) {
+    return pjsuaJNI.vid_set_android_capturer(window);
+  }
+
+  public static int set_turn_credentials(pj_str_t username, pj_str_t password, pj_str_t realm, SWIGTYPE_p_pj_stun_auth_cred turn_auth_cred) {
+    return pjsuaJNI.set_turn_credentials(pj_str_t.getCPtr(username), username, pj_str_t.getCPtr(password), password, pj_str_t.getCPtr(realm), realm, SWIGTYPE_p_pj_stun_auth_cred.getCPtr(turn_auth_cred));
+  }
+
+  public static pj_str_t get_rx_data_header(pj_str_t name, SWIGTYPE_p_pjsip_rx_data data) {
+    return new pj_str_t(pjsuaJNI.get_rx_data_header(pj_str_t.getCPtr(name), name, SWIGTYPE_p_pjsip_rx_data.getCPtr(data)), true);
+  }
+
+  public static void css_on_call_state(int call_id, pjsip_event e) {
+    pjsuaJNI.css_on_call_state(call_id, pjsip_event.getCPtr(e), e);
+  }
+
+  public static void css_on_call_media_state(int call_id) {
+    pjsuaJNI.css_on_call_media_state(call_id);
+  }
+
+  public static void jzrtp_SASVerified(int call_id) {
+    pjsuaJNI.jzrtp_SASVerified(call_id);
+  }
+
+  public static void jzrtp_SASRevoked(int call_id) {
+    pjsuaJNI.jzrtp_SASRevoked(call_id);
+  }
+
+  public static zrtp_state_info jzrtp_getInfoFromCall(int call_id) {
+    return new zrtp_state_info(pjsuaJNI.jzrtp_getInfoFromCall(call_id), true);
+  }
+
+  public static int codecs_get_nbr() {
+    return pjsuaJNI.codecs_get_nbr();
+  }
+
+  public static pj_str_t codecs_get_id(int codec_id) {
+    return new pj_str_t(pjsuaJNI.codecs_get_id(codec_id), true);
+  }
+
+  public static int codecs_vid_get_nbr() {
+    return pjsuaJNI.codecs_vid_get_nbr();
+  }
+
+  public static pj_str_t codecs_vid_get_id(int codec_id) {
+    return new pj_str_t(pjsuaJNI.codecs_vid_get_id(codec_id), true);
+  }
+
+  public static int codec_set_frames_per_packet(pj_str_t codec_id, int frames_per_packet) {
+    return pjsuaJNI.codec_set_frames_per_packet(pj_str_t.getCPtr(codec_id), codec_id, frames_per_packet);
+  }
+
+  public static int codec_h264_set_profile(long profile_id, long level_id, long width, long height, long fps, long avg_kbps, long max_kbps) {
+    return pjsuaJNI.codec_h264_set_profile(profile_id, level_id, width, height, fps, avg_kbps, max_kbps);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_100rel_use.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_100rel_use.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_100rel_use.java	(working copy)
@@ -0,0 +1,53 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_100rel_use {
+  PJSUA_100REL_NOT_USED,
+  PJSUA_100REL_MANDATORY,
+  PJSUA_100REL_OPTIONAL;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_100rel_use swigToEnum(int swigValue) {
+    pjsua_100rel_use[] swigValues = pjsua_100rel_use.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_100rel_use swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_100rel_use.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_100rel_use() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_100rel_use(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_100rel_use(pjsua_100rel_use swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_acc_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_acc_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_acc_config.java	(working copy)
@@ -0,0 +1,553 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_acc_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_acc_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_acc_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_acc_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setUser_data(byte[] value) {
+    pjsuaJNI.pjsua_acc_config_user_data_set(swigCPtr, this, value);
+  }
+
+  public byte[] getUser_data() {
+	return pjsuaJNI.pjsua_acc_config_user_data_get(swigCPtr, this);
+}
+
+  public void setPriority(int value) {
+    pjsuaJNI.pjsua_acc_config_priority_set(swigCPtr, this, value);
+  }
+
+  public int getPriority() {
+    return pjsuaJNI.pjsua_acc_config_priority_get(swigCPtr, this);
+  }
+
+  public void setId(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_id_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getId() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_id_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setReg_uri(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_reg_uri_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getReg_uri() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_reg_uri_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setReg_hdr_list(SWIGTYPE_p_pjsip_hdr value) {
+    pjsuaJNI.pjsua_acc_config_reg_hdr_list_set(swigCPtr, this, SWIGTYPE_p_pjsip_hdr.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_hdr getReg_hdr_list() {
+    return new SWIGTYPE_p_pjsip_hdr(pjsuaJNI.pjsua_acc_config_reg_hdr_list_get(swigCPtr, this), true);
+  }
+
+  public void setSub_hdr_list(SWIGTYPE_p_pjsip_hdr value) {
+    pjsuaJNI.pjsua_acc_config_sub_hdr_list_set(swigCPtr, this, SWIGTYPE_p_pjsip_hdr.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_hdr getSub_hdr_list() {
+    return new SWIGTYPE_p_pjsip_hdr(pjsuaJNI.pjsua_acc_config_sub_hdr_list_get(swigCPtr, this), true);
+  }
+
+  public void setMwi_enabled(int value) {
+    pjsuaJNI.pjsua_acc_config_mwi_enabled_set(swigCPtr, this, value);
+  }
+
+  public int getMwi_enabled() {
+    return pjsuaJNI.pjsua_acc_config_mwi_enabled_get(swigCPtr, this);
+  }
+
+  public void setMwi_expires(long value) {
+    pjsuaJNI.pjsua_acc_config_mwi_expires_set(swigCPtr, this, value);
+  }
+
+  public long getMwi_expires() {
+    return pjsuaJNI.pjsua_acc_config_mwi_expires_get(swigCPtr, this);
+  }
+
+  public void setPublish_enabled(int value) {
+    pjsuaJNI.pjsua_acc_config_publish_enabled_set(swigCPtr, this, value);
+  }
+
+  public int getPublish_enabled() {
+    return pjsuaJNI.pjsua_acc_config_publish_enabled_get(swigCPtr, this);
+  }
+
+  public void setPublish_opt(SWIGTYPE_p_pjsip_publishc_opt value) {
+    pjsuaJNI.pjsua_acc_config_publish_opt_set(swigCPtr, this, SWIGTYPE_p_pjsip_publishc_opt.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_publishc_opt getPublish_opt() {
+    return new SWIGTYPE_p_pjsip_publishc_opt(pjsuaJNI.pjsua_acc_config_publish_opt_get(swigCPtr, this), true);
+  }
+
+  public void setUnpublish_max_wait_time_msec(long value) {
+    pjsuaJNI.pjsua_acc_config_unpublish_max_wait_time_msec_set(swigCPtr, this, value);
+  }
+
+  public long getUnpublish_max_wait_time_msec() {
+    return pjsuaJNI.pjsua_acc_config_unpublish_max_wait_time_msec_get(swigCPtr, this);
+  }
+
+  public void setAuth_pref(pjsip_auth_clt_pref value) {
+    pjsuaJNI.pjsua_acc_config_auth_pref_set(swigCPtr, this, pjsip_auth_clt_pref.getCPtr(value), value);
+  }
+
+  public pjsip_auth_clt_pref getAuth_pref() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_auth_pref_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsip_auth_clt_pref(cPtr, false);
+  }
+
+  public void setPidf_tuple_id(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_pidf_tuple_id_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getPidf_tuple_id() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_pidf_tuple_id_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setForce_contact(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_force_contact_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getForce_contact() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_force_contact_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setContact_params(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_contact_params_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getContact_params() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_contact_params_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setContact_uri_params(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_contact_uri_params_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getContact_uri_params() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_contact_uri_params_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setRequire_100rel(pjsua_100rel_use value) {
+    pjsuaJNI.pjsua_acc_config_require_100rel_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_100rel_use getRequire_100rel() {
+    return pjsua_100rel_use.swigToEnum(pjsuaJNI.pjsua_acc_config_require_100rel_get(swigCPtr, this));
+  }
+
+  public void setUse_timer(pjsua_sip_timer_use value) {
+    pjsuaJNI.pjsua_acc_config_use_timer_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_sip_timer_use getUse_timer() {
+    return pjsua_sip_timer_use.swigToEnum(pjsuaJNI.pjsua_acc_config_use_timer_get(swigCPtr, this));
+  }
+
+  public void setTimer_setting(pjsip_timer_setting value) {
+    pjsuaJNI.pjsua_acc_config_timer_setting_set(swigCPtr, this, pjsip_timer_setting.getCPtr(value), value);
+  }
+
+  public pjsip_timer_setting getTimer_setting() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_timer_setting_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsip_timer_setting(cPtr, false);
+  }
+
+  public void setProxy_cnt(long value) {
+    pjsuaJNI.pjsua_acc_config_proxy_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getProxy_cnt() {
+    return pjsuaJNI.pjsua_acc_config_proxy_cnt_get(swigCPtr, this);
+  }
+
+  public void setProxy(pj_str_t[] value) {
+    pjsuaJNI.pjsua_acc_config_proxy_set(swigCPtr, this, pj_str_t.cArrayUnwrap(value));
+  }
+
+  public pj_str_t[] getProxy() {
+    return pj_str_t.cArrayWrap(pjsuaJNI.pjsua_acc_config_proxy_get(swigCPtr, this), false);
+  }
+
+  public void setLock_codec(long value) {
+    pjsuaJNI.pjsua_acc_config_lock_codec_set(swigCPtr, this, value);
+  }
+
+  public long getLock_codec() {
+    return pjsuaJNI.pjsua_acc_config_lock_codec_get(swigCPtr, this);
+  }
+
+  public void setReg_timeout(long value) {
+    pjsuaJNI.pjsua_acc_config_reg_timeout_set(swigCPtr, this, value);
+  }
+
+  public long getReg_timeout() {
+    return pjsuaJNI.pjsua_acc_config_reg_timeout_get(swigCPtr, this);
+  }
+
+  public void setReg_delay_before_refresh(long value) {
+    pjsuaJNI.pjsua_acc_config_reg_delay_before_refresh_set(swigCPtr, this, value);
+  }
+
+  public long getReg_delay_before_refresh() {
+    return pjsuaJNI.pjsua_acc_config_reg_delay_before_refresh_get(swigCPtr, this);
+  }
+
+  public void setUnreg_timeout(long value) {
+    pjsuaJNI.pjsua_acc_config_unreg_timeout_set(swigCPtr, this, value);
+  }
+
+  public long getUnreg_timeout() {
+    return pjsuaJNI.pjsua_acc_config_unreg_timeout_get(swigCPtr, this);
+  }
+
+  public void setCred_count(long value) {
+    pjsuaJNI.pjsua_acc_config_cred_count_set(swigCPtr, this, value);
+  }
+
+  public long getCred_count() {
+    return pjsuaJNI.pjsua_acc_config_cred_count_get(swigCPtr, this);
+  }
+
+  public void setCred_info(pjsip_cred_info value) {
+    pjsuaJNI.pjsua_acc_config_cred_info_set(swigCPtr, this, pjsip_cred_info.getCPtr(value), value);
+  }
+
+  public pjsip_cred_info getCred_info() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_cred_info_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsip_cred_info(cPtr, false);
+  }
+
+  public void setTransport_id(int value) {
+    pjsuaJNI.pjsua_acc_config_transport_id_set(swigCPtr, this, value);
+  }
+
+  public int getTransport_id() {
+    return pjsuaJNI.pjsua_acc_config_transport_id_get(swigCPtr, this);
+  }
+
+  public void setAllow_contact_rewrite(int value) {
+    pjsuaJNI.pjsua_acc_config_allow_contact_rewrite_set(swigCPtr, this, value);
+  }
+
+  public int getAllow_contact_rewrite() {
+    return pjsuaJNI.pjsua_acc_config_allow_contact_rewrite_get(swigCPtr, this);
+  }
+
+  public void setContact_rewrite_method(int value) {
+    pjsuaJNI.pjsua_acc_config_contact_rewrite_method_set(swigCPtr, this, value);
+  }
+
+  public int getContact_rewrite_method() {
+    return pjsuaJNI.pjsua_acc_config_contact_rewrite_method_get(swigCPtr, this);
+  }
+
+  public void setContact_use_src_port(int value) {
+    pjsuaJNI.pjsua_acc_config_contact_use_src_port_set(swigCPtr, this, value);
+  }
+
+  public int getContact_use_src_port() {
+    return pjsuaJNI.pjsua_acc_config_contact_use_src_port_get(swigCPtr, this);
+  }
+
+  public void setAllow_via_rewrite(int value) {
+    pjsuaJNI.pjsua_acc_config_allow_via_rewrite_set(swigCPtr, this, value);
+  }
+
+  public int getAllow_via_rewrite() {
+    return pjsuaJNI.pjsua_acc_config_allow_via_rewrite_get(swigCPtr, this);
+  }
+
+  public void setAllow_sdp_nat_rewrite(int value) {
+    pjsuaJNI.pjsua_acc_config_allow_sdp_nat_rewrite_set(swigCPtr, this, value);
+  }
+
+  public int getAllow_sdp_nat_rewrite() {
+    return pjsuaJNI.pjsua_acc_config_allow_sdp_nat_rewrite_get(swigCPtr, this);
+  }
+
+  public void setUse_rfc5626(long value) {
+    pjsuaJNI.pjsua_acc_config_use_rfc5626_set(swigCPtr, this, value);
+  }
+
+  public long getUse_rfc5626() {
+    return pjsuaJNI.pjsua_acc_config_use_rfc5626_get(swigCPtr, this);
+  }
+
+  public void setRfc5626_instance_id(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_rfc5626_instance_id_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getRfc5626_instance_id() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_rfc5626_instance_id_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setRfc5626_reg_id(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_rfc5626_reg_id_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getRfc5626_reg_id() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_rfc5626_reg_id_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setKa_interval(long value) {
+    pjsuaJNI.pjsua_acc_config_ka_interval_set(swigCPtr, this, value);
+  }
+
+  public long getKa_interval() {
+    return pjsuaJNI.pjsua_acc_config_ka_interval_get(swigCPtr, this);
+  }
+
+  public void setKa_data(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_config_ka_data_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getKa_data() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_ka_data_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setVid_in_auto_show(int value) {
+    pjsuaJNI.pjsua_acc_config_vid_in_auto_show_set(swigCPtr, this, value);
+  }
+
+  public int getVid_in_auto_show() {
+    return pjsuaJNI.pjsua_acc_config_vid_in_auto_show_get(swigCPtr, this);
+  }
+
+  public void setVid_out_auto_transmit(int value) {
+    pjsuaJNI.pjsua_acc_config_vid_out_auto_transmit_set(swigCPtr, this, value);
+  }
+
+  public int getVid_out_auto_transmit() {
+    return pjsuaJNI.pjsua_acc_config_vid_out_auto_transmit_get(swigCPtr, this);
+  }
+
+  public void setVid_wnd_flags(long value) {
+    pjsuaJNI.pjsua_acc_config_vid_wnd_flags_set(swigCPtr, this, value);
+  }
+
+  public long getVid_wnd_flags() {
+    return pjsuaJNI.pjsua_acc_config_vid_wnd_flags_get(swigCPtr, this);
+  }
+
+  public void setVid_cap_dev(SWIGTYPE_p_pjmedia_vid_dev_index value) {
+    pjsuaJNI.pjsua_acc_config_vid_cap_dev_set(swigCPtr, this, SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_vid_dev_index getVid_cap_dev() {
+    return new SWIGTYPE_p_pjmedia_vid_dev_index(pjsuaJNI.pjsua_acc_config_vid_cap_dev_get(swigCPtr, this), true);
+  }
+
+  public void setVid_rend_dev(SWIGTYPE_p_pjmedia_vid_dev_index value) {
+    pjsuaJNI.pjsua_acc_config_vid_rend_dev_set(swigCPtr, this, SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_vid_dev_index getVid_rend_dev() {
+    return new SWIGTYPE_p_pjmedia_vid_dev_index(pjsuaJNI.pjsua_acc_config_vid_rend_dev_get(swigCPtr, this), true);
+  }
+
+  public void setVid_stream_rc_cfg(SWIGTYPE_p_pjmedia_vid_stream_rc_config value) {
+    pjsuaJNI.pjsua_acc_config_vid_stream_rc_cfg_set(swigCPtr, this, SWIGTYPE_p_pjmedia_vid_stream_rc_config.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_vid_stream_rc_config getVid_stream_rc_cfg() {
+    return new SWIGTYPE_p_pjmedia_vid_stream_rc_config(pjsuaJNI.pjsua_acc_config_vid_stream_rc_cfg_get(swigCPtr, this), true);
+  }
+
+  public void setRtp_cfg(pjsua_transport_config value) {
+    pjsuaJNI.pjsua_acc_config_rtp_cfg_set(swigCPtr, this, pjsua_transport_config.getCPtr(value), value);
+  }
+
+  public pjsua_transport_config getRtp_cfg() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_rtp_cfg_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsua_transport_config(cPtr, false);
+  }
+
+  public void setIpv6_media_use(pjsua_ipv6_use value) {
+    pjsuaJNI.pjsua_acc_config_ipv6_media_use_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_ipv6_use getIpv6_media_use() {
+    return pjsua_ipv6_use.swigToEnum(pjsuaJNI.pjsua_acc_config_ipv6_media_use_get(swigCPtr, this));
+  }
+
+  public void setSip_stun_use(pjsua_stun_use value) {
+    pjsuaJNI.pjsua_acc_config_sip_stun_use_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_stun_use getSip_stun_use() {
+    return pjsua_stun_use.swigToEnum(pjsuaJNI.pjsua_acc_config_sip_stun_use_get(swigCPtr, this));
+  }
+
+  public void setMedia_stun_use(pjsua_stun_use value) {
+    pjsuaJNI.pjsua_acc_config_media_stun_use_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_stun_use getMedia_stun_use() {
+    return pjsua_stun_use.swigToEnum(pjsuaJNI.pjsua_acc_config_media_stun_use_get(swigCPtr, this));
+  }
+
+  public void setIce_cfg_use(pjsua_ice_config_use value) {
+    pjsuaJNI.pjsua_acc_config_ice_cfg_use_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_ice_config_use getIce_cfg_use() {
+    return pjsua_ice_config_use.swigToEnum(pjsuaJNI.pjsua_acc_config_ice_cfg_use_get(swigCPtr, this));
+  }
+
+  public void setIce_cfg(pjsua_ice_config value) {
+    pjsuaJNI.pjsua_acc_config_ice_cfg_set(swigCPtr, this, pjsua_ice_config.getCPtr(value), value);
+  }
+
+  public pjsua_ice_config getIce_cfg() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_ice_cfg_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsua_ice_config(cPtr, false);
+  }
+
+  public void setTurn_cfg_use(pjsua_turn_config_use value) {
+    pjsuaJNI.pjsua_acc_config_turn_cfg_use_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_turn_config_use getTurn_cfg_use() {
+    return pjsua_turn_config_use.swigToEnum(pjsuaJNI.pjsua_acc_config_turn_cfg_use_get(swigCPtr, this));
+  }
+
+  public void setTurn_cfg(pjsua_turn_config value) {
+    pjsuaJNI.pjsua_acc_config_turn_cfg_set(swigCPtr, this, pjsua_turn_config.getCPtr(value), value);
+  }
+
+  public pjsua_turn_config getTurn_cfg() {
+    long cPtr = pjsuaJNI.pjsua_acc_config_turn_cfg_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsua_turn_config(cPtr, false);
+  }
+
+  public void setUse_srtp(pjmedia_srtp_use value) {
+    pjsuaJNI.pjsua_acc_config_use_srtp_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjmedia_srtp_use getUse_srtp() {
+    return pjmedia_srtp_use.swigToEnum(pjsuaJNI.pjsua_acc_config_use_srtp_get(swigCPtr, this));
+  }
+
+  public void setSrtp_secure_signaling(int value) {
+    pjsuaJNI.pjsua_acc_config_srtp_secure_signaling_set(swigCPtr, this, value);
+  }
+
+  public int getSrtp_secure_signaling() {
+    return pjsuaJNI.pjsua_acc_config_srtp_secure_signaling_get(swigCPtr, this);
+  }
+
+  public void setSrtp_optional_dup_offer(int value) {
+    pjsuaJNI.pjsua_acc_config_srtp_optional_dup_offer_set(swigCPtr, this, value);
+  }
+
+  public int getSrtp_optional_dup_offer() {
+    return pjsuaJNI.pjsua_acc_config_srtp_optional_dup_offer_get(swigCPtr, this);
+  }
+
+  public void setReg_retry_interval(long value) {
+    pjsuaJNI.pjsua_acc_config_reg_retry_interval_set(swigCPtr, this, value);
+  }
+
+  public long getReg_retry_interval() {
+    return pjsuaJNI.pjsua_acc_config_reg_retry_interval_get(swigCPtr, this);
+  }
+
+  public void setReg_first_retry_interval(long value) {
+    pjsuaJNI.pjsua_acc_config_reg_first_retry_interval_set(swigCPtr, this, value);
+  }
+
+  public long getReg_first_retry_interval() {
+    return pjsuaJNI.pjsua_acc_config_reg_first_retry_interval_get(swigCPtr, this);
+  }
+
+  public void setReg_retry_random_interval(long value) {
+    pjsuaJNI.pjsua_acc_config_reg_retry_random_interval_set(swigCPtr, this, value);
+  }
+
+  public long getReg_retry_random_interval() {
+    return pjsuaJNI.pjsua_acc_config_reg_retry_random_interval_get(swigCPtr, this);
+  }
+
+  public void setDrop_calls_on_reg_fail(int value) {
+    pjsuaJNI.pjsua_acc_config_drop_calls_on_reg_fail_set(swigCPtr, this, value);
+  }
+
+  public int getDrop_calls_on_reg_fail() {
+    return pjsuaJNI.pjsua_acc_config_drop_calls_on_reg_fail_get(swigCPtr, this);
+  }
+
+  public void setReg_use_proxy(long value) {
+    pjsuaJNI.pjsua_acc_config_reg_use_proxy_set(swigCPtr, this, value);
+  }
+
+  public long getReg_use_proxy() {
+    return pjsuaJNI.pjsua_acc_config_reg_use_proxy_get(swigCPtr, this);
+  }
+
+  public void setCall_hold_type(pjsua_call_hold_type value) {
+    pjsuaJNI.pjsua_acc_config_call_hold_type_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_call_hold_type getCall_hold_type() {
+    return pjsua_call_hold_type.swigToEnum(pjsuaJNI.pjsua_acc_config_call_hold_type_get(swigCPtr, this));
+  }
+
+  public void setRegister_on_acc_add(int value) {
+    pjsuaJNI.pjsua_acc_config_register_on_acc_add_set(swigCPtr, this, value);
+  }
+
+  public int getRegister_on_acc_add() {
+    return pjsuaJNI.pjsua_acc_config_register_on_acc_add_get(swigCPtr, this);
+  }
+
+  public pjsua_acc_config() {
+    this(pjsuaJNI.new_pjsua_acc_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_acc_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_acc_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_acc_info.java	(working copy)
@@ -0,0 +1,142 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_acc_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_acc_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_acc_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_acc_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setId(int value) {
+    pjsuaJNI.pjsua_acc_info_id_set(swigCPtr, this, value);
+  }
+
+  public int getId() {
+    return pjsuaJNI.pjsua_acc_info_id_get(swigCPtr, this);
+  }
+
+  public void setIs_default(int value) {
+    pjsuaJNI.pjsua_acc_info_is_default_set(swigCPtr, this, value);
+  }
+
+  public int getIs_default() {
+    return pjsuaJNI.pjsua_acc_info_is_default_get(swigCPtr, this);
+  }
+
+  public void setAcc_uri(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_info_acc_uri_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getAcc_uri() {
+    long cPtr = pjsuaJNI.pjsua_acc_info_acc_uri_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setHas_registration(int value) {
+    pjsuaJNI.pjsua_acc_info_has_registration_set(swigCPtr, this, value);
+  }
+
+  public int getHas_registration() {
+    return pjsuaJNI.pjsua_acc_info_has_registration_get(swigCPtr, this);
+  }
+
+  public void setExpires(int value) {
+    pjsuaJNI.pjsua_acc_info_expires_set(swigCPtr, this, value);
+  }
+
+  public int getExpires() {
+    return pjsuaJNI.pjsua_acc_info_expires_get(swigCPtr, this);
+  }
+
+  public void setStatus(pjsip_status_code value) {
+    pjsuaJNI.pjsua_acc_info_status_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsip_status_code getStatus() {
+    return pjsip_status_code.swigToEnum(pjsuaJNI.pjsua_acc_info_status_get(swigCPtr, this));
+  }
+
+  public void setReg_last_err(int value) {
+    pjsuaJNI.pjsua_acc_info_reg_last_err_set(swigCPtr, this, value);
+  }
+
+  public int getReg_last_err() {
+    return pjsuaJNI.pjsua_acc_info_reg_last_err_get(swigCPtr, this);
+  }
+
+  public void setStatus_text(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_info_status_text_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getStatus_text() {
+    long cPtr = pjsuaJNI.pjsua_acc_info_status_text_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setOnline_status(int value) {
+    pjsuaJNI.pjsua_acc_info_online_status_set(swigCPtr, this, value);
+  }
+
+  public int getOnline_status() {
+    return pjsuaJNI.pjsua_acc_info_online_status_get(swigCPtr, this);
+  }
+
+  public void setOnline_status_text(pj_str_t value) {
+    pjsuaJNI.pjsua_acc_info_online_status_text_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getOnline_status_text() {
+    long cPtr = pjsuaJNI.pjsua_acc_info_online_status_text_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setRpid(pjrpid_element value) {
+    pjsuaJNI.pjsua_acc_info_rpid_set(swigCPtr, this, pjrpid_element.getCPtr(value), value);
+  }
+
+  public pjrpid_element getRpid() {
+    long cPtr = pjsuaJNI.pjsua_acc_info_rpid_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjrpid_element(cPtr, false);
+  }
+
+  public void setBuf_(String value) {
+    pjsuaJNI.pjsua_acc_info_buf__set(swigCPtr, this, value);
+  }
+
+  public String getBuf_() {
+    return pjsuaJNI.pjsua_acc_info_buf__get(swigCPtr, this);
+  }
+
+  public pjsua_acc_info() {
+    this(pjsuaJNI.new_pjsua_acc_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_config.java	(working copy)
@@ -0,0 +1,67 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_buddy_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_buddy_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_buddy_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_buddy_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setUri(pj_str_t value) {
+    pjsuaJNI.pjsua_buddy_config_uri_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getUri() {
+    long cPtr = pjsuaJNI.pjsua_buddy_config_uri_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setSubscribe(int value) {
+    pjsuaJNI.pjsua_buddy_config_subscribe_set(swigCPtr, this, value);
+  }
+
+  public int getSubscribe() {
+    return pjsuaJNI.pjsua_buddy_config_subscribe_get(swigCPtr, this);
+  }
+
+  public void setUser_data(byte[] value) {
+    pjsuaJNI.pjsua_buddy_config_user_data_set(swigCPtr, this, value);
+  }
+
+  public byte[] getUser_data() {
+	return pjsuaJNI.pjsua_buddy_config_user_data_get(swigCPtr, this);
+}
+
+  public pjsua_buddy_config() {
+    this(pjsuaJNI.new_pjsua_buddy_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_info.java	(working copy)
@@ -0,0 +1,151 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_buddy_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_buddy_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_buddy_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_buddy_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setId(int value) {
+    pjsuaJNI.pjsua_buddy_info_id_set(swigCPtr, this, value);
+  }
+
+  public int getId() {
+    return pjsuaJNI.pjsua_buddy_info_id_get(swigCPtr, this);
+  }
+
+  public void setUri(pj_str_t value) {
+    pjsuaJNI.pjsua_buddy_info_uri_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getUri() {
+    long cPtr = pjsuaJNI.pjsua_buddy_info_uri_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setContact(pj_str_t value) {
+    pjsuaJNI.pjsua_buddy_info_contact_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getContact() {
+    long cPtr = pjsuaJNI.pjsua_buddy_info_contact_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setStatus(pjsua_buddy_status value) {
+    pjsuaJNI.pjsua_buddy_info_status_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_buddy_status getStatus() {
+    return pjsua_buddy_status.swigToEnum(pjsuaJNI.pjsua_buddy_info_status_get(swigCPtr, this));
+  }
+
+  public void setStatus_text(pj_str_t value) {
+    pjsuaJNI.pjsua_buddy_info_status_text_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getStatus_text() {
+    long cPtr = pjsuaJNI.pjsua_buddy_info_status_text_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setMonitor_pres(int value) {
+    pjsuaJNI.pjsua_buddy_info_monitor_pres_set(swigCPtr, this, value);
+  }
+
+  public int getMonitor_pres() {
+    return pjsuaJNI.pjsua_buddy_info_monitor_pres_get(swigCPtr, this);
+  }
+
+  public void setSub_state(SWIGTYPE_p_pjsip_evsub_state value) {
+    pjsuaJNI.pjsua_buddy_info_sub_state_set(swigCPtr, this, SWIGTYPE_p_pjsip_evsub_state.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_evsub_state getSub_state() {
+    return new SWIGTYPE_p_pjsip_evsub_state(pjsuaJNI.pjsua_buddy_info_sub_state_get(swigCPtr, this), true);
+  }
+
+  public void setSub_state_name(String value) {
+    pjsuaJNI.pjsua_buddy_info_sub_state_name_set(swigCPtr, this, value);
+  }
+
+  public String getSub_state_name() {
+    return pjsuaJNI.pjsua_buddy_info_sub_state_name_get(swigCPtr, this);
+  }
+
+  public void setSub_term_code(long value) {
+    pjsuaJNI.pjsua_buddy_info_sub_term_code_set(swigCPtr, this, value);
+  }
+
+  public long getSub_term_code() {
+    return pjsuaJNI.pjsua_buddy_info_sub_term_code_get(swigCPtr, this);
+  }
+
+  public void setSub_term_reason(pj_str_t value) {
+    pjsuaJNI.pjsua_buddy_info_sub_term_reason_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getSub_term_reason() {
+    long cPtr = pjsuaJNI.pjsua_buddy_info_sub_term_reason_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setRpid(pjrpid_element value) {
+    pjsuaJNI.pjsua_buddy_info_rpid_set(swigCPtr, this, pjrpid_element.getCPtr(value), value);
+  }
+
+  public pjrpid_element getRpid() {
+    long cPtr = pjsuaJNI.pjsua_buddy_info_rpid_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjrpid_element(cPtr, false);
+  }
+
+  public void setPres_status(SWIGTYPE_p_pjsip_pres_status value) {
+    pjsuaJNI.pjsua_buddy_info_pres_status_set(swigCPtr, this, SWIGTYPE_p_pjsip_pres_status.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_pres_status getPres_status() {
+    return new SWIGTYPE_p_pjsip_pres_status(pjsuaJNI.pjsua_buddy_info_pres_status_get(swigCPtr, this), true);
+  }
+
+  public void setBuf_(String value) {
+    pjsuaJNI.pjsua_buddy_info_buf__set(swigCPtr, this, value);
+  }
+
+  public String getBuf_() {
+    return pjsuaJNI.pjsua_buddy_info_buf__get(swigCPtr, this);
+  }
+
+  public pjsua_buddy_info() {
+    this(pjsuaJNI.new_pjsua_buddy_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_status.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_status.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_buddy_status.java	(working copy)
@@ -0,0 +1,53 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_buddy_status {
+  PJSUA_BUDDY_STATUS_UNKNOWN,
+  PJSUA_BUDDY_STATUS_ONLINE,
+  PJSUA_BUDDY_STATUS_OFFLINE;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_buddy_status swigToEnum(int swigValue) {
+    pjsua_buddy_status[] swigValues = pjsua_buddy_status.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_buddy_status swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_buddy_status.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_buddy_status() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_buddy_status(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_buddy_status(pjsua_buddy_status swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_call_flag.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_call_flag.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_call_flag.java	(working copy)
@@ -0,0 +1,54 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_call_flag {
+  PJSUA_CALL_UNHOLD(pjsuaJNI.PJSUA_CALL_UNHOLD_get()),
+  PJSUA_CALL_UPDATE_CONTACT(pjsuaJNI.PJSUA_CALL_UPDATE_CONTACT_get()),
+  PJSUA_CALL_INCLUDE_DISABLED_MEDIA(pjsuaJNI.PJSUA_CALL_INCLUDE_DISABLED_MEDIA_get()),
+  PJSUA_CALL_NO_SDP_OFFER(pjsuaJNI.PJSUA_CALL_NO_SDP_OFFER_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_call_flag swigToEnum(int swigValue) {
+    pjsua_call_flag[] swigValues = pjsua_call_flag.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_call_flag swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_call_flag.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_flag() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_flag(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_flag(pjsua_call_flag swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_call_hold_type.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_call_hold_type.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_call_hold_type.java	(working copy)
@@ -0,0 +1,52 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_call_hold_type {
+  PJSUA_CALL_HOLD_TYPE_RFC3264,
+  PJSUA_CALL_HOLD_TYPE_RFC2543;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_call_hold_type swigToEnum(int swigValue) {
+    pjsua_call_hold_type[] swigValues = pjsua_call_hold_type.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_call_hold_type swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_call_hold_type.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_hold_type() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_hold_type(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_hold_type(pjsua_call_hold_type swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_call_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_call_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_call_info.java	(working copy)
@@ -0,0 +1,254 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_call_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_call_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_call_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_call_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setId(int value) {
+    pjsuaJNI.pjsua_call_info_id_set(swigCPtr, this, value);
+  }
+
+  public int getId() {
+    return pjsuaJNI.pjsua_call_info_id_get(swigCPtr, this);
+  }
+
+  public void setRole(SWIGTYPE_p_pjsip_role_e value) {
+    pjsuaJNI.pjsua_call_info_role_set(swigCPtr, this, SWIGTYPE_p_pjsip_role_e.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_role_e getRole() {
+    return new SWIGTYPE_p_pjsip_role_e(pjsuaJNI.pjsua_call_info_role_get(swigCPtr, this), true);
+  }
+
+  public void setAcc_id(int value) {
+    pjsuaJNI.pjsua_call_info_acc_id_set(swigCPtr, this, value);
+  }
+
+  public int getAcc_id() {
+    return pjsuaJNI.pjsua_call_info_acc_id_get(swigCPtr, this);
+  }
+
+  public void setLocal_info(pj_str_t value) {
+    pjsuaJNI.pjsua_call_info_local_info_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getLocal_info() {
+    long cPtr = pjsuaJNI.pjsua_call_info_local_info_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setLocal_contact(pj_str_t value) {
+    pjsuaJNI.pjsua_call_info_local_contact_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getLocal_contact() {
+    long cPtr = pjsuaJNI.pjsua_call_info_local_contact_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setRemote_info(pj_str_t value) {
+    pjsuaJNI.pjsua_call_info_remote_info_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getRemote_info() {
+    long cPtr = pjsuaJNI.pjsua_call_info_remote_info_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setRemote_contact(pj_str_t value) {
+    pjsuaJNI.pjsua_call_info_remote_contact_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getRemote_contact() {
+    long cPtr = pjsuaJNI.pjsua_call_info_remote_contact_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setCall_id(pj_str_t value) {
+    pjsuaJNI.pjsua_call_info_call_id_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getCall_id() {
+    long cPtr = pjsuaJNI.pjsua_call_info_call_id_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setSetting(pjsua_call_setting value) {
+    pjsuaJNI.pjsua_call_info_setting_set(swigCPtr, this, pjsua_call_setting.getCPtr(value), value);
+  }
+
+  public pjsua_call_setting getSetting() {
+    long cPtr = pjsuaJNI.pjsua_call_info_setting_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsua_call_setting(cPtr, false);
+  }
+
+  public void setState(pjsip_inv_state value) {
+    pjsuaJNI.pjsua_call_info_state_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsip_inv_state getState() {
+    return pjsip_inv_state.swigToEnum(pjsuaJNI.pjsua_call_info_state_get(swigCPtr, this));
+  }
+
+  public void setState_text(pj_str_t value) {
+    pjsuaJNI.pjsua_call_info_state_text_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getState_text() {
+    long cPtr = pjsuaJNI.pjsua_call_info_state_text_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setLast_status(pjsip_status_code value) {
+    pjsuaJNI.pjsua_call_info_last_status_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsip_status_code getLast_status() {
+    return pjsip_status_code.swigToEnum(pjsuaJNI.pjsua_call_info_last_status_get(swigCPtr, this));
+  }
+
+  public void setLast_status_text(pj_str_t value) {
+    pjsuaJNI.pjsua_call_info_last_status_text_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getLast_status_text() {
+    long cPtr = pjsuaJNI.pjsua_call_info_last_status_text_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setMedia_status(pjsua_call_media_status value) {
+    pjsuaJNI.pjsua_call_info_media_status_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_call_media_status getMedia_status() {
+    return pjsua_call_media_status.swigToEnum(pjsuaJNI.pjsua_call_info_media_status_get(swigCPtr, this));
+  }
+
+  public void setMedia_dir(pjmedia_dir value) {
+    pjsuaJNI.pjsua_call_info_media_dir_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjmedia_dir getMedia_dir() {
+    return pjmedia_dir.swigToEnum(pjsuaJNI.pjsua_call_info_media_dir_get(swigCPtr, this));
+  }
+
+  public void setConf_slot(int value) {
+    pjsuaJNI.pjsua_call_info_conf_slot_set(swigCPtr, this, value);
+  }
+
+  public int getConf_slot() {
+    return pjsuaJNI.pjsua_call_info_conf_slot_get(swigCPtr, this);
+  }
+
+  public void setMedia_cnt(long value) {
+    pjsuaJNI.pjsua_call_info_media_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getMedia_cnt() {
+    return pjsuaJNI.pjsua_call_info_media_cnt_get(swigCPtr, this);
+  }
+
+  public void setMedia(pjsua_call_media_info value) {
+    pjsuaJNI.pjsua_call_info_media_set(swigCPtr, this, pjsua_call_media_info.getCPtr(value), value);
+  }
+
+  public pjsua_call_media_info getMedia() {
+    long cPtr = pjsuaJNI.pjsua_call_info_media_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsua_call_media_info(cPtr, false);
+  }
+
+  public void setProv_media_cnt(long value) {
+    pjsuaJNI.pjsua_call_info_prov_media_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getProv_media_cnt() {
+    return pjsuaJNI.pjsua_call_info_prov_media_cnt_get(swigCPtr, this);
+  }
+
+  public void setProv_media(pjsua_call_media_info value) {
+    pjsuaJNI.pjsua_call_info_prov_media_set(swigCPtr, this, pjsua_call_media_info.getCPtr(value), value);
+  }
+
+  public pjsua_call_media_info getProv_media() {
+    long cPtr = pjsuaJNI.pjsua_call_info_prov_media_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsua_call_media_info(cPtr, false);
+  }
+
+  public void setConnect_duration(pj_time_val value) {
+    pjsuaJNI.pjsua_call_info_connect_duration_set(swigCPtr, this, pj_time_val.getCPtr(value), value);
+  }
+
+  public pj_time_val getConnect_duration() {
+    long cPtr = pjsuaJNI.pjsua_call_info_connect_duration_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_time_val(cPtr, false);
+  }
+
+  public void setTotal_duration(pj_time_val value) {
+    pjsuaJNI.pjsua_call_info_total_duration_set(swigCPtr, this, pj_time_val.getCPtr(value), value);
+  }
+
+  public pj_time_val getTotal_duration() {
+    long cPtr = pjsuaJNI.pjsua_call_info_total_duration_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_time_val(cPtr, false);
+  }
+
+  public void setRem_offerer(int value) {
+    pjsuaJNI.pjsua_call_info_rem_offerer_set(swigCPtr, this, value);
+  }
+
+  public int getRem_offerer() {
+    return pjsuaJNI.pjsua_call_info_rem_offerer_get(swigCPtr, this);
+  }
+
+  public void setRem_aud_cnt(long value) {
+    pjsuaJNI.pjsua_call_info_rem_aud_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getRem_aud_cnt() {
+    return pjsuaJNI.pjsua_call_info_rem_aud_cnt_get(swigCPtr, this);
+  }
+
+  public void setRem_vid_cnt(long value) {
+    pjsuaJNI.pjsua_call_info_rem_vid_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getRem_vid_cnt() {
+    return pjsuaJNI.pjsua_call_info_rem_vid_cnt_get(swigCPtr, this);
+  }
+
+  public pjsua_call_info() {
+    this(pjsuaJNI.new_pjsua_call_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_call_media_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_call_media_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_call_media_info.java	(working copy)
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_call_media_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_call_media_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_call_media_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_call_media_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setIndex(long value) {
+    pjsuaJNI.pjsua_call_media_info_index_set(swigCPtr, this, value);
+  }
+
+  public long getIndex() {
+    return pjsuaJNI.pjsua_call_media_info_index_get(swigCPtr, this);
+  }
+
+  public void setType(SWIGTYPE_p_pjmedia_type value) {
+    pjsuaJNI.pjsua_call_media_info_type_set(swigCPtr, this, SWIGTYPE_p_pjmedia_type.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_type getType() {
+    return new SWIGTYPE_p_pjmedia_type(pjsuaJNI.pjsua_call_media_info_type_get(swigCPtr, this), true);
+  }
+
+  public void setDir(pjmedia_dir value) {
+    pjsuaJNI.pjsua_call_media_info_dir_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjmedia_dir getDir() {
+    return pjmedia_dir.swigToEnum(pjsuaJNI.pjsua_call_media_info_dir_get(swigCPtr, this));
+  }
+
+  public void setStatus(pjsua_call_media_status value) {
+    pjsuaJNI.pjsua_call_media_info_status_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_call_media_status getStatus() {
+    return pjsua_call_media_status.swigToEnum(pjsuaJNI.pjsua_call_media_info_status_get(swigCPtr, this));
+  }
+
+  public pjsua_call_media_info() {
+    this(pjsuaJNI.new_pjsua_call_media_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_call_media_status.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_call_media_status.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_call_media_status.java	(working copy)
@@ -0,0 +1,55 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_call_media_status {
+  PJSUA_CALL_MEDIA_NONE,
+  PJSUA_CALL_MEDIA_ACTIVE,
+  PJSUA_CALL_MEDIA_LOCAL_HOLD,
+  PJSUA_CALL_MEDIA_REMOTE_HOLD,
+  PJSUA_CALL_MEDIA_ERROR;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_call_media_status swigToEnum(int swigValue) {
+    pjsua_call_media_status[] swigValues = pjsua_call_media_status.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_call_media_status swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_call_media_status.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_media_status() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_media_status(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_media_status(pjsua_call_media_status swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_call_setting.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_call_setting.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_call_setting.java	(working copy)
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_call_setting {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_call_setting(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_call_setting obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_call_setting(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setFlag(long value) {
+    pjsuaJNI.pjsua_call_setting_flag_set(swigCPtr, this, value);
+  }
+
+  public long getFlag() {
+    return pjsuaJNI.pjsua_call_setting_flag_get(swigCPtr, this);
+  }
+
+  public void setReq_keyframe_method(long value) {
+    pjsuaJNI.pjsua_call_setting_req_keyframe_method_set(swigCPtr, this, value);
+  }
+
+  public long getReq_keyframe_method() {
+    return pjsuaJNI.pjsua_call_setting_req_keyframe_method_get(swigCPtr, this);
+  }
+
+  public void setAud_cnt(long value) {
+    pjsuaJNI.pjsua_call_setting_aud_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getAud_cnt() {
+    return pjsuaJNI.pjsua_call_setting_aud_cnt_get(swigCPtr, this);
+  }
+
+  public void setVid_cnt(long value) {
+    pjsuaJNI.pjsua_call_setting_vid_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getVid_cnt() {
+    return pjsuaJNI.pjsua_call_setting_vid_cnt_get(swigCPtr, this);
+  }
+
+  public pjsua_call_setting() {
+    this(pjsuaJNI.new_pjsua_call_setting(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_call_vid_strm_op.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_call_vid_strm_op.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_call_vid_strm_op.java	(working copy)
@@ -0,0 +1,58 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_call_vid_strm_op {
+  PJSUA_CALL_VID_STRM_NO_OP,
+  PJSUA_CALL_VID_STRM_ADD,
+  PJSUA_CALL_VID_STRM_REMOVE,
+  PJSUA_CALL_VID_STRM_CHANGE_DIR,
+  PJSUA_CALL_VID_STRM_CHANGE_CAP_DEV,
+  PJSUA_CALL_VID_STRM_START_TRANSMIT,
+  PJSUA_CALL_VID_STRM_STOP_TRANSMIT,
+  PJSUA_CALL_VID_STRM_SEND_KEYFRAME;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_call_vid_strm_op swigToEnum(int swigValue) {
+    pjsua_call_vid_strm_op[] swigValues = pjsua_call_vid_strm_op.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_call_vid_strm_op swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_call_vid_strm_op.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_vid_strm_op() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_vid_strm_op(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_call_vid_strm_op(pjsua_call_vid_strm_op swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_call_vid_strm_op_param.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_call_vid_strm_op_param.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_call_vid_strm_op_param.java	(working copy)
@@ -0,0 +1,66 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_call_vid_strm_op_param {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_call_vid_strm_op_param(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_call_vid_strm_op_param obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_call_vid_strm_op_param(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setMed_idx(int value) {
+    pjsuaJNI.pjsua_call_vid_strm_op_param_med_idx_set(swigCPtr, this, value);
+  }
+
+  public int getMed_idx() {
+    return pjsuaJNI.pjsua_call_vid_strm_op_param_med_idx_get(swigCPtr, this);
+  }
+
+  public void setDir(pjmedia_dir value) {
+    pjsuaJNI.pjsua_call_vid_strm_op_param_dir_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjmedia_dir getDir() {
+    return pjmedia_dir.swigToEnum(pjsuaJNI.pjsua_call_vid_strm_op_param_dir_get(swigCPtr, this));
+  }
+
+  public void setCap_dev(SWIGTYPE_p_pjmedia_vid_dev_index value) {
+    pjsuaJNI.pjsua_call_vid_strm_op_param_cap_dev_set(swigCPtr, this, SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_vid_dev_index getCap_dev() {
+    return new SWIGTYPE_p_pjmedia_vid_dev_index(pjsuaJNI.pjsua_call_vid_strm_op_param_cap_dev_get(swigCPtr, this), true);
+  }
+
+  public pjsua_call_vid_strm_op_param() {
+    this(pjsuaJNI.new_pjsua_call_vid_strm_op_param(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_callback.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_callback.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_callback.java	(working copy)
@@ -0,0 +1,392 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_callback {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_callback(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_callback obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_callback(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setOn_call_state(SWIGTYPE_p_f_int_p_pjsip_event__void value) {
+    pjsuaJNI.pjsua_callback_on_call_state_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsip_event__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsip_event__void getOn_call_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsip_event__void(cPtr, false);
+  }
+
+  public void setOn_incoming_call(SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void value) {
+    pjsuaJNI.pjsua_callback_on_incoming_call_set(swigCPtr, this, SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void getOn_incoming_call() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_incoming_call_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void(cPtr, false);
+  }
+
+  public void setOn_call_tsx_state(SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void value) {
+    pjsuaJNI.pjsua_callback_on_call_tsx_state_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void getOn_call_tsx_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_tsx_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void(cPtr, false);
+  }
+
+  public void setOn_call_media_state(SWIGTYPE_p_f_int__void value) {
+    pjsuaJNI.pjsua_callback_on_call_media_state_set(swigCPtr, this, SWIGTYPE_p_f_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int__void getOn_call_media_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_media_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int__void(cPtr, false);
+  }
+
+  public void setOn_call_sdp_created(SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void value) {
+    pjsuaJNI.pjsua_callback_on_call_sdp_created_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void getOn_call_sdp_created() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_sdp_created_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void(cPtr, false);
+  }
+
+  public void setOn_stream_created(SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void value) {
+    pjsuaJNI.pjsua_callback_on_stream_created_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void getOn_stream_created() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_stream_created_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void(cPtr, false);
+  }
+
+  public void setOn_stream_destroyed(SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void value) {
+    pjsuaJNI.pjsua_callback_on_stream_destroyed_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void getOn_stream_destroyed() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_stream_destroyed_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void(cPtr, false);
+  }
+
+  public void setOn_dtmf_digit(SWIGTYPE_p_f_int_int__void value) {
+    pjsuaJNI.pjsua_callback_on_dtmf_digit_set(swigCPtr, this, SWIGTYPE_p_f_int_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_int__void getOn_dtmf_digit() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_dtmf_digit_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_int__void(cPtr, false);
+  }
+
+  public void setOn_call_transfer_request(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void value) {
+    pjsuaJNI.pjsua_callback_on_call_transfer_request_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void getOn_call_transfer_request() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_transfer_request_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void(cPtr, false);
+  }
+
+  public void setOn_call_transfer_request2(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void value) {
+    pjsuaJNI.pjsua_callback_on_call_transfer_request2_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void getOn_call_transfer_request2() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_transfer_request2_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void(cPtr, false);
+  }
+
+  public void setOn_call_transfer_status(SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void value) {
+    pjsuaJNI.pjsua_callback_on_call_transfer_status_set(swigCPtr, this, SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void getOn_call_transfer_status() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_transfer_status_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void(cPtr, false);
+  }
+
+  public void setOn_call_replace_request(SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void value) {
+    pjsuaJNI.pjsua_callback_on_call_replace_request_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void getOn_call_replace_request() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_replace_request_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void(cPtr, false);
+  }
+
+  public void setOn_call_replace_request2(SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void value) {
+    pjsuaJNI.pjsua_callback_on_call_replace_request2_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void getOn_call_replace_request2() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_replace_request2_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void(cPtr, false);
+  }
+
+  public void setOn_call_replaced(SWIGTYPE_p_f_int_int__void value) {
+    pjsuaJNI.pjsua_callback_on_call_replaced_set(swigCPtr, this, SWIGTYPE_p_f_int_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_int__void getOn_call_replaced() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_replaced_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_int__void(cPtr, false);
+  }
+
+  public void setOn_call_rx_offer(SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void value) {
+    pjsuaJNI.pjsua_callback_on_call_rx_offer_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void getOn_call_rx_offer() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_rx_offer_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void(cPtr, false);
+  }
+
+  public void setOn_reg_started(SWIGTYPE_p_f_int_int__void value) {
+    pjsuaJNI.pjsua_callback_on_reg_started_set(swigCPtr, this, SWIGTYPE_p_f_int_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_int__void getOn_reg_started() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_reg_started_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_int__void(cPtr, false);
+  }
+
+  public void setOn_reg_state(SWIGTYPE_p_f_int__void value) {
+    pjsuaJNI.pjsua_callback_on_reg_state_set(swigCPtr, this, SWIGTYPE_p_f_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int__void getOn_reg_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_reg_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int__void(cPtr, false);
+  }
+
+  public void setOn_reg_state2(SWIGTYPE_p_f_int_p_pjsua_reg_info__void value) {
+    pjsuaJNI.pjsua_callback_on_reg_state2_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsua_reg_info__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsua_reg_info__void getOn_reg_state2() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_reg_state2_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsua_reg_info__void(cPtr, false);
+  }
+
+  public void setOn_incoming_subscribe(SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void value) {
+    pjsuaJNI.pjsua_callback_on_incoming_subscribe_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void getOn_incoming_subscribe() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_incoming_subscribe_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void(cPtr, false);
+  }
+
+  public void setOn_srv_subscribe_state(SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void value) {
+    pjsuaJNI.pjsua_callback_on_srv_subscribe_state_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void getOn_srv_subscribe_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_srv_subscribe_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void(cPtr, false);
+  }
+
+  public void setOn_buddy_state(SWIGTYPE_p_f_int__void value) {
+    pjsuaJNI.pjsua_callback_on_buddy_state_set(swigCPtr, this, SWIGTYPE_p_f_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int__void getOn_buddy_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_buddy_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int__void(cPtr, false);
+  }
+
+  public void setOn_buddy_evsub_state(SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void value) {
+    pjsuaJNI.pjsua_callback_on_buddy_evsub_state_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void getOn_buddy_evsub_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_buddy_evsub_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void(cPtr, false);
+  }
+
+  public void setOn_pager(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void value) {
+    pjsuaJNI.pjsua_callback_on_pager_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void getOn_pager() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_pager_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void(cPtr, false);
+  }
+
+  public void setOn_pager2(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void value) {
+    pjsuaJNI.pjsua_callback_on_pager2_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void getOn_pager2() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_pager2_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void(cPtr, false);
+  }
+
+  public void setOn_pager_status(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void value) {
+    pjsuaJNI.pjsua_callback_on_pager_status_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void getOn_pager_status() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_pager_status_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void(cPtr, false);
+  }
+
+  public void setOn_pager_status2(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void value) {
+    pjsuaJNI.pjsua_callback_on_pager_status2_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void getOn_pager_status2() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_pager_status2_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void(cPtr, false);
+  }
+
+  public void setOn_typing(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void value) {
+    pjsuaJNI.pjsua_callback_on_typing_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void getOn_typing() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_typing_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void(cPtr, false);
+  }
+
+  public void setOn_typing2(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void value) {
+    pjsuaJNI.pjsua_callback_on_typing2_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void getOn_typing2() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_typing2_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void(cPtr, false);
+  }
+
+  public void setOn_nat_detect(SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void value) {
+    pjsuaJNI.pjsua_callback_on_nat_detect_set(swigCPtr, this, SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void getOn_nat_detect() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_nat_detect_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void(cPtr, false);
+  }
+
+  public void setOn_call_redirected(SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op value) {
+    pjsuaJNI.pjsua_callback_on_call_redirected_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op getOn_call_redirected() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_redirected_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op(cPtr, false);
+  }
+
+  public void setOn_mwi_state(SWIGTYPE_p_f_int_p_pjsip_evsub__void value) {
+    pjsuaJNI.pjsua_callback_on_mwi_state_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsip_evsub__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsip_evsub__void getOn_mwi_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_mwi_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsip_evsub__void(cPtr, false);
+  }
+
+  public void setOn_mwi_info(SWIGTYPE_p_f_int_p_pjsua_mwi_info__void value) {
+    pjsuaJNI.pjsua_callback_on_mwi_info_set(swigCPtr, this, SWIGTYPE_p_f_int_p_pjsua_mwi_info__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_pjsua_mwi_info__void getOn_mwi_info() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_mwi_info_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_pjsua_mwi_info__void(cPtr, false);
+  }
+
+  public void setOn_transport_state(SWIGTYPE_p_pjsip_tp_state_callback value) {
+    pjsuaJNI.pjsua_callback_on_transport_state_set(swigCPtr, this, SWIGTYPE_p_pjsip_tp_state_callback.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_tp_state_callback getOn_transport_state() {
+    return new SWIGTYPE_p_pjsip_tp_state_callback(pjsuaJNI.pjsua_callback_on_transport_state_get(swigCPtr, this), true);
+  }
+
+  public void setOn_call_media_transport_state(SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int value) {
+    pjsuaJNI.pjsua_callback_on_call_media_transport_state_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int getOn_call_media_transport_state() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_media_transport_state_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int(cPtr, false);
+  }
+
+  public void setOn_ice_transport_error(SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void value) {
+    pjsuaJNI.pjsua_callback_on_ice_transport_error_set(swigCPtr, this, SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void getOn_ice_transport_error() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_ice_transport_error_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void(cPtr, false);
+  }
+
+  public void setOn_snd_dev_operation(SWIGTYPE_p_f_int__int value) {
+    pjsuaJNI.pjsua_callback_on_snd_dev_operation_set(swigCPtr, this, SWIGTYPE_p_f_int__int.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int__int getOn_snd_dev_operation() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_snd_dev_operation_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int__int(cPtr, false);
+  }
+
+  public void setOn_call_media_event(SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void value) {
+    pjsuaJNI.pjsua_callback_on_call_media_event_set(swigCPtr, this, SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void getOn_call_media_event() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_call_media_event_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void(cPtr, false);
+  }
+
+  public void setOn_create_media_transport(SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport value) {
+    pjsuaJNI.pjsua_callback_on_create_media_transport_set(swigCPtr, this, SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport getOn_create_media_transport() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_create_media_transport_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport(cPtr, false);
+  }
+
+  public void setOn_acc_find_for_incoming(SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void value) {
+    pjsuaJNI.pjsua_callback_on_acc_find_for_incoming_set(swigCPtr, this, SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void getOn_acc_find_for_incoming() {
+    long cPtr = pjsuaJNI.pjsua_callback_on_acc_find_for_incoming_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void(cPtr, false);
+  }
+
+  public pjsua_callback() {
+    this(pjsuaJNI.new_pjsua_callback(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_codec_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_codec_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_codec_info.java	(working copy)
@@ -0,0 +1,76 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_codec_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_codec_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_codec_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_codec_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setCodec_id(pj_str_t value) {
+    pjsuaJNI.pjsua_codec_info_codec_id_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getCodec_id() {
+    long cPtr = pjsuaJNI.pjsua_codec_info_codec_id_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setPriority(short value) {
+    pjsuaJNI.pjsua_codec_info_priority_set(swigCPtr, this, value);
+  }
+
+  public short getPriority() {
+    return pjsuaJNI.pjsua_codec_info_priority_get(swigCPtr, this);
+  }
+
+  public void setDesc(pj_str_t value) {
+    pjsuaJNI.pjsua_codec_info_desc_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getDesc() {
+    long cPtr = pjsuaJNI.pjsua_codec_info_desc_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setBuf_(String value) {
+    pjsuaJNI.pjsua_codec_info_buf__set(swigCPtr, this, value);
+  }
+
+  public String getBuf_() {
+    return pjsuaJNI.pjsua_codec_info_buf__get(swigCPtr, this);
+  }
+
+  public pjsua_codec_info() {
+    this(pjsuaJNI.new_pjsua_codec_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_conf_port_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_conf_port_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_conf_port_info.java	(working copy)
@@ -0,0 +1,131 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_conf_port_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_conf_port_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_conf_port_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_conf_port_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setSlot_id(int value) {
+    pjsuaJNI.pjsua_conf_port_info_slot_id_set(swigCPtr, this, value);
+  }
+
+  public int getSlot_id() {
+    return pjsuaJNI.pjsua_conf_port_info_slot_id_get(swigCPtr, this);
+  }
+
+  public void setName(pj_str_t value) {
+    pjsuaJNI.pjsua_conf_port_info_name_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getName() {
+    long cPtr = pjsuaJNI.pjsua_conf_port_info_name_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setFormat(SWIGTYPE_p_pjmedia_format value) {
+    pjsuaJNI.pjsua_conf_port_info_format_set(swigCPtr, this, SWIGTYPE_p_pjmedia_format.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_format getFormat() {
+    return new SWIGTYPE_p_pjmedia_format(pjsuaJNI.pjsua_conf_port_info_format_get(swigCPtr, this), true);
+  }
+
+  public void setClock_rate(long value) {
+    pjsuaJNI.pjsua_conf_port_info_clock_rate_set(swigCPtr, this, value);
+  }
+
+  public long getClock_rate() {
+    return pjsuaJNI.pjsua_conf_port_info_clock_rate_get(swigCPtr, this);
+  }
+
+  public void setChannel_count(long value) {
+    pjsuaJNI.pjsua_conf_port_info_channel_count_set(swigCPtr, this, value);
+  }
+
+  public long getChannel_count() {
+    return pjsuaJNI.pjsua_conf_port_info_channel_count_get(swigCPtr, this);
+  }
+
+  public void setSamples_per_frame(long value) {
+    pjsuaJNI.pjsua_conf_port_info_samples_per_frame_set(swigCPtr, this, value);
+  }
+
+  public long getSamples_per_frame() {
+    return pjsuaJNI.pjsua_conf_port_info_samples_per_frame_get(swigCPtr, this);
+  }
+
+  public void setBits_per_sample(long value) {
+    pjsuaJNI.pjsua_conf_port_info_bits_per_sample_set(swigCPtr, this, value);
+  }
+
+  public long getBits_per_sample() {
+    return pjsuaJNI.pjsua_conf_port_info_bits_per_sample_get(swigCPtr, this);
+  }
+
+  public void setTx_level_adj(float value) {
+    pjsuaJNI.pjsua_conf_port_info_tx_level_adj_set(swigCPtr, this, value);
+  }
+
+  public float getTx_level_adj() {
+    return pjsuaJNI.pjsua_conf_port_info_tx_level_adj_get(swigCPtr, this);
+  }
+
+  public void setRx_level_adj(float value) {
+    pjsuaJNI.pjsua_conf_port_info_rx_level_adj_set(swigCPtr, this, value);
+  }
+
+  public float getRx_level_adj() {
+    return pjsuaJNI.pjsua_conf_port_info_rx_level_adj_get(swigCPtr, this);
+  }
+
+  public void setListener_cnt(long value) {
+    pjsuaJNI.pjsua_conf_port_info_listener_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getListener_cnt() {
+    return pjsuaJNI.pjsua_conf_port_info_listener_cnt_get(swigCPtr, this);
+  }
+
+  public void setListeners(int[] value) {
+    pjsuaJNI.pjsua_conf_port_info_listeners_set(swigCPtr, this, value);
+  }
+
+  public int[] getListeners() {
+    return pjsuaJNI.pjsua_conf_port_info_listeners_get(swigCPtr, this);
+  }
+
+  public pjsua_conf_port_info() {
+    this(pjsuaJNI.new_pjsua_conf_port_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_config.java	(working copy)
@@ -0,0 +1,256 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setMax_calls(long value) {
+    pjsuaJNI.pjsua_config_max_calls_set(swigCPtr, this, value);
+  }
+
+  public long getMax_calls() {
+    return pjsuaJNI.pjsua_config_max_calls_get(swigCPtr, this);
+  }
+
+  public void setThread_cnt(long value) {
+    pjsuaJNI.pjsua_config_thread_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getThread_cnt() {
+    return pjsuaJNI.pjsua_config_thread_cnt_get(swigCPtr, this);
+  }
+
+  public void setNameserver_count(long value) {
+    pjsuaJNI.pjsua_config_nameserver_count_set(swigCPtr, this, value);
+  }
+
+  public long getNameserver_count() {
+    return pjsuaJNI.pjsua_config_nameserver_count_get(swigCPtr, this);
+  }
+
+  public void setNameserver(pj_str_t[] value) {
+    pjsuaJNI.pjsua_config_nameserver_set(swigCPtr, this, pj_str_t.cArrayUnwrap(value));
+  }
+
+  public pj_str_t[] getNameserver() {
+    return pj_str_t.cArrayWrap(pjsuaJNI.pjsua_config_nameserver_get(swigCPtr, this), false);
+  }
+
+  public void setForce_lr(int value) {
+    pjsuaJNI.pjsua_config_force_lr_set(swigCPtr, this, value);
+  }
+
+  public int getForce_lr() {
+    return pjsuaJNI.pjsua_config_force_lr_get(swigCPtr, this);
+  }
+
+  public void setOutbound_proxy_cnt(long value) {
+    pjsuaJNI.pjsua_config_outbound_proxy_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getOutbound_proxy_cnt() {
+    return pjsuaJNI.pjsua_config_outbound_proxy_cnt_get(swigCPtr, this);
+  }
+
+  public void setOutbound_proxy(pj_str_t[] value) {
+    pjsuaJNI.pjsua_config_outbound_proxy_set(swigCPtr, this, pj_str_t.cArrayUnwrap(value));
+  }
+
+  public pj_str_t[] getOutbound_proxy() {
+    return pj_str_t.cArrayWrap(pjsuaJNI.pjsua_config_outbound_proxy_get(swigCPtr, this), false);
+  }
+
+  public void setStun_domain(pj_str_t value) {
+    pjsuaJNI.pjsua_config_stun_domain_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getStun_domain() {
+    long cPtr = pjsuaJNI.pjsua_config_stun_domain_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setStun_host(pj_str_t value) {
+    pjsuaJNI.pjsua_config_stun_host_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getStun_host() {
+    long cPtr = pjsuaJNI.pjsua_config_stun_host_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setStun_srv_cnt(long value) {
+    pjsuaJNI.pjsua_config_stun_srv_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getStun_srv_cnt() {
+    return pjsuaJNI.pjsua_config_stun_srv_cnt_get(swigCPtr, this);
+  }
+
+  public void setStun_srv(pj_str_t[] value) {
+    pjsuaJNI.pjsua_config_stun_srv_set(swigCPtr, this, pj_str_t.cArrayUnwrap(value));
+  }
+
+  public pj_str_t[] getStun_srv() {
+    return pj_str_t.cArrayWrap(pjsuaJNI.pjsua_config_stun_srv_get(swigCPtr, this), false);
+  }
+
+  public void setStun_ignore_failure(int value) {
+    pjsuaJNI.pjsua_config_stun_ignore_failure_set(swigCPtr, this, value);
+  }
+
+  public int getStun_ignore_failure() {
+    return pjsuaJNI.pjsua_config_stun_ignore_failure_get(swigCPtr, this);
+  }
+
+  public void setStun_map_use_stun2(int value) {
+    pjsuaJNI.pjsua_config_stun_map_use_stun2_set(swigCPtr, this, value);
+  }
+
+  public int getStun_map_use_stun2() {
+    return pjsuaJNI.pjsua_config_stun_map_use_stun2_get(swigCPtr, this);
+  }
+
+  public void setNat_type_in_sdp(int value) {
+    pjsuaJNI.pjsua_config_nat_type_in_sdp_set(swigCPtr, this, value);
+  }
+
+  public int getNat_type_in_sdp() {
+    return pjsuaJNI.pjsua_config_nat_type_in_sdp_get(swigCPtr, this);
+  }
+
+  public void setRequire_100rel(pjsua_100rel_use value) {
+    pjsuaJNI.pjsua_config_require_100rel_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_100rel_use getRequire_100rel() {
+    return pjsua_100rel_use.swigToEnum(pjsuaJNI.pjsua_config_require_100rel_get(swigCPtr, this));
+  }
+
+  public void setUse_timer(pjsua_sip_timer_use value) {
+    pjsuaJNI.pjsua_config_use_timer_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_sip_timer_use getUse_timer() {
+    return pjsua_sip_timer_use.swigToEnum(pjsuaJNI.pjsua_config_use_timer_get(swigCPtr, this));
+  }
+
+  public void setEnable_unsolicited_mwi(int value) {
+    pjsuaJNI.pjsua_config_enable_unsolicited_mwi_set(swigCPtr, this, value);
+  }
+
+  public int getEnable_unsolicited_mwi() {
+    return pjsuaJNI.pjsua_config_enable_unsolicited_mwi_get(swigCPtr, this);
+  }
+
+  public void setTimer_setting(pjsip_timer_setting value) {
+    pjsuaJNI.pjsua_config_timer_setting_set(swigCPtr, this, pjsip_timer_setting.getCPtr(value), value);
+  }
+
+  public pjsip_timer_setting getTimer_setting() {
+    long cPtr = pjsuaJNI.pjsua_config_timer_setting_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsip_timer_setting(cPtr, false);
+  }
+
+  public void setCred_count(long value) {
+    pjsuaJNI.pjsua_config_cred_count_set(swigCPtr, this, value);
+  }
+
+  public long getCred_count() {
+    return pjsuaJNI.pjsua_config_cred_count_get(swigCPtr, this);
+  }
+
+  public void setCred_info(pjsip_cred_info value) {
+    pjsuaJNI.pjsua_config_cred_info_set(swigCPtr, this, pjsip_cred_info.getCPtr(value), value);
+  }
+
+  public pjsip_cred_info getCred_info() {
+    long cPtr = pjsuaJNI.pjsua_config_cred_info_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsip_cred_info(cPtr, false);
+  }
+
+  public void setCb(pjsua_callback value) {
+    pjsuaJNI.pjsua_config_cb_set(swigCPtr, this, pjsua_callback.getCPtr(value), value);
+  }
+
+  public pjsua_callback getCb() {
+    long cPtr = pjsuaJNI.pjsua_config_cb_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsua_callback(cPtr, false);
+  }
+
+  public void setUser_agent(pj_str_t value) {
+    pjsuaJNI.pjsua_config_user_agent_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getUser_agent() {
+    long cPtr = pjsuaJNI.pjsua_config_user_agent_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setUse_srtp(pjmedia_srtp_use value) {
+    pjsuaJNI.pjsua_config_use_srtp_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjmedia_srtp_use getUse_srtp() {
+    return pjmedia_srtp_use.swigToEnum(pjsuaJNI.pjsua_config_use_srtp_get(swigCPtr, this));
+  }
+
+  public void setSrtp_secure_signaling(int value) {
+    pjsuaJNI.pjsua_config_srtp_secure_signaling_set(swigCPtr, this, value);
+  }
+
+  public int getSrtp_secure_signaling() {
+    return pjsuaJNI.pjsua_config_srtp_secure_signaling_get(swigCPtr, this);
+  }
+
+  public void setSrtp_optional_dup_offer(int value) {
+    pjsuaJNI.pjsua_config_srtp_optional_dup_offer_set(swigCPtr, this, value);
+  }
+
+  public int getSrtp_optional_dup_offer() {
+    return pjsuaJNI.pjsua_config_srtp_optional_dup_offer_get(swigCPtr, this);
+  }
+
+  public void setHangup_forked_call(int value) {
+    pjsuaJNI.pjsua_config_hangup_forked_call_set(swigCPtr, this, value);
+  }
+
+  public int getHangup_forked_call() {
+    return pjsuaJNI.pjsua_config_hangup_forked_call_get(swigCPtr, this);
+  }
+
+  public pjsua_config() {
+    this(pjsuaJNI.new_pjsua_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_contact_rewrite_method.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_contact_rewrite_method.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_contact_rewrite_method.java	(working copy)
@@ -0,0 +1,53 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_contact_rewrite_method {
+  PJSUA_CONTACT_REWRITE_UNREGISTER(pjsuaJNI.PJSUA_CONTACT_REWRITE_UNREGISTER_get()),
+  PJSUA_CONTACT_REWRITE_NO_UNREG(pjsuaJNI.PJSUA_CONTACT_REWRITE_NO_UNREG_get()),
+  PJSUA_CONTACT_REWRITE_ALWAYS_UPDATE(pjsuaJNI.PJSUA_CONTACT_REWRITE_ALWAYS_UPDATE_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_contact_rewrite_method swigToEnum(int swigValue) {
+    pjsua_contact_rewrite_method[] swigValues = pjsua_contact_rewrite_method.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_contact_rewrite_method swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_contact_rewrite_method.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_contact_rewrite_method() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_contact_rewrite_method(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_contact_rewrite_method(pjsua_contact_rewrite_method swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_create_media_transport_flag.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_create_media_transport_flag.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_create_media_transport_flag.java	(working copy)
@@ -0,0 +1,51 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_create_media_transport_flag {
+  PJSUA_MED_TP_CLOSE_MEMBER(pjsuaJNI.PJSUA_MED_TP_CLOSE_MEMBER_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_create_media_transport_flag swigToEnum(int swigValue) {
+    pjsua_create_media_transport_flag[] swigValues = pjsua_create_media_transport_flag.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_create_media_transport_flag swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_create_media_transport_flag.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_create_media_transport_flag() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_create_media_transport_flag(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_create_media_transport_flag(pjsua_create_media_transport_flag swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_destroy_flag.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_destroy_flag.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_destroy_flag.java	(working copy)
@@ -0,0 +1,53 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_destroy_flag {
+  PJSUA_DESTROY_NO_RX_MSG(pjsuaJNI.PJSUA_DESTROY_NO_RX_MSG_get()),
+  PJSUA_DESTROY_NO_TX_MSG(pjsuaJNI.PJSUA_DESTROY_NO_TX_MSG_get()),
+  PJSUA_DESTROY_NO_NETWORK(pjsuaJNI.PJSUA_DESTROY_NO_NETWORK_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_destroy_flag swigToEnum(int swigValue) {
+    pjsua_destroy_flag[] swigValues = pjsua_destroy_flag.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_destroy_flag swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_destroy_flag.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_destroy_flag() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_destroy_flag(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_destroy_flag(pjsua_destroy_flag swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_ice_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_ice_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_ice_config.java	(working copy)
@@ -0,0 +1,83 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_ice_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_ice_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_ice_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_ice_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setEnable_ice(int value) {
+    pjsuaJNI.pjsua_ice_config_enable_ice_set(swigCPtr, this, value);
+  }
+
+  public int getEnable_ice() {
+    return pjsuaJNI.pjsua_ice_config_enable_ice_get(swigCPtr, this);
+  }
+
+  public void setIce_max_host_cands(int value) {
+    pjsuaJNI.pjsua_ice_config_ice_max_host_cands_set(swigCPtr, this, value);
+  }
+
+  public int getIce_max_host_cands() {
+    return pjsuaJNI.pjsua_ice_config_ice_max_host_cands_get(swigCPtr, this);
+  }
+
+  public void setIce_opt(pj_ice_sess_options value) {
+    pjsuaJNI.pjsua_ice_config_ice_opt_set(swigCPtr, this, pj_ice_sess_options.getCPtr(value), value);
+  }
+
+  public pj_ice_sess_options getIce_opt() {
+    long cPtr = pjsuaJNI.pjsua_ice_config_ice_opt_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_ice_sess_options(cPtr, false);
+  }
+
+  public void setIce_no_rtcp(int value) {
+    pjsuaJNI.pjsua_ice_config_ice_no_rtcp_set(swigCPtr, this, value);
+  }
+
+  public int getIce_no_rtcp() {
+    return pjsuaJNI.pjsua_ice_config_ice_no_rtcp_get(swigCPtr, this);
+  }
+
+  public void setIce_always_update(int value) {
+    pjsuaJNI.pjsua_ice_config_ice_always_update_set(swigCPtr, this, value);
+  }
+
+  public int getIce_always_update() {
+    return pjsuaJNI.pjsua_ice_config_ice_always_update_get(swigCPtr, this);
+  }
+
+  public pjsua_ice_config() {
+    this(pjsuaJNI.new_pjsua_ice_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_ice_config_use.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_ice_config_use.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_ice_config_use.java	(working copy)
@@ -0,0 +1,52 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_ice_config_use {
+  PJSUA_ICE_CONFIG_USE_DEFAULT,
+  PJSUA_ICE_CONFIG_USE_CUSTOM;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_ice_config_use swigToEnum(int swigValue) {
+    pjsua_ice_config_use[] swigValues = pjsua_ice_config_use.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_ice_config_use swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_ice_config_use.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_ice_config_use() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_ice_config_use(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_ice_config_use(pjsua_ice_config_use swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_invalid_id_const_.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_invalid_id_const_.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_invalid_id_const_.java	(working copy)
@@ -0,0 +1,51 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_invalid_id_const_ {
+  PJSUA_INVALID_ID(pjsuaJNI.PJSUA_INVALID_ID_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_invalid_id_const_ swigToEnum(int swigValue) {
+    pjsua_invalid_id_const_[] swigValues = pjsua_invalid_id_const_.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_invalid_id_const_ swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_invalid_id_const_.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_invalid_id_const_() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_invalid_id_const_(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_invalid_id_const_(pjsua_invalid_id_const_ swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_ipv6_use.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_ipv6_use.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_ipv6_use.java	(working copy)
@@ -0,0 +1,52 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_ipv6_use {
+  PJSUA_IPV6_DISABLED,
+  PJSUA_IPV6_ENABLED;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_ipv6_use swigToEnum(int swigValue) {
+    pjsua_ipv6_use[] swigValues = pjsua_ipv6_use.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_ipv6_use swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_ipv6_use.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_ipv6_use() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_ipv6_use(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_ipv6_use(pjsua_ipv6_use swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_logging_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_logging_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_logging_config.java	(working copy)
@@ -0,0 +1,100 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_logging_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_logging_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_logging_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_logging_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setMsg_logging(int value) {
+    pjsuaJNI.pjsua_logging_config_msg_logging_set(swigCPtr, this, value);
+  }
+
+  public int getMsg_logging() {
+    return pjsuaJNI.pjsua_logging_config_msg_logging_get(swigCPtr, this);
+  }
+
+  public void setLevel(long value) {
+    pjsuaJNI.pjsua_logging_config_level_set(swigCPtr, this, value);
+  }
+
+  public long getLevel() {
+    return pjsuaJNI.pjsua_logging_config_level_get(swigCPtr, this);
+  }
+
+  public void setConsole_level(long value) {
+    pjsuaJNI.pjsua_logging_config_console_level_set(swigCPtr, this, value);
+  }
+
+  public long getConsole_level() {
+    return pjsuaJNI.pjsua_logging_config_console_level_get(swigCPtr, this);
+  }
+
+  public void setDecor(long value) {
+    pjsuaJNI.pjsua_logging_config_decor_set(swigCPtr, this, value);
+  }
+
+  public long getDecor() {
+    return pjsuaJNI.pjsua_logging_config_decor_get(swigCPtr, this);
+  }
+
+  public void setLog_filename(pj_str_t value) {
+    pjsuaJNI.pjsua_logging_config_log_filename_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getLog_filename() {
+    long cPtr = pjsuaJNI.pjsua_logging_config_log_filename_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setLog_file_flags(long value) {
+    pjsuaJNI.pjsua_logging_config_log_file_flags_set(swigCPtr, this, value);
+  }
+
+  public long getLog_file_flags() {
+    return pjsuaJNI.pjsua_logging_config_log_file_flags_get(swigCPtr, this);
+  }
+
+  public void setCb(SWIGTYPE_p_f_int_p_q_const__char_int__void value) {
+    pjsuaJNI.pjsua_logging_config_cb_set(swigCPtr, this, SWIGTYPE_p_f_int_p_q_const__char_int__void.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_f_int_p_q_const__char_int__void getCb() {
+    long cPtr = pjsuaJNI.pjsua_logging_config_cb_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_f_int_p_q_const__char_int__void(cPtr, false);
+  }
+
+  public pjsua_logging_config() {
+    this(pjsuaJNI.new_pjsua_logging_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_med_tp_st.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_med_tp_st.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_med_tp_st.java	(working copy)
@@ -0,0 +1,56 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_med_tp_st {
+  PJSUA_MED_TP_NULL,
+  PJSUA_MED_TP_CREATING,
+  PJSUA_MED_TP_IDLE,
+  PJSUA_MED_TP_INIT,
+  PJSUA_MED_TP_RUNNING,
+  PJSUA_MED_TP_DISABLED;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_med_tp_st swigToEnum(int swigValue) {
+    pjsua_med_tp_st[] swigValues = pjsua_med_tp_st.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_med_tp_st swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_med_tp_st.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_med_tp_st() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_med_tp_st(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_med_tp_st(pjsua_med_tp_st swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_med_tp_state_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_med_tp_state_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_med_tp_state_info.java	(working copy)
@@ -0,0 +1,82 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_med_tp_state_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_med_tp_state_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_med_tp_state_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_med_tp_state_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setMed_idx(long value) {
+    pjsuaJNI.pjsua_med_tp_state_info_med_idx_set(swigCPtr, this, value);
+  }
+
+  public long getMed_idx() {
+    return pjsuaJNI.pjsua_med_tp_state_info_med_idx_get(swigCPtr, this);
+  }
+
+  public void setState(pjsua_med_tp_st value) {
+    pjsuaJNI.pjsua_med_tp_state_info_state_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsua_med_tp_st getState() {
+    return pjsua_med_tp_st.swigToEnum(pjsuaJNI.pjsua_med_tp_state_info_state_get(swigCPtr, this));
+  }
+
+  public void setStatus(int value) {
+    pjsuaJNI.pjsua_med_tp_state_info_status_set(swigCPtr, this, value);
+  }
+
+  public int getStatus() {
+    return pjsuaJNI.pjsua_med_tp_state_info_status_get(swigCPtr, this);
+  }
+
+  public void setSip_err_code(int value) {
+    pjsuaJNI.pjsua_med_tp_state_info_sip_err_code_set(swigCPtr, this, value);
+  }
+
+  public int getSip_err_code() {
+    return pjsuaJNI.pjsua_med_tp_state_info_sip_err_code_get(swigCPtr, this);
+  }
+
+  public void setExt_info(byte[] value) {
+    pjsuaJNI.pjsua_med_tp_state_info_ext_info_set(swigCPtr, this, value);
+  }
+
+  public byte[] getExt_info() {
+	return pjsuaJNI.pjsua_med_tp_state_info_ext_info_get(swigCPtr, this);
+}
+
+  public pjsua_med_tp_state_info() {
+    this(pjsuaJNI.new_pjsua_med_tp_state_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_media_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_media_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_media_config.java	(working copy)
@@ -0,0 +1,316 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_media_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_media_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_media_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_media_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setClock_rate(long value) {
+    pjsuaJNI.pjsua_media_config_clock_rate_set(swigCPtr, this, value);
+  }
+
+  public long getClock_rate() {
+    return pjsuaJNI.pjsua_media_config_clock_rate_get(swigCPtr, this);
+  }
+
+  public void setSnd_clock_rate(long value) {
+    pjsuaJNI.pjsua_media_config_snd_clock_rate_set(swigCPtr, this, value);
+  }
+
+  public long getSnd_clock_rate() {
+    return pjsuaJNI.pjsua_media_config_snd_clock_rate_get(swigCPtr, this);
+  }
+
+  public void setChannel_count(long value) {
+    pjsuaJNI.pjsua_media_config_channel_count_set(swigCPtr, this, value);
+  }
+
+  public long getChannel_count() {
+    return pjsuaJNI.pjsua_media_config_channel_count_get(swigCPtr, this);
+  }
+
+  public void setAudio_frame_ptime(long value) {
+    pjsuaJNI.pjsua_media_config_audio_frame_ptime_set(swigCPtr, this, value);
+  }
+
+  public long getAudio_frame_ptime() {
+    return pjsuaJNI.pjsua_media_config_audio_frame_ptime_get(swigCPtr, this);
+  }
+
+  public void setMax_media_ports(long value) {
+    pjsuaJNI.pjsua_media_config_max_media_ports_set(swigCPtr, this, value);
+  }
+
+  public long getMax_media_ports() {
+    return pjsuaJNI.pjsua_media_config_max_media_ports_get(swigCPtr, this);
+  }
+
+  public void setHas_ioqueue(int value) {
+    pjsuaJNI.pjsua_media_config_has_ioqueue_set(swigCPtr, this, value);
+  }
+
+  public int getHas_ioqueue() {
+    return pjsuaJNI.pjsua_media_config_has_ioqueue_get(swigCPtr, this);
+  }
+
+  public void setThread_cnt(long value) {
+    pjsuaJNI.pjsua_media_config_thread_cnt_set(swigCPtr, this, value);
+  }
+
+  public long getThread_cnt() {
+    return pjsuaJNI.pjsua_media_config_thread_cnt_get(swigCPtr, this);
+  }
+
+  public void setQuality(long value) {
+    pjsuaJNI.pjsua_media_config_quality_set(swigCPtr, this, value);
+  }
+
+  public long getQuality() {
+    return pjsuaJNI.pjsua_media_config_quality_get(swigCPtr, this);
+  }
+
+  public void setPtime(long value) {
+    pjsuaJNI.pjsua_media_config_ptime_set(swigCPtr, this, value);
+  }
+
+  public long getPtime() {
+    return pjsuaJNI.pjsua_media_config_ptime_get(swigCPtr, this);
+  }
+
+  public void setNo_vad(int value) {
+    pjsuaJNI.pjsua_media_config_no_vad_set(swigCPtr, this, value);
+  }
+
+  public int getNo_vad() {
+    return pjsuaJNI.pjsua_media_config_no_vad_get(swigCPtr, this);
+  }
+
+  public void setIlbc_mode(long value) {
+    pjsuaJNI.pjsua_media_config_ilbc_mode_set(swigCPtr, this, value);
+  }
+
+  public long getIlbc_mode() {
+    return pjsuaJNI.pjsua_media_config_ilbc_mode_get(swigCPtr, this);
+  }
+
+  public void setTx_drop_pct(long value) {
+    pjsuaJNI.pjsua_media_config_tx_drop_pct_set(swigCPtr, this, value);
+  }
+
+  public long getTx_drop_pct() {
+    return pjsuaJNI.pjsua_media_config_tx_drop_pct_get(swigCPtr, this);
+  }
+
+  public void setRx_drop_pct(long value) {
+    pjsuaJNI.pjsua_media_config_rx_drop_pct_set(swigCPtr, this, value);
+  }
+
+  public long getRx_drop_pct() {
+    return pjsuaJNI.pjsua_media_config_rx_drop_pct_get(swigCPtr, this);
+  }
+
+  public void setEc_options(long value) {
+    pjsuaJNI.pjsua_media_config_ec_options_set(swigCPtr, this, value);
+  }
+
+  public long getEc_options() {
+    return pjsuaJNI.pjsua_media_config_ec_options_get(swigCPtr, this);
+  }
+
+  public void setEc_tail_len(long value) {
+    pjsuaJNI.pjsua_media_config_ec_tail_len_set(swigCPtr, this, value);
+  }
+
+  public long getEc_tail_len() {
+    return pjsuaJNI.pjsua_media_config_ec_tail_len_get(swigCPtr, this);
+  }
+
+  public void setSnd_rec_latency(long value) {
+    pjsuaJNI.pjsua_media_config_snd_rec_latency_set(swigCPtr, this, value);
+  }
+
+  public long getSnd_rec_latency() {
+    return pjsuaJNI.pjsua_media_config_snd_rec_latency_get(swigCPtr, this);
+  }
+
+  public void setSnd_play_latency(long value) {
+    pjsuaJNI.pjsua_media_config_snd_play_latency_set(swigCPtr, this, value);
+  }
+
+  public long getSnd_play_latency() {
+    return pjsuaJNI.pjsua_media_config_snd_play_latency_get(swigCPtr, this);
+  }
+
+  public void setJb_init(int value) {
+    pjsuaJNI.pjsua_media_config_jb_init_set(swigCPtr, this, value);
+  }
+
+  public int getJb_init() {
+    return pjsuaJNI.pjsua_media_config_jb_init_get(swigCPtr, this);
+  }
+
+  public void setJb_min_pre(int value) {
+    pjsuaJNI.pjsua_media_config_jb_min_pre_set(swigCPtr, this, value);
+  }
+
+  public int getJb_min_pre() {
+    return pjsuaJNI.pjsua_media_config_jb_min_pre_get(swigCPtr, this);
+  }
+
+  public void setJb_max_pre(int value) {
+    pjsuaJNI.pjsua_media_config_jb_max_pre_set(swigCPtr, this, value);
+  }
+
+  public int getJb_max_pre() {
+    return pjsuaJNI.pjsua_media_config_jb_max_pre_get(swigCPtr, this);
+  }
+
+  public void setJb_max(int value) {
+    pjsuaJNI.pjsua_media_config_jb_max_set(swigCPtr, this, value);
+  }
+
+  public int getJb_max() {
+    return pjsuaJNI.pjsua_media_config_jb_max_get(swigCPtr, this);
+  }
+
+  public void setEnable_ice(int value) {
+    pjsuaJNI.pjsua_media_config_enable_ice_set(swigCPtr, this, value);
+  }
+
+  public int getEnable_ice() {
+    return pjsuaJNI.pjsua_media_config_enable_ice_get(swigCPtr, this);
+  }
+
+  public void setIce_max_host_cands(int value) {
+    pjsuaJNI.pjsua_media_config_ice_max_host_cands_set(swigCPtr, this, value);
+  }
+
+  public int getIce_max_host_cands() {
+    return pjsuaJNI.pjsua_media_config_ice_max_host_cands_get(swigCPtr, this);
+  }
+
+  public void setIce_opt(pj_ice_sess_options value) {
+    pjsuaJNI.pjsua_media_config_ice_opt_set(swigCPtr, this, pj_ice_sess_options.getCPtr(value), value);
+  }
+
+  public pj_ice_sess_options getIce_opt() {
+    long cPtr = pjsuaJNI.pjsua_media_config_ice_opt_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_ice_sess_options(cPtr, false);
+  }
+
+  public void setIce_no_rtcp(int value) {
+    pjsuaJNI.pjsua_media_config_ice_no_rtcp_set(swigCPtr, this, value);
+  }
+
+  public int getIce_no_rtcp() {
+    return pjsuaJNI.pjsua_media_config_ice_no_rtcp_get(swigCPtr, this);
+  }
+
+  public void setIce_always_update(int value) {
+    pjsuaJNI.pjsua_media_config_ice_always_update_set(swigCPtr, this, value);
+  }
+
+  public int getIce_always_update() {
+    return pjsuaJNI.pjsua_media_config_ice_always_update_get(swigCPtr, this);
+  }
+
+  public void setEnable_turn(int value) {
+    pjsuaJNI.pjsua_media_config_enable_turn_set(swigCPtr, this, value);
+  }
+
+  public int getEnable_turn() {
+    return pjsuaJNI.pjsua_media_config_enable_turn_get(swigCPtr, this);
+  }
+
+  public void setTurn_server(pj_str_t value) {
+    pjsuaJNI.pjsua_media_config_turn_server_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getTurn_server() {
+    long cPtr = pjsuaJNI.pjsua_media_config_turn_server_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setTurn_conn_type(pj_turn_tp_type value) {
+    pjsuaJNI.pjsua_media_config_turn_conn_type_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pj_turn_tp_type getTurn_conn_type() {
+    return pj_turn_tp_type.swigToEnum(pjsuaJNI.pjsua_media_config_turn_conn_type_get(swigCPtr, this));
+  }
+
+  public void setTurn_auth_cred(SWIGTYPE_p_pj_stun_auth_cred value) {
+    pjsuaJNI.pjsua_media_config_turn_auth_cred_set(swigCPtr, this, SWIGTYPE_p_pj_stun_auth_cred.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_stun_auth_cred getTurn_auth_cred() {
+    return new SWIGTYPE_p_pj_stun_auth_cred(pjsuaJNI.pjsua_media_config_turn_auth_cred_get(swigCPtr, this), true);
+  }
+
+  public void setSnd_auto_close_time(int value) {
+    pjsuaJNI.pjsua_media_config_snd_auto_close_time_set(swigCPtr, this, value);
+  }
+
+  public int getSnd_auto_close_time() {
+    return pjsuaJNI.pjsua_media_config_snd_auto_close_time_get(swigCPtr, this);
+  }
+
+  public void setVid_preview_enable_native(int value) {
+    pjsuaJNI.pjsua_media_config_vid_preview_enable_native_set(swigCPtr, this, value);
+  }
+
+  public int getVid_preview_enable_native() {
+    return pjsuaJNI.pjsua_media_config_vid_preview_enable_native_get(swigCPtr, this);
+  }
+
+  public void setNo_smart_media_update(int value) {
+    pjsuaJNI.pjsua_media_config_no_smart_media_update_set(swigCPtr, this, value);
+  }
+
+  public int getNo_smart_media_update() {
+    return pjsuaJNI.pjsua_media_config_no_smart_media_update_get(swigCPtr, this);
+  }
+
+  public void setNo_rtcp_sdes_bye(int value) {
+    pjsuaJNI.pjsua_media_config_no_rtcp_sdes_bye_set(swigCPtr, this, value);
+  }
+
+  public int getNo_rtcp_sdes_bye() {
+    return pjsuaJNI.pjsua_media_config_no_rtcp_sdes_bye_get(swigCPtr, this);
+  }
+
+  public pjsua_media_config() {
+    this(pjsuaJNI.new_pjsua_media_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_media_transport.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_media_transport.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_media_transport.java	(working copy)
@@ -0,0 +1,59 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_media_transport {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_media_transport(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_media_transport obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_media_transport(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setSkinfo(SWIGTYPE_p_pjmedia_sock_info value) {
+    pjsuaJNI.pjsua_media_transport_skinfo_set(swigCPtr, this, SWIGTYPE_p_pjmedia_sock_info.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_sock_info getSkinfo() {
+    return new SWIGTYPE_p_pjmedia_sock_info(pjsuaJNI.pjsua_media_transport_skinfo_get(swigCPtr, this), true);
+  }
+
+  public void setTransport(SWIGTYPE_p_pjmedia_transport value) {
+    pjsuaJNI.pjsua_media_transport_transport_set(swigCPtr, this, SWIGTYPE_p_pjmedia_transport.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_transport getTransport() {
+    long cPtr = pjsuaJNI.pjsua_media_transport_transport_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pjmedia_transport(cPtr, false);
+  }
+
+  public pjsua_media_transport() {
+    this(pjsuaJNI.new_pjsua_media_transport(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_msg_data.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_msg_data.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_msg_data.java	(working copy)
@@ -0,0 +1,93 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_msg_data {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_msg_data(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_msg_data obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_msg_data(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setTarget_uri(pj_str_t value) {
+    pjsuaJNI.pjsua_msg_data_target_uri_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getTarget_uri() {
+    long cPtr = pjsuaJNI.pjsua_msg_data_target_uri_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setHdr_list(SWIGTYPE_p_pjsip_hdr value) {
+    pjsuaJNI.pjsua_msg_data_hdr_list_set(swigCPtr, this, SWIGTYPE_p_pjsip_hdr.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_hdr getHdr_list() {
+    return new SWIGTYPE_p_pjsip_hdr(pjsuaJNI.pjsua_msg_data_hdr_list_get(swigCPtr, this), true);
+  }
+
+  public void setContent_type(pj_str_t value) {
+    pjsuaJNI.pjsua_msg_data_content_type_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getContent_type() {
+    long cPtr = pjsuaJNI.pjsua_msg_data_content_type_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setMsg_body(pj_str_t value) {
+    pjsuaJNI.pjsua_msg_data_msg_body_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getMsg_body() {
+    long cPtr = pjsuaJNI.pjsua_msg_data_msg_body_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setMultipart_ctype(SWIGTYPE_p_pjsip_media_type value) {
+    pjsuaJNI.pjsua_msg_data_multipart_ctype_set(swigCPtr, this, SWIGTYPE_p_pjsip_media_type.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_media_type getMultipart_ctype() {
+    return new SWIGTYPE_p_pjsip_media_type(pjsuaJNI.pjsua_msg_data_multipart_ctype_get(swigCPtr, this), true);
+  }
+
+  public void setMultipart_parts(SWIGTYPE_p_pjsip_multipart_part value) {
+    pjsuaJNI.pjsua_msg_data_multipart_parts_set(swigCPtr, this, SWIGTYPE_p_pjsip_multipart_part.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_multipart_part getMultipart_parts() {
+    return new SWIGTYPE_p_pjsip_multipart_part(pjsuaJNI.pjsua_msg_data_multipart_parts_get(swigCPtr, this), true);
+  }
+
+  public pjsua_msg_data() {
+    this(pjsuaJNI.new_pjsua_msg_data(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_mwi_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_mwi_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_mwi_info.java	(working copy)
@@ -0,0 +1,60 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_mwi_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_mwi_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_mwi_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_mwi_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setEvsub(SWIGTYPE_p_pjsip_evsub value) {
+    pjsuaJNI.pjsua_mwi_info_evsub_set(swigCPtr, this, SWIGTYPE_p_pjsip_evsub.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_evsub getEvsub() {
+    long cPtr = pjsuaJNI.pjsua_mwi_info_evsub_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pjsip_evsub(cPtr, false);
+  }
+
+  public void setRdata(SWIGTYPE_p_pjsip_rx_data value) {
+    pjsuaJNI.pjsua_mwi_info_rdata_set(swigCPtr, this, SWIGTYPE_p_pjsip_rx_data.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_rx_data getRdata() {
+    long cPtr = pjsuaJNI.pjsua_mwi_info_rdata_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pjsip_rx_data(cPtr, false);
+  }
+
+  public pjsua_mwi_info() {
+    this(pjsuaJNI.new_pjsua_mwi_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_reg_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_reg_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_reg_info.java	(working copy)
@@ -0,0 +1,51 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_reg_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_reg_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_reg_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_reg_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setCbparam(SWIGTYPE_p_pjsip_regc_cbparam value) {
+    pjsuaJNI.pjsua_reg_info_cbparam_set(swigCPtr, this, SWIGTYPE_p_pjsip_regc_cbparam.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_regc_cbparam getCbparam() {
+    long cPtr = pjsuaJNI.pjsua_reg_info_cbparam_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_pjsip_regc_cbparam(cPtr, false);
+  }
+
+  public pjsua_reg_info() {
+    this(pjsuaJNI.new_pjsua_reg_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_sip_timer_use.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_sip_timer_use.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_sip_timer_use.java	(working copy)
@@ -0,0 +1,54 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_sip_timer_use {
+  PJSUA_SIP_TIMER_INACTIVE,
+  PJSUA_SIP_TIMER_OPTIONAL,
+  PJSUA_SIP_TIMER_REQUIRED,
+  PJSUA_SIP_TIMER_ALWAYS;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_sip_timer_use swigToEnum(int swigValue) {
+    pjsua_sip_timer_use[] swigValues = pjsua_sip_timer_use.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_sip_timer_use swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_sip_timer_use.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_sip_timer_use() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_sip_timer_use(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_sip_timer_use(pjsua_sip_timer_use swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_state.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_state.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_state.java	(working copy)
@@ -0,0 +1,56 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_state {
+  PJSUA_STATE_NULL,
+  PJSUA_STATE_CREATED,
+  PJSUA_STATE_INIT,
+  PJSUA_STATE_STARTING,
+  PJSUA_STATE_RUNNING,
+  PJSUA_STATE_CLOSING;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_state swigToEnum(int swigValue) {
+    pjsua_state[] swigValues = pjsua_state.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_state swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_state.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_state() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_state(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_state(pjsua_state swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_stream_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_stream_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_stream_info.java	(working copy)
@@ -0,0 +1,50 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_stream_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_stream_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_stream_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_stream_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setType(SWIGTYPE_p_pjmedia_type value) {
+    pjsuaJNI.pjsua_stream_info_type_set(swigCPtr, this, SWIGTYPE_p_pjmedia_type.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_type getType() {
+    return new SWIGTYPE_p_pjmedia_type(pjsuaJNI.pjsua_stream_info_type_get(swigCPtr, this), true);
+  }
+
+  public pjsua_stream_info() {
+    this(pjsuaJNI.new_pjsua_stream_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_stream_stat.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_stream_stat.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_stream_stat.java	(working copy)
@@ -0,0 +1,58 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_stream_stat {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_stream_stat(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_stream_stat obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_stream_stat(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setRtcp(SWIGTYPE_p_pjmedia_rtcp_stat value) {
+    pjsuaJNI.pjsua_stream_stat_rtcp_set(swigCPtr, this, SWIGTYPE_p_pjmedia_rtcp_stat.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_rtcp_stat getRtcp() {
+    return new SWIGTYPE_p_pjmedia_rtcp_stat(pjsuaJNI.pjsua_stream_stat_rtcp_get(swigCPtr, this), true);
+  }
+
+  public void setJbuf(SWIGTYPE_p_pjmedia_jb_state value) {
+    pjsuaJNI.pjsua_stream_stat_jbuf_set(swigCPtr, this, SWIGTYPE_p_pjmedia_jb_state.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_jb_state getJbuf() {
+    return new SWIGTYPE_p_pjmedia_jb_state(pjsuaJNI.pjsua_stream_stat_jbuf_get(swigCPtr, this), true);
+  }
+
+  public pjsua_stream_stat() {
+    this(pjsuaJNI.new_pjsua_stream_stat(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_stun_use.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_stun_use.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_stun_use.java	(working copy)
@@ -0,0 +1,52 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_stun_use {
+  PJSUA_STUN_USE_DEFAULT,
+  PJSUA_STUN_USE_DISABLED;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_stun_use swigToEnum(int swigValue) {
+    pjsua_stun_use[] swigValues = pjsua_stun_use.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_stun_use swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_stun_use.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_stun_use() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_stun_use(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_stun_use(pjsua_stun_use swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_transport_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_transport_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_transport_config.java	(working copy)
@@ -0,0 +1,110 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_transport_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_transport_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_transport_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_transport_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setPort(long value) {
+    pjsuaJNI.pjsua_transport_config_port_set(swigCPtr, this, value);
+  }
+
+  public long getPort() {
+    return pjsuaJNI.pjsua_transport_config_port_get(swigCPtr, this);
+  }
+
+  public void setPort_range(long value) {
+    pjsuaJNI.pjsua_transport_config_port_range_set(swigCPtr, this, value);
+  }
+
+  public long getPort_range() {
+    return pjsuaJNI.pjsua_transport_config_port_range_get(swigCPtr, this);
+  }
+
+  public void setPublic_addr(pj_str_t value) {
+    pjsuaJNI.pjsua_transport_config_public_addr_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getPublic_addr() {
+    long cPtr = pjsuaJNI.pjsua_transport_config_public_addr_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setBound_addr(pj_str_t value) {
+    pjsuaJNI.pjsua_transport_config_bound_addr_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getBound_addr() {
+    long cPtr = pjsuaJNI.pjsua_transport_config_bound_addr_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setTls_setting(pjsip_tls_setting value) {
+    pjsuaJNI.pjsua_transport_config_tls_setting_set(swigCPtr, this, pjsip_tls_setting.getCPtr(value), value);
+  }
+
+  public pjsip_tls_setting getTls_setting() {
+    long cPtr = pjsuaJNI.pjsua_transport_config_tls_setting_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pjsip_tls_setting(cPtr, false);
+  }
+
+  public void setQos_type(pj_qos_type value) {
+    pjsuaJNI.pjsua_transport_config_qos_type_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pj_qos_type getQos_type() {
+    return pj_qos_type.swigToEnum(pjsuaJNI.pjsua_transport_config_qos_type_get(swigCPtr, this));
+  }
+
+  public void setQos_params(pj_qos_params value) {
+    pjsuaJNI.pjsua_transport_config_qos_params_set(swigCPtr, this, pj_qos_params.getCPtr(value), value);
+  }
+
+  public pj_qos_params getQos_params() {
+    long cPtr = pjsuaJNI.pjsua_transport_config_qos_params_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_qos_params(cPtr, false);
+  }
+
+  public void setSockopt_params(SWIGTYPE_p_pj_sockopt_params value) {
+    pjsuaJNI.pjsua_transport_config_sockopt_params_set(swigCPtr, this, SWIGTYPE_p_pj_sockopt_params.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_sockopt_params getSockopt_params() {
+    return new SWIGTYPE_p_pj_sockopt_params(pjsuaJNI.pjsua_transport_config_sockopt_params_get(swigCPtr, this), true);
+  }
+
+  public pjsua_transport_config() {
+    this(pjsuaJNI.new_pjsua_transport_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_transport_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_transport_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_transport_info.java	(working copy)
@@ -0,0 +1,116 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_transport_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_transport_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_transport_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_transport_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setId(int value) {
+    pjsuaJNI.pjsua_transport_info_id_set(swigCPtr, this, value);
+  }
+
+  public int getId() {
+    return pjsuaJNI.pjsua_transport_info_id_get(swigCPtr, this);
+  }
+
+  public void setType(pjsip_transport_type_e value) {
+    pjsuaJNI.pjsua_transport_info_type_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pjsip_transport_type_e getType() {
+    return pjsip_transport_type_e.swigToEnum(pjsuaJNI.pjsua_transport_info_type_get(swigCPtr, this));
+  }
+
+  public void setType_name(pj_str_t value) {
+    pjsuaJNI.pjsua_transport_info_type_name_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getType_name() {
+    long cPtr = pjsuaJNI.pjsua_transport_info_type_name_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setInfo(pj_str_t value) {
+    pjsuaJNI.pjsua_transport_info_info_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getInfo() {
+    long cPtr = pjsuaJNI.pjsua_transport_info_info_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setFlag(long value) {
+    pjsuaJNI.pjsua_transport_info_flag_set(swigCPtr, this, value);
+  }
+
+  public long getFlag() {
+    return pjsuaJNI.pjsua_transport_info_flag_get(swigCPtr, this);
+  }
+
+  public void setAddr_len(long value) {
+    pjsuaJNI.pjsua_transport_info_addr_len_set(swigCPtr, this, value);
+  }
+
+  public long getAddr_len() {
+    return pjsuaJNI.pjsua_transport_info_addr_len_get(swigCPtr, this);
+  }
+
+  public void setLocal_addr(SWIGTYPE_p_pj_sockaddr value) {
+    pjsuaJNI.pjsua_transport_info_local_addr_set(swigCPtr, this, SWIGTYPE_p_pj_sockaddr.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_sockaddr getLocal_addr() {
+    return new SWIGTYPE_p_pj_sockaddr(pjsuaJNI.pjsua_transport_info_local_addr_get(swigCPtr, this), true);
+  }
+
+  public void setLocal_name(SWIGTYPE_p_pjsip_host_port value) {
+    pjsuaJNI.pjsua_transport_info_local_name_set(swigCPtr, this, SWIGTYPE_p_pjsip_host_port.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjsip_host_port getLocal_name() {
+    return new SWIGTYPE_p_pjsip_host_port(pjsuaJNI.pjsua_transport_info_local_name_get(swigCPtr, this), true);
+  }
+
+  public void setUsage_count(long value) {
+    pjsuaJNI.pjsua_transport_info_usage_count_set(swigCPtr, this, value);
+  }
+
+  public long getUsage_count() {
+    return pjsuaJNI.pjsua_transport_info_usage_count_get(swigCPtr, this);
+  }
+
+  public pjsua_transport_info() {
+    this(pjsuaJNI.new_pjsua_transport_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_turn_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_turn_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_turn_config.java	(working copy)
@@ -0,0 +1,75 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_turn_config {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_turn_config(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_turn_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_turn_config(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setEnable_turn(int value) {
+    pjsuaJNI.pjsua_turn_config_enable_turn_set(swigCPtr, this, value);
+  }
+
+  public int getEnable_turn() {
+    return pjsuaJNI.pjsua_turn_config_enable_turn_get(swigCPtr, this);
+  }
+
+  public void setTurn_server(pj_str_t value) {
+    pjsuaJNI.pjsua_turn_config_turn_server_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getTurn_server() {
+    long cPtr = pjsuaJNI.pjsua_turn_config_turn_server_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setTurn_conn_type(pj_turn_tp_type value) {
+    pjsuaJNI.pjsua_turn_config_turn_conn_type_set(swigCPtr, this, value.swigValue());
+  }
+
+  public pj_turn_tp_type getTurn_conn_type() {
+    return pj_turn_tp_type.swigToEnum(pjsuaJNI.pjsua_turn_config_turn_conn_type_get(swigCPtr, this));
+  }
+
+  public void setTurn_auth_cred(SWIGTYPE_p_pj_stun_auth_cred value) {
+    pjsuaJNI.pjsua_turn_config_turn_auth_cred_set(swigCPtr, this, SWIGTYPE_p_pj_stun_auth_cred.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pj_stun_auth_cred getTurn_auth_cred() {
+    return new SWIGTYPE_p_pj_stun_auth_cred(pjsuaJNI.pjsua_turn_config_turn_auth_cred_get(swigCPtr, this), true);
+  }
+
+  public pjsua_turn_config() {
+    this(pjsuaJNI.new_pjsua_turn_config(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_turn_config_use.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_turn_config_use.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_turn_config_use.java	(working copy)
@@ -0,0 +1,52 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_turn_config_use {
+  PJSUA_TURN_CONFIG_USE_DEFAULT,
+  PJSUA_TURN_CONFIG_USE_CUSTOM;
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_turn_config_use swigToEnum(int swigValue) {
+    pjsua_turn_config_use[] swigValues = pjsua_turn_config_use.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_turn_config_use swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_turn_config_use.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_turn_config_use() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_turn_config_use(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_turn_config_use(pjsua_turn_config_use swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_vid_preview_param.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_vid_preview_param.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_vid_preview_param.java	(working copy)
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_vid_preview_param {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_vid_preview_param(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_vid_preview_param obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_vid_preview_param(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setRend_id(SWIGTYPE_p_pjmedia_vid_dev_index value) {
+    pjsuaJNI.pjsua_vid_preview_param_rend_id_set(swigCPtr, this, SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_vid_dev_index getRend_id() {
+    return new SWIGTYPE_p_pjmedia_vid_dev_index(pjsuaJNI.pjsua_vid_preview_param_rend_id_get(swigCPtr, this), true);
+  }
+
+  public void setShow(int value) {
+    pjsuaJNI.pjsua_vid_preview_param_show_set(swigCPtr, this, value);
+  }
+
+  public int getShow() {
+    return pjsuaJNI.pjsua_vid_preview_param_show_get(swigCPtr, this);
+  }
+
+  public void setWnd_flags(long value) {
+    pjsuaJNI.pjsua_vid_preview_param_wnd_flags_set(swigCPtr, this, value);
+  }
+
+  public long getWnd_flags() {
+    return pjsuaJNI.pjsua_vid_preview_param_wnd_flags_get(swigCPtr, this);
+  }
+
+  public void setFormat(SWIGTYPE_p_pjmedia_format value) {
+    pjsuaJNI.pjsua_vid_preview_param_format_set(swigCPtr, this, SWIGTYPE_p_pjmedia_format.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_format getFormat() {
+    return new SWIGTYPE_p_pjmedia_format(pjsuaJNI.pjsua_vid_preview_param_format_get(swigCPtr, this), true);
+  }
+
+  public pjsua_vid_preview_param() {
+    this(pjsuaJNI.new_pjsua_vid_preview_param(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_vid_req_keyframe_method.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_vid_req_keyframe_method.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_vid_req_keyframe_method.java	(working copy)
@@ -0,0 +1,52 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public enum pjsua_vid_req_keyframe_method {
+  PJSUA_VID_REQ_KEYFRAME_SIP_INFO(pjsuaJNI.PJSUA_VID_REQ_KEYFRAME_SIP_INFO_get()),
+  PJSUA_VID_REQ_KEYFRAME_RTCP_PLI(pjsuaJNI.PJSUA_VID_REQ_KEYFRAME_RTCP_PLI_get());
+
+  public final int swigValue() {
+    return swigValue;
+  }
+
+  public static pjsua_vid_req_keyframe_method swigToEnum(int swigValue) {
+    pjsua_vid_req_keyframe_method[] swigValues = pjsua_vid_req_keyframe_method.class.getEnumConstants();
+    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
+      return swigValues[swigValue];
+    for (pjsua_vid_req_keyframe_method swigEnum : swigValues)
+      if (swigEnum.swigValue == swigValue)
+        return swigEnum;
+    throw new IllegalArgumentException("No enum " + pjsua_vid_req_keyframe_method.class + " with value " + swigValue);
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_vid_req_keyframe_method() {
+    this.swigValue = SwigNext.next++;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_vid_req_keyframe_method(int swigValue) {
+    this.swigValue = swigValue;
+    SwigNext.next = swigValue+1;
+  }
+
+  @SuppressWarnings("unused")
+  private pjsua_vid_req_keyframe_method(pjsua_vid_req_keyframe_method swigEnum) {
+    this.swigValue = swigEnum.swigValue;
+    SwigNext.next = this.swigValue+1;
+  }
+
+  private final int swigValue;
+
+  private static class SwigNext {
+    private static int next = 0;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/pjsua_vid_win_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsua_vid_win_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsua_vid_win_info.java	(working copy)
@@ -0,0 +1,90 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsua_vid_win_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected pjsua_vid_win_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(pjsua_vid_win_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_pjsua_vid_win_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setIs_native(int value) {
+    pjsuaJNI.pjsua_vid_win_info_is_native_set(swigCPtr, this, value);
+  }
+
+  public int getIs_native() {
+    return pjsuaJNI.pjsua_vid_win_info_is_native_get(swigCPtr, this);
+  }
+
+  public void setHwnd(SWIGTYPE_p_pjmedia_vid_dev_hwnd value) {
+    pjsuaJNI.pjsua_vid_win_info_hwnd_set(swigCPtr, this, SWIGTYPE_p_pjmedia_vid_dev_hwnd.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_vid_dev_hwnd getHwnd() {
+    return new SWIGTYPE_p_pjmedia_vid_dev_hwnd(pjsuaJNI.pjsua_vid_win_info_hwnd_get(swigCPtr, this), true);
+  }
+
+  public void setRdr_dev(SWIGTYPE_p_pjmedia_vid_dev_index value) {
+    pjsuaJNI.pjsua_vid_win_info_rdr_dev_set(swigCPtr, this, SWIGTYPE_p_pjmedia_vid_dev_index.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_vid_dev_index getRdr_dev() {
+    return new SWIGTYPE_p_pjmedia_vid_dev_index(pjsuaJNI.pjsua_vid_win_info_rdr_dev_get(swigCPtr, this), true);
+  }
+
+  public void setShow(int value) {
+    pjsuaJNI.pjsua_vid_win_info_show_set(swigCPtr, this, value);
+  }
+
+  public int getShow() {
+    return pjsuaJNI.pjsua_vid_win_info_show_get(swigCPtr, this);
+  }
+
+  public void setPos(SWIGTYPE_p_pjmedia_coord value) {
+    pjsuaJNI.pjsua_vid_win_info_pos_set(swigCPtr, this, SWIGTYPE_p_pjmedia_coord.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_coord getPos() {
+    return new SWIGTYPE_p_pjmedia_coord(pjsuaJNI.pjsua_vid_win_info_pos_get(swigCPtr, this), true);
+  }
+
+  public void setSize(SWIGTYPE_p_pjmedia_rect_size value) {
+    pjsuaJNI.pjsua_vid_win_info_size_set(swigCPtr, this, SWIGTYPE_p_pjmedia_rect_size.getCPtr(value));
+  }
+
+  public SWIGTYPE_p_pjmedia_rect_size getSize() {
+    return new SWIGTYPE_p_pjmedia_rect_size(pjsuaJNI.pjsua_vid_win_info_size_get(swigCPtr, this), true);
+  }
+
+  public pjsua_vid_win_info() {
+    this(pjsuaJNI.new_pjsua_vid_win_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsuaConstants.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsuaConstants.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsuaConstants.java	(working copy)
@@ -0,0 +1,50 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public interface pjsuaConstants {
+  public final static pjsua_callback WRAPPER_CALLBACK_STRUCT = new pjsua_callback(pjsuaJNI.WRAPPER_CALLBACK_STRUCT_get(), false);
+  public final static int PJ_SUCCESS = pjsuaJNI.PJ_SUCCESS_get();
+  public final static int PJ_TRUE = pjsuaJNI.PJ_TRUE_get();
+  public final static int PJ_FALSE = pjsuaJNI.PJ_FALSE_get();
+  public final static int PJMEDIA_TONEGEN_LOOP = pjsuaJNI.PJMEDIA_TONEGEN_LOOP_get();
+  public final static int PJMEDIA_TONEGEN_NO_LOCK = pjsuaJNI.PJMEDIA_TONEGEN_NO_LOCK_get();
+
+  public final static int DISABLED_FOR_TICKET_1185 = pjsuaJNI.DISABLED_FOR_TICKET_1185_get();
+  public final static int PJSUA_ACC_MAX_PROXIES = pjsuaJNI.PJSUA_ACC_MAX_PROXIES_get();
+  public final static int PJSUA_DEFAULT_SRTP_SECURE_SIGNALING = pjsuaJNI.PJSUA_DEFAULT_SRTP_SECURE_SIGNALING_get();
+  public final static int PJSUA_ADD_ICE_TAGS = pjsuaJNI.PJSUA_ADD_ICE_TAGS_get();
+  public final static int PJSUA_ACQUIRE_CALL_TIMEOUT = pjsuaJNI.PJSUA_ACQUIRE_CALL_TIMEOUT_get();
+  public final static int PJSUA_HAS_VIDEO = pjsuaJNI.PJSUA_HAS_VIDEO_get();
+  public final static int PJSUA_VID_REQ_KEYFRAME_INTERVAL = pjsuaJNI.PJSUA_VID_REQ_KEYFRAME_INTERVAL_get();
+  public final static int PJSUA_MAX_ACC = pjsuaJNI.PJSUA_MAX_ACC_get();
+  public final static int PJSUA_REG_INTERVAL = pjsuaJNI.PJSUA_REG_INTERVAL_get();
+  public final static int PJSUA_UNREG_TIMEOUT = pjsuaJNI.PJSUA_UNREG_TIMEOUT_get();
+  public final static int PJSUA_DEFAULT_ACC_PRIORITY = pjsuaJNI.PJSUA_DEFAULT_ACC_PRIORITY_get();
+  public final static int PJSUA_UNPUBLISH_MAX_WAIT_TIME_MSEC = pjsuaJNI.PJSUA_UNPUBLISH_MAX_WAIT_TIME_MSEC_get();
+  public final static int PJSUA_REG_RETRY_INTERVAL = pjsuaJNI.PJSUA_REG_RETRY_INTERVAL_get();
+  public final static int PJSUA_REG_USE_OUTBOUND_PROXY = pjsuaJNI.PJSUA_REG_USE_OUTBOUND_PROXY_get();
+  public final static int PJSUA_REG_USE_ACC_PROXY = pjsuaJNI.PJSUA_REG_USE_ACC_PROXY_get();
+  public final static int PJSUA_MAX_CALLS = pjsuaJNI.PJSUA_MAX_CALLS_get();
+  public final static int PJSUA_MAX_VID_WINS = pjsuaJNI.PJSUA_MAX_VID_WINS_get();
+  public final static int PJSUA_XFER_NO_REQUIRE_REPLACES = pjsuaJNI.PJSUA_XFER_NO_REQUIRE_REPLACES_get();
+  public final static int PJSUA_MAX_BUDDIES = pjsuaJNI.PJSUA_MAX_BUDDIES_get();
+  public final static int PJSUA_PRES_TIMER = pjsuaJNI.PJSUA_PRES_TIMER_get();
+  public final static int PJSUA_MEDIA_HAS_PJMEDIA = pjsuaJNI.PJSUA_MEDIA_HAS_PJMEDIA_get();
+  public final static int PJSUA_THIRD_PARTY_STREAM_HAS_GET_INFO = pjsuaJNI.PJSUA_THIRD_PARTY_STREAM_HAS_GET_INFO_get();
+  public final static int PJSUA_THIRD_PARTY_STREAM_HAS_GET_STAT = pjsuaJNI.PJSUA_THIRD_PARTY_STREAM_HAS_GET_STAT_get();
+  public final static int PJSUA_MAX_CONF_PORTS = pjsuaJNI.PJSUA_MAX_CONF_PORTS_get();
+  public final static int PJSUA_DEFAULT_CLOCK_RATE = pjsuaJNI.PJSUA_DEFAULT_CLOCK_RATE_get();
+  public final static int PJSUA_DEFAULT_AUDIO_FRAME_PTIME = pjsuaJNI.PJSUA_DEFAULT_AUDIO_FRAME_PTIME_get();
+  public final static int PJSUA_DEFAULT_CODEC_QUALITY = pjsuaJNI.PJSUA_DEFAULT_CODEC_QUALITY_get();
+  public final static int PJSUA_DEFAULT_ILBC_MODE = pjsuaJNI.PJSUA_DEFAULT_ILBC_MODE_get();
+  public final static int PJSUA_DEFAULT_EC_TAIL_LEN = pjsuaJNI.PJSUA_DEFAULT_EC_TAIL_LEN_get();
+  public final static int PJSUA_MAX_PLAYERS = pjsuaJNI.PJSUA_MAX_PLAYERS_get();
+  public final static int PJSUA_MAX_RECORDERS = pjsuaJNI.PJSUA_MAX_RECORDERS_get();
+}
Index: CSipSimple/src/org/pjsip/pjsua/pjsuaJNI.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/pjsuaJNI.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/pjsuaJNI.java	(working copy)
@@ -0,0 +1,1492 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class pjsuaJNI {
+  public final static native long pj_str_copy(String jarg1);
+  public final static native long WRAPPER_CALLBACK_STRUCT_get();
+  public final static native void delete_Callback(long jarg1);
+  public final static native void Callback_on_call_state(long jarg1, Callback jarg1_, int jarg2, long jarg3, pjsip_event jarg3_);
+  public final static native void Callback_on_call_stateSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pjsip_event jarg3_);
+  public final static native void Callback_on_incoming_call(long jarg1, Callback jarg1_, int jarg2, int jarg3, long jarg4);
+  public final static native void Callback_on_incoming_callSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, int jarg3, long jarg4);
+  public final static native void Callback_on_call_tsx_state(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4, pjsip_event jarg4_);
+  public final static native void Callback_on_call_tsx_stateSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4, pjsip_event jarg4_);
+  public final static native void Callback_on_call_media_state(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_call_media_stateSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_call_sdp_created(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4, pj_pool_t jarg4_, long jarg5);
+  public final static native void Callback_on_call_sdp_createdSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4, pj_pool_t jarg4_, long jarg5);
+  public final static native void Callback_on_stream_created(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4, long jarg5);
+  public final static native void Callback_on_stream_createdSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4, long jarg5);
+  public final static native void Callback_on_stream_destroyed(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4);
+  public final static native void Callback_on_stream_destroyedSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4);
+  public final static native void Callback_on_dtmf_digit(long jarg1, Callback jarg1_, int jarg2, int jarg3);
+  public final static native void Callback_on_dtmf_digitSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, int jarg3);
+  public final static native void Callback_on_call_transfer_request(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4);
+  public final static native void Callback_on_call_transfer_requestSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4);
+  public final static native void Callback_on_call_transfer_status(long jarg1, Callback jarg1_, int jarg2, int jarg3, long jarg4, pj_str_t jarg4_, int jarg5, long jarg6);
+  public final static native void Callback_on_call_transfer_statusSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, int jarg3, long jarg4, pj_str_t jarg4_, int jarg5, long jarg6);
+  public final static native void Callback_on_call_replace_request(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4, long jarg5, pj_str_t jarg5_);
+  public final static native void Callback_on_call_replace_requestSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, long jarg4, long jarg5, pj_str_t jarg5_);
+  public final static native void Callback_on_call_replaced(long jarg1, Callback jarg1_, int jarg2, int jarg3);
+  public final static native void Callback_on_call_replacedSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, int jarg3);
+  public final static native void Callback_on_reg_state(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_reg_stateSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_buddy_state(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_buddy_stateSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_pager(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, long jarg5, pj_str_t jarg5_, long jarg6, pj_str_t jarg6_, long jarg7, pj_str_t jarg7_);
+  public final static native void Callback_on_pagerSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, long jarg5, pj_str_t jarg5_, long jarg6, pj_str_t jarg6_, long jarg7, pj_str_t jarg7_);
+  public final static native void Callback_on_pager2(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, long jarg5, pj_str_t jarg5_, long jarg6, pj_str_t jarg6_, long jarg7, pj_str_t jarg7_, long jarg8);
+  public final static native void Callback_on_pager2SwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, long jarg5, pj_str_t jarg5_, long jarg6, pj_str_t jarg6_, long jarg7, pj_str_t jarg7_, long jarg8);
+  public final static native void Callback_on_pager_status(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, int jarg5, long jarg6, pj_str_t jarg6_);
+  public final static native void Callback_on_pager_statusSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, int jarg5, long jarg6, pj_str_t jarg6_);
+  public final static native void Callback_on_pager_status2(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, int jarg5, long jarg6, pj_str_t jarg6_, long jarg7, long jarg8);
+  public final static native void Callback_on_pager_status2SwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, int jarg5, long jarg6, pj_str_t jarg6_, long jarg7, long jarg8);
+  public final static native void Callback_on_typing(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, long jarg5, pj_str_t jarg5_, int jarg6);
+  public final static native void Callback_on_typingSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, long jarg5, pj_str_t jarg5_, int jarg6);
+  public final static native void Callback_on_nat_detect(long jarg1, Callback jarg1_, long jarg2, pj_stun_nat_detect_result jarg2_);
+  public final static native void Callback_on_nat_detectSwigExplicitCallback(long jarg1, Callback jarg1_, long jarg2, pj_stun_nat_detect_result jarg2_);
+  public final static native int Callback_on_call_redirected(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_);
+  public final static native int Callback_on_call_redirectedSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_);
+  public final static native void Callback_on_mwi_info(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_);
+  public final static native void Callback_on_mwi_infoSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_);
+  public final static native void Callback_on_call_media_transport_state(long jarg1, Callback jarg1_, int jarg2, long jarg3, pjsua_med_tp_state_info jarg3_);
+  public final static native void Callback_on_call_media_transport_stateSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, long jarg3, pjsua_med_tp_state_info jarg3_);
+  public final static native int Callback_on_validate_audio_clock_rate(long jarg1, Callback jarg1_, int jarg2);
+  public final static native int Callback_on_validate_audio_clock_rateSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_setup_audio(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_setup_audioSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2);
+  public final static native void Callback_on_teardown_audio(long jarg1, Callback jarg1_);
+  public final static native void Callback_on_teardown_audioSwigExplicitCallback(long jarg1, Callback jarg1_);
+  public final static native int Callback_on_set_micro_source(long jarg1, Callback jarg1_);
+  public final static native int Callback_on_set_micro_sourceSwigExplicitCallback(long jarg1, Callback jarg1_);
+  public final static native int Callback_timer_schedule(long jarg1, Callback jarg1_, int jarg2, int jarg3, int jarg4);
+  public final static native int Callback_timer_scheduleSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, int jarg3, int jarg4);
+  public final static native int Callback_timer_cancel(long jarg1, Callback jarg1_, int jarg2, int jarg3);
+  public final static native int Callback_timer_cancelSwigExplicitCallback(long jarg1, Callback jarg1_, int jarg2, int jarg3);
+  public final static native long new_Callback();
+  public final static native void Callback_director_connect(Callback obj, long cptr, boolean mem_own, boolean weak_global);
+  public final static native void Callback_change_ownership(Callback obj, long cptr, boolean take_or_release);
+  public final static native void setCallbackObject(long jarg1, Callback jarg1_);
+  public final static native int PJ_SUCCESS_get();
+  public final static native int PJ_TRUE_get();
+  public final static native int PJ_FALSE_get();
+  public final static native void pj_str_t_ptr_set(long jarg1, pj_str_t jarg1_, String jarg2);
+  public final static native String pj_str_t_ptr_get(long jarg1, pj_str_t jarg1_);
+  public final static native void pj_str_t_slen_set(long jarg1, pj_str_t jarg1_, int jarg2);
+  public final static native int pj_str_t_slen_get(long jarg1, pj_str_t jarg1_);
+  public final static native long new_pj_str_t();
+  public final static native void delete_pj_str_t(long jarg1);
+  public final static native void pjmedia_port_info_name_set(long jarg1, pjmedia_port_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjmedia_port_info_name_get(long jarg1, pjmedia_port_info jarg1_);
+  public final static native void pjmedia_port_info_signature_set(long jarg1, pjmedia_port_info jarg1_, long jarg2);
+  public final static native long pjmedia_port_info_signature_get(long jarg1, pjmedia_port_info jarg1_);
+  public final static native void pjmedia_port_info_dir_set(long jarg1, pjmedia_port_info jarg1_, int jarg2);
+  public final static native int pjmedia_port_info_dir_get(long jarg1, pjmedia_port_info jarg1_);
+  public final static native void pjmedia_port_info_fmt_set(long jarg1, pjmedia_port_info jarg1_, long jarg2);
+  public final static native long pjmedia_port_info_fmt_get(long jarg1, pjmedia_port_info jarg1_);
+  public final static native long new_pjmedia_port_info();
+  public final static native void delete_pjmedia_port_info(long jarg1);
+  public final static native void pjmedia_port_info_set(long jarg1, pjmedia_port jarg1_, long jarg2, pjmedia_port_info jarg2_);
+  public final static native long pjmedia_port_info_get(long jarg1, pjmedia_port jarg1_);
+  public final static native void pjmedia_port_get_clock_src_set(long jarg1, pjmedia_port jarg1_, long jarg2);
+  public final static native long pjmedia_port_get_clock_src_get(long jarg1, pjmedia_port jarg1_);
+  public final static native void pjmedia_port_put_frame_set(long jarg1, pjmedia_port jarg1_, long jarg2);
+  public final static native long pjmedia_port_put_frame_get(long jarg1, pjmedia_port jarg1_);
+  public final static native void pjmedia_port_get_frame_set(long jarg1, pjmedia_port jarg1_, long jarg2);
+  public final static native long pjmedia_port_get_frame_get(long jarg1, pjmedia_port jarg1_);
+  public final static native void pjmedia_port_on_destroy_set(long jarg1, pjmedia_port jarg1_, long jarg2);
+  public final static native long pjmedia_port_on_destroy_get(long jarg1, pjmedia_port jarg1_);
+  public final static native int PJMEDIA_DIR_NONE_get();
+  public final static native int PJMEDIA_DIR_ENCODING_get();
+  public final static native int PJMEDIA_DIR_CAPTURE_get();
+  public final static native int PJMEDIA_DIR_DECODING_get();
+  public final static native int PJMEDIA_DIR_PLAYBACK_get();
+  public final static native int PJMEDIA_DIR_RENDER_get();
+  public final static native int PJMEDIA_DIR_ENCODING_DECODING_get();
+  public final static native int PJMEDIA_DIR_CAPTURE_PLAYBACK_get();
+  public final static native int PJMEDIA_DIR_CAPTURE_RENDER_get();
+  public final static native void pjsip_cred_info_realm_set(long jarg1, pjsip_cred_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_cred_info_realm_get(long jarg1, pjsip_cred_info jarg1_);
+  public final static native void pjsip_cred_info_scheme_set(long jarg1, pjsip_cred_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_cred_info_scheme_get(long jarg1, pjsip_cred_info jarg1_);
+  public final static native void pjsip_cred_info_username_set(long jarg1, pjsip_cred_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_cred_info_username_get(long jarg1, pjsip_cred_info jarg1_);
+  public final static native void pjsip_cred_info_data_type_set(long jarg1, pjsip_cred_info jarg1_, int jarg2);
+  public final static native int pjsip_cred_info_data_type_get(long jarg1, pjsip_cred_info jarg1_);
+  public final static native void pjsip_cred_info_data_set(long jarg1, pjsip_cred_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_cred_info_data_get(long jarg1, pjsip_cred_info jarg1_);
+  public final static native long new_pjsip_cred_info();
+  public final static native void delete_pjsip_cred_info(long jarg1);
+  public final static native int PJSIP_CRED_DATA_PLAIN_PASSWD_get();
+  public final static native int PJSIP_CRED_DATA_DIGEST_get();
+  public final static native int PJSIP_CRED_DATA_EXT_AKA_get();
+  public final static native int PJMEDIA_TONEGEN_LOOP_get();
+  public final static native int PJMEDIA_TONEGEN_NO_LOCK_get();
+  public final static native void pjsip_event_type_set(long jarg1, pjsip_event jarg1_, int jarg2);
+  public final static native int pjsip_event_type_get(long jarg1, pjsip_event jarg1_);
+  public final static native long new_pjsip_event();
+  public final static native void delete_pjsip_event(long jarg1);
+  public final static native void pjmedia_snd_dev_info_name_set(long jarg1, pjmedia_snd_dev_info jarg1_, String jarg2);
+  public final static native String pjmedia_snd_dev_info_name_get(long jarg1, pjmedia_snd_dev_info jarg1_);
+  public final static native void pjmedia_snd_dev_info_input_count_set(long jarg1, pjmedia_snd_dev_info jarg1_, long jarg2);
+  public final static native long pjmedia_snd_dev_info_input_count_get(long jarg1, pjmedia_snd_dev_info jarg1_);
+  public final static native void pjmedia_snd_dev_info_output_count_set(long jarg1, pjmedia_snd_dev_info jarg1_, long jarg2);
+  public final static native long pjmedia_snd_dev_info_output_count_get(long jarg1, pjmedia_snd_dev_info jarg1_);
+  public final static native void pjmedia_snd_dev_info_default_samples_per_sec_set(long jarg1, pjmedia_snd_dev_info jarg1_, long jarg2);
+  public final static native long pjmedia_snd_dev_info_default_samples_per_sec_get(long jarg1, pjmedia_snd_dev_info jarg1_);
+  public final static native long new_pjmedia_snd_dev_info();
+  public final static native void delete_pjmedia_snd_dev_info(long jarg1);
+  public final static native void pjmedia_tone_desc_freq1_set(long jarg1, pjmedia_tone_desc jarg1_, short jarg2);
+  public final static native short pjmedia_tone_desc_freq1_get(long jarg1, pjmedia_tone_desc jarg1_);
+  public final static native void pjmedia_tone_desc_freq2_set(long jarg1, pjmedia_tone_desc jarg1_, short jarg2);
+  public final static native short pjmedia_tone_desc_freq2_get(long jarg1, pjmedia_tone_desc jarg1_);
+  public final static native void pjmedia_tone_desc_on_msec_set(long jarg1, pjmedia_tone_desc jarg1_, short jarg2);
+  public final static native short pjmedia_tone_desc_on_msec_get(long jarg1, pjmedia_tone_desc jarg1_);
+  public final static native void pjmedia_tone_desc_off_msec_set(long jarg1, pjmedia_tone_desc jarg1_, short jarg2);
+  public final static native short pjmedia_tone_desc_off_msec_get(long jarg1, pjmedia_tone_desc jarg1_);
+  public final static native void pjmedia_tone_desc_volume_set(long jarg1, pjmedia_tone_desc jarg1_, short jarg2);
+  public final static native short pjmedia_tone_desc_volume_get(long jarg1, pjmedia_tone_desc jarg1_);
+  public final static native void pjmedia_tone_desc_flags_set(long jarg1, pjmedia_tone_desc jarg1_, short jarg2);
+  public final static native short pjmedia_tone_desc_flags_get(long jarg1, pjmedia_tone_desc jarg1_);
+  public final static native long new_pjmedia_tone_desc();
+  public final static native void delete_pjmedia_tone_desc(long jarg1);
+  public final static native void pjmedia_tone_digit_digit_set(long jarg1, pjmedia_tone_digit jarg1_, char jarg2);
+  public final static native char pjmedia_tone_digit_digit_get(long jarg1, pjmedia_tone_digit jarg1_);
+  public final static native void pjmedia_tone_digit_on_msec_set(long jarg1, pjmedia_tone_digit jarg1_, short jarg2);
+  public final static native short pjmedia_tone_digit_on_msec_get(long jarg1, pjmedia_tone_digit jarg1_);
+  public final static native void pjmedia_tone_digit_off_msec_set(long jarg1, pjmedia_tone_digit jarg1_, short jarg2);
+  public final static native short pjmedia_tone_digit_off_msec_get(long jarg1, pjmedia_tone_digit jarg1_);
+  public final static native void pjmedia_tone_digit_volume_set(long jarg1, pjmedia_tone_digit jarg1_, short jarg2);
+  public final static native short pjmedia_tone_digit_volume_get(long jarg1, pjmedia_tone_digit jarg1_);
+  public final static native long new_pjmedia_tone_digit();
+  public final static native void delete_pjmedia_tone_digit(long jarg1);
+  public final static native void pj_pool_t_obj_name_set(long jarg1, pj_pool_t jarg1_, String jarg2);
+  public final static native String pj_pool_t_obj_name_get(long jarg1, pj_pool_t jarg1_);
+  public final static native void pj_pool_t_factory_set(long jarg1, pj_pool_t jarg1_, long jarg2);
+  public final static native long pj_pool_t_factory_get(long jarg1, pj_pool_t jarg1_);
+  public final static native void pj_pool_t_factory_data_set(long jarg1, pj_pool_t jarg1_, byte[] jarg2);
+  public final static native byte[] pj_pool_t_factory_data_get(long jarg1, pj_pool_t jarg1_);
+  public final static native void pj_pool_t_capacity_set(long jarg1, pj_pool_t jarg1_, long jarg2);
+  public final static native long pj_pool_t_capacity_get(long jarg1, pj_pool_t jarg1_);
+  public final static native void pj_pool_t_increment_size_set(long jarg1, pj_pool_t jarg1_, long jarg2);
+  public final static native long pj_pool_t_increment_size_get(long jarg1, pj_pool_t jarg1_);
+  public final static native void pj_pool_t_block_list_set(long jarg1, pj_pool_t jarg1_, long jarg2);
+  public final static native long pj_pool_t_block_list_get(long jarg1, pj_pool_t jarg1_);
+  public final static native void pj_pool_t_callback_set(long jarg1, pj_pool_t jarg1_, long jarg2);
+  public final static native long pj_pool_t_callback_get(long jarg1, pj_pool_t jarg1_);
+  public final static native long new_pj_pool_t();
+  public final static native void delete_pj_pool_t(long jarg1);
+  public final static native int PJSIP_TRANSPORT_IPV6_get();
+  public final static native int PJSIP_TRANSPORT_UDP6_get();
+  public final static native int PJSIP_TRANSPORT_TCP6_get();
+  public final static native int PJSIP_TRANSPORT_TLS6_get();
+  public final static native int PJ_TURN_TP_UDP_get();
+  public final static native int PJ_TURN_TP_TCP_get();
+  public final static native int PJ_TURN_TP_TLS_get();
+  public final static native int PJSIP_SC_TRYING_get();
+  public final static native int PJSIP_SC_RINGING_get();
+  public final static native int PJSIP_SC_CALL_BEING_FORWARDED_get();
+  public final static native int PJSIP_SC_QUEUED_get();
+  public final static native int PJSIP_SC_PROGRESS_get();
+  public final static native int PJSIP_SC_OK_get();
+  public final static native int PJSIP_SC_ACCEPTED_get();
+  public final static native int PJSIP_SC_MULTIPLE_CHOICES_get();
+  public final static native int PJSIP_SC_MOVED_PERMANENTLY_get();
+  public final static native int PJSIP_SC_MOVED_TEMPORARILY_get();
+  public final static native int PJSIP_SC_USE_PROXY_get();
+  public final static native int PJSIP_SC_ALTERNATIVE_SERVICE_get();
+  public final static native int PJSIP_SC_BAD_REQUEST_get();
+  public final static native int PJSIP_SC_UNAUTHORIZED_get();
+  public final static native int PJSIP_SC_PAYMENT_REQUIRED_get();
+  public final static native int PJSIP_SC_FORBIDDEN_get();
+  public final static native int PJSIP_SC_NOT_FOUND_get();
+  public final static native int PJSIP_SC_METHOD_NOT_ALLOWED_get();
+  public final static native int PJSIP_SC_NOT_ACCEPTABLE_get();
+  public final static native int PJSIP_SC_PROXY_AUTHENTICATION_REQUIRED_get();
+  public final static native int PJSIP_SC_REQUEST_TIMEOUT_get();
+  public final static native int PJSIP_SC_GONE_get();
+  public final static native int PJSIP_SC_REQUEST_ENTITY_TOO_LARGE_get();
+  public final static native int PJSIP_SC_REQUEST_URI_TOO_LONG_get();
+  public final static native int PJSIP_SC_UNSUPPORTED_MEDIA_TYPE_get();
+  public final static native int PJSIP_SC_UNSUPPORTED_URI_SCHEME_get();
+  public final static native int PJSIP_SC_BAD_EXTENSION_get();
+  public final static native int PJSIP_SC_EXTENSION_REQUIRED_get();
+  public final static native int PJSIP_SC_SESSION_TIMER_TOO_SMALL_get();
+  public final static native int PJSIP_SC_INTERVAL_TOO_BRIEF_get();
+  public final static native int PJSIP_SC_TEMPORARILY_UNAVAILABLE_get();
+  public final static native int PJSIP_SC_CALL_TSX_DOES_NOT_EXIST_get();
+  public final static native int PJSIP_SC_LOOP_DETECTED_get();
+  public final static native int PJSIP_SC_TOO_MANY_HOPS_get();
+  public final static native int PJSIP_SC_ADDRESS_INCOMPLETE_get();
+  public final static native int PJSIP_AC_AMBIGUOUS_get();
+  public final static native int PJSIP_SC_BUSY_HERE_get();
+  public final static native int PJSIP_SC_REQUEST_TERMINATED_get();
+  public final static native int PJSIP_SC_NOT_ACCEPTABLE_HERE_get();
+  public final static native int PJSIP_SC_BAD_EVENT_get();
+  public final static native int PJSIP_SC_REQUEST_UPDATED_get();
+  public final static native int PJSIP_SC_REQUEST_PENDING_get();
+  public final static native int PJSIP_SC_UNDECIPHERABLE_get();
+  public final static native int PJSIP_SC_INTERNAL_SERVER_ERROR_get();
+  public final static native int PJSIP_SC_NOT_IMPLEMENTED_get();
+  public final static native int PJSIP_SC_BAD_GATEWAY_get();
+  public final static native int PJSIP_SC_SERVICE_UNAVAILABLE_get();
+  public final static native int PJSIP_SC_SERVER_TIMEOUT_get();
+  public final static native int PJSIP_SC_VERSION_NOT_SUPPORTED_get();
+  public final static native int PJSIP_SC_MESSAGE_TOO_LARGE_get();
+  public final static native int PJSIP_SC_PRECONDITION_FAILURE_get();
+  public final static native int PJSIP_SC_BUSY_EVERYWHERE_get();
+  public final static native int PJSIP_SC_DECLINE_get();
+  public final static native int PJSIP_SC_DOES_NOT_EXIST_ANYWHERE_get();
+  public final static native int PJSIP_SC_NOT_ACCEPTABLE_ANYWHERE_get();
+  public final static native int PJSIP_SC_TSX_TIMEOUT_get();
+  public final static native int PJSIP_SC_TSX_TRANSPORT_ERROR_get();
+  public final static native long pjsua_pool_create(String jarg1, long jarg2, long jarg3);
+  public final static native void pj_pool_release(long jarg1, pj_pool_t jarg1_);
+  public final static native int pjmedia_tonegen_create2(long jarg1, pj_pool_t jarg1_, long jarg2, pj_str_t jarg2_, long jarg3, long jarg4, long jarg5, long jarg6, long jarg7, pjmedia_port jarg8);
+  public final static native int pjmedia_tonegen_play(long jarg1, pjmedia_port jarg1_, long jarg2, long[] jarg3, long jarg4);
+  public final static native int pjmedia_tonegen_play_digits(long jarg1, pjmedia_port jarg1_, long jarg2, long[] jarg3, long jarg4);
+  public final static native int pjmedia_tonegen_rewind(long jarg1, pjmedia_port jarg1_);
+  public final static native int pjmedia_tonegen_stop(long jarg1, pjmedia_port jarg1_);
+  public final static native int pjmedia_port_destroy(long jarg1, pjmedia_port jarg1_);
+  public final static native int PJSIP_SSL_UNSPECIFIED_METHOD_get();
+  public final static native int PJSIP_SSLV2_METHOD_get();
+  public final static native int PJSIP_SSLV3_METHOD_get();
+  public final static native int PJSIP_TLSV1_METHOD_get();
+  public final static native int PJSIP_TLSV1_1_METHOD_get();
+  public final static native int PJSIP_TLSV1_2_METHOD_get();
+  public final static native int PJSIP_SSLV23_METHOD_get();
+  public final static native void pjsip_tls_setting_ca_list_file_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_tls_setting_ca_list_file_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_ca_list_path_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_tls_setting_ca_list_path_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_cert_file_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_tls_setting_cert_file_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_privkey_file_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_tls_setting_privkey_file_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_password_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_tls_setting_password_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_method_set(long jarg1, pjsip_tls_setting jarg1_, int jarg2);
+  public final static native int pjsip_tls_setting_method_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_proto_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2);
+  public final static native long pjsip_tls_setting_proto_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_ciphers_num_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2);
+  public final static native long pjsip_tls_setting_ciphers_num_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_ciphers_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2);
+  public final static native long pjsip_tls_setting_ciphers_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_verify_server_set(long jarg1, pjsip_tls_setting jarg1_, int jarg2);
+  public final static native int pjsip_tls_setting_verify_server_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_verify_client_set(long jarg1, pjsip_tls_setting jarg1_, int jarg2);
+  public final static native int pjsip_tls_setting_verify_client_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_require_client_cert_set(long jarg1, pjsip_tls_setting jarg1_, int jarg2);
+  public final static native int pjsip_tls_setting_require_client_cert_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_timeout_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2, pj_time_val jarg2_);
+  public final static native long pjsip_tls_setting_timeout_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_reuse_addr_set(long jarg1, pjsip_tls_setting jarg1_, int jarg2);
+  public final static native int pjsip_tls_setting_reuse_addr_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_qos_type_set(long jarg1, pjsip_tls_setting jarg1_, int jarg2);
+  public final static native int pjsip_tls_setting_qos_type_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_qos_params_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2, pj_qos_params jarg2_);
+  public final static native long pjsip_tls_setting_qos_params_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_qos_ignore_error_set(long jarg1, pjsip_tls_setting jarg1_, int jarg2);
+  public final static native int pjsip_tls_setting_qos_ignore_error_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_sockopt_params_set(long jarg1, pjsip_tls_setting jarg1_, long jarg2);
+  public final static native long pjsip_tls_setting_sockopt_params_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native void pjsip_tls_setting_sockopt_ignore_error_set(long jarg1, pjsip_tls_setting jarg1_, int jarg2);
+  public final static native int pjsip_tls_setting_sockopt_ignore_error_get(long jarg1, pjsip_tls_setting jarg1_);
+  public final static native long new_pjsip_tls_setting();
+  public final static native void delete_pjsip_tls_setting(long jarg1);
+  public final static native void pj_qos_params_flags_set(long jarg1, pj_qos_params jarg1_, short jarg2);
+  public final static native short pj_qos_params_flags_get(long jarg1, pj_qos_params jarg1_);
+  public final static native void pj_qos_params_dscp_val_set(long jarg1, pj_qos_params jarg1_, short jarg2);
+  public final static native short pj_qos_params_dscp_val_get(long jarg1, pj_qos_params jarg1_);
+  public final static native void pj_qos_params_so_prio_set(long jarg1, pj_qos_params jarg1_, short jarg2);
+  public final static native short pj_qos_params_so_prio_get(long jarg1, pj_qos_params jarg1_);
+  public final static native void pj_qos_params_wmm_prio_set(long jarg1, pj_qos_params jarg1_, long jarg2);
+  public final static native long pj_qos_params_wmm_prio_get(long jarg1, pj_qos_params jarg1_);
+  public final static native long new_pj_qos_params();
+  public final static native void delete_pj_qos_params(long jarg1);
+  public final static native void pj_time_val_sec_set(long jarg1, pj_time_val jarg1_, int jarg2);
+  public final static native int pj_time_val_sec_get(long jarg1, pj_time_val jarg1_);
+  public final static native void pj_time_val_msec_set(long jarg1, pj_time_val jarg1_, int jarg2);
+  public final static native int pj_time_val_msec_get(long jarg1, pj_time_val jarg1_);
+  public final static native long new_pj_time_val();
+  public final static native void delete_pj_time_val(long jarg1);
+  public final static native void pj_stun_nat_detect_result_status_set(long jarg1, pj_stun_nat_detect_result jarg1_, int jarg2);
+  public final static native int pj_stun_nat_detect_result_status_get(long jarg1, pj_stun_nat_detect_result jarg1_);
+  public final static native void pj_stun_nat_detect_result_status_text_set(long jarg1, pj_stun_nat_detect_result jarg1_, String jarg2);
+  public final static native String pj_stun_nat_detect_result_status_text_get(long jarg1, pj_stun_nat_detect_result jarg1_);
+  public final static native void pj_stun_nat_detect_result_nat_type_set(long jarg1, pj_stun_nat_detect_result jarg1_, int jarg2);
+  public final static native int pj_stun_nat_detect_result_nat_type_get(long jarg1, pj_stun_nat_detect_result jarg1_);
+  public final static native void pj_stun_nat_detect_result_nat_type_name_set(long jarg1, pj_stun_nat_detect_result jarg1_, String jarg2);
+  public final static native String pj_stun_nat_detect_result_nat_type_name_get(long jarg1, pj_stun_nat_detect_result jarg1_);
+  public final static native long new_pj_stun_nat_detect_result();
+  public final static native void delete_pj_stun_nat_detect_result(long jarg1);
+  public final static native void pjsip_timer_setting_min_se_set(long jarg1, pjsip_timer_setting jarg1_, long jarg2);
+  public final static native long pjsip_timer_setting_min_se_get(long jarg1, pjsip_timer_setting jarg1_);
+  public final static native void pjsip_timer_setting_sess_expires_set(long jarg1, pjsip_timer_setting jarg1_, long jarg2);
+  public final static native long pjsip_timer_setting_sess_expires_get(long jarg1, pjsip_timer_setting jarg1_);
+  public final static native long new_pjsip_timer_setting();
+  public final static native void delete_pjsip_timer_setting(long jarg1);
+  public final static native void pjsua_msg_data_target_uri_set(long jarg1, pjsua_msg_data jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_msg_data_target_uri_get(long jarg1, pjsua_msg_data jarg1_);
+  public final static native void pjsua_msg_data_hdr_list_set(long jarg1, pjsua_msg_data jarg1_, long jarg2);
+  public final static native long pjsua_msg_data_hdr_list_get(long jarg1, pjsua_msg_data jarg1_);
+  public final static native void pjsua_msg_data_content_type_set(long jarg1, pjsua_msg_data jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_msg_data_content_type_get(long jarg1, pjsua_msg_data jarg1_);
+  public final static native void pjsua_msg_data_msg_body_set(long jarg1, pjsua_msg_data jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_msg_data_msg_body_get(long jarg1, pjsua_msg_data jarg1_);
+  public final static native void pjsua_msg_data_multipart_ctype_set(long jarg1, pjsua_msg_data jarg1_, long jarg2);
+  public final static native long pjsua_msg_data_multipart_ctype_get(long jarg1, pjsua_msg_data jarg1_);
+  public final static native void pjsua_msg_data_multipart_parts_set(long jarg1, pjsua_msg_data jarg1_, long jarg2);
+  public final static native long pjsua_msg_data_multipart_parts_get(long jarg1, pjsua_msg_data jarg1_);
+  public final static native long new_pjsua_msg_data();
+  public final static native void delete_pjsua_msg_data(long jarg1);
+  public final static native void pjrpid_element_type_set(long jarg1, pjrpid_element jarg1_, long jarg2);
+  public final static native long pjrpid_element_type_get(long jarg1, pjrpid_element jarg1_);
+  public final static native void pjrpid_element_id_set(long jarg1, pjrpid_element jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjrpid_element_id_get(long jarg1, pjrpid_element jarg1_);
+  public final static native void pjrpid_element_activity_set(long jarg1, pjrpid_element jarg1_, int jarg2);
+  public final static native int pjrpid_element_activity_get(long jarg1, pjrpid_element jarg1_);
+  public final static native void pjrpid_element_note_set(long jarg1, pjrpid_element jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjrpid_element_note_get(long jarg1, pjrpid_element jarg1_);
+  public final static native long new_pjrpid_element();
+  public final static native void delete_pjrpid_element(long jarg1);
+  public final static native void pjsip_auth_clt_pref_initial_auth_set(long jarg1, pjsip_auth_clt_pref jarg1_, int jarg2);
+  public final static native int pjsip_auth_clt_pref_initial_auth_get(long jarg1, pjsip_auth_clt_pref jarg1_);
+  public final static native void pjsip_auth_clt_pref_algorithm_set(long jarg1, pjsip_auth_clt_pref jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsip_auth_clt_pref_algorithm_get(long jarg1, pjsip_auth_clt_pref jarg1_);
+  public final static native long new_pjsip_auth_clt_pref();
+  public final static native void delete_pjsip_auth_clt_pref(long jarg1);
+  public final static native void pj_ice_sess_options_aggressive_set(long jarg1, pj_ice_sess_options jarg1_, int jarg2);
+  public final static native int pj_ice_sess_options_aggressive_get(long jarg1, pj_ice_sess_options jarg1_);
+  public final static native void pj_ice_sess_options_nominated_check_delay_set(long jarg1, pj_ice_sess_options jarg1_, long jarg2);
+  public final static native long pj_ice_sess_options_nominated_check_delay_get(long jarg1, pj_ice_sess_options jarg1_);
+  public final static native void pj_ice_sess_options_controlled_agent_want_nom_timeout_set(long jarg1, pj_ice_sess_options jarg1_, int jarg2);
+  public final static native int pj_ice_sess_options_controlled_agent_want_nom_timeout_get(long jarg1, pj_ice_sess_options jarg1_);
+  public final static native long new_pj_ice_sess_options();
+  public final static native void delete_pj_ice_sess_options(long jarg1);
+  public final static native void delete_ZrtpCallback(long jarg1);
+  public final static native void ZrtpCallback_on_zrtp_show_sas(long jarg1, ZrtpCallback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, int jarg4);
+  public final static native void ZrtpCallback_on_zrtp_show_sasSwigExplicitZrtpCallback(long jarg1, ZrtpCallback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, int jarg4);
+  public final static native void ZrtpCallback_on_zrtp_update_transport(long jarg1, ZrtpCallback jarg1_, int jarg2);
+  public final static native void ZrtpCallback_on_zrtp_update_transportSwigExplicitZrtpCallback(long jarg1, ZrtpCallback jarg1_, int jarg2);
+  public final static native long new_ZrtpCallback();
+  public final static native void ZrtpCallback_director_connect(ZrtpCallback obj, long cptr, boolean mem_own, boolean weak_global);
+  public final static native void ZrtpCallback_change_ownership(ZrtpCallback obj, long cptr, boolean take_or_release);
+  public final static native void setZrtpCallbackObject(long jarg1, ZrtpCallback jarg1_);
+  public final static native void delete_MobileRegHandlerCallback(long jarg1);
+  public final static native void MobileRegHandlerCallback_on_save_contact(long jarg1, MobileRegHandlerCallback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, int jarg4);
+  public final static native void MobileRegHandlerCallback_on_save_contactSwigExplicitMobileRegHandlerCallback(long jarg1, MobileRegHandlerCallback jarg1_, int jarg2, long jarg3, pj_str_t jarg3_, int jarg4);
+  public final static native long MobileRegHandlerCallback_on_restore_contact(long jarg1, MobileRegHandlerCallback jarg1_, int jarg2);
+  public final static native long MobileRegHandlerCallback_on_restore_contactSwigExplicitMobileRegHandlerCallback(long jarg1, MobileRegHandlerCallback jarg1_, int jarg2);
+  public final static native long new_MobileRegHandlerCallback();
+  public final static native void MobileRegHandlerCallback_director_connect(MobileRegHandlerCallback obj, long cptr, boolean mem_own, boolean weak_global);
+  public final static native void MobileRegHandlerCallback_change_ownership(MobileRegHandlerCallback obj, long cptr, boolean take_or_release);
+  public final static native int mobile_reg_handler_init();
+  public final static native void mobile_reg_handler_set_callback(long jarg1, MobileRegHandlerCallback jarg1_);
+  public final static native int sipclf_mod_init();
+  public final static native void delete_EarlyLockCallback(long jarg1);
+  public final static native void EarlyLockCallback_on_create_early_lock(long jarg1, EarlyLockCallback jarg1_);
+  public final static native void EarlyLockCallback_on_create_early_lockSwigExplicitEarlyLockCallback(long jarg1, EarlyLockCallback jarg1_);
+  public final static native long new_EarlyLockCallback();
+  public final static native void EarlyLockCallback_director_connect(EarlyLockCallback obj, long cptr, boolean mem_own, boolean weak_global);
+  public final static native void EarlyLockCallback_change_ownership(EarlyLockCallback obj, long cptr, boolean take_or_release);
+  public final static native int mod_earlylock_init();
+  public final static native void mod_earlylock_set_callback(long jarg1, EarlyLockCallback jarg1_);
+  public final static native int PJSUA_INVALID_ID_get();
+  public final static native int DISABLED_FOR_TICKET_1185_get();
+  public final static native int PJSUA_ACC_MAX_PROXIES_get();
+  public final static native int PJSUA_DEFAULT_SRTP_SECURE_SIGNALING_get();
+  public final static native int PJSUA_ADD_ICE_TAGS_get();
+  public final static native int PJSUA_ACQUIRE_CALL_TIMEOUT_get();
+  public final static native int PJSUA_HAS_VIDEO_get();
+  public final static native int PJSUA_VID_REQ_KEYFRAME_INTERVAL_get();
+  public final static native void pjsua_logging_config_msg_logging_set(long jarg1, pjsua_logging_config jarg1_, int jarg2);
+  public final static native int pjsua_logging_config_msg_logging_get(long jarg1, pjsua_logging_config jarg1_);
+  public final static native void pjsua_logging_config_level_set(long jarg1, pjsua_logging_config jarg1_, long jarg2);
+  public final static native long pjsua_logging_config_level_get(long jarg1, pjsua_logging_config jarg1_);
+  public final static native void pjsua_logging_config_console_level_set(long jarg1, pjsua_logging_config jarg1_, long jarg2);
+  public final static native long pjsua_logging_config_console_level_get(long jarg1, pjsua_logging_config jarg1_);
+  public final static native void pjsua_logging_config_decor_set(long jarg1, pjsua_logging_config jarg1_, long jarg2);
+  public final static native long pjsua_logging_config_decor_get(long jarg1, pjsua_logging_config jarg1_);
+  public final static native void pjsua_logging_config_log_filename_set(long jarg1, pjsua_logging_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_logging_config_log_filename_get(long jarg1, pjsua_logging_config jarg1_);
+  public final static native void pjsua_logging_config_log_file_flags_set(long jarg1, pjsua_logging_config jarg1_, long jarg2);
+  public final static native long pjsua_logging_config_log_file_flags_get(long jarg1, pjsua_logging_config jarg1_);
+  public final static native void pjsua_logging_config_cb_set(long jarg1, pjsua_logging_config jarg1_, long jarg2);
+  public final static native long pjsua_logging_config_cb_get(long jarg1, pjsua_logging_config jarg1_);
+  public final static native long new_pjsua_logging_config();
+  public final static native void delete_pjsua_logging_config(long jarg1);
+  public final static native void logging_config_default(long jarg1, pjsua_logging_config jarg1_);
+  public final static native void logging_config_dup(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_logging_config jarg2_, long jarg3, pjsua_logging_config jarg3_);
+  public final static native void pjsua_mwi_info_evsub_set(long jarg1, pjsua_mwi_info jarg1_, long jarg2);
+  public final static native long pjsua_mwi_info_evsub_get(long jarg1, pjsua_mwi_info jarg1_);
+  public final static native void pjsua_mwi_info_rdata_set(long jarg1, pjsua_mwi_info jarg1_, long jarg2);
+  public final static native long pjsua_mwi_info_rdata_get(long jarg1, pjsua_mwi_info jarg1_);
+  public final static native long new_pjsua_mwi_info();
+  public final static native void delete_pjsua_mwi_info(long jarg1);
+  public final static native void pjsua_reg_info_cbparam_set(long jarg1, pjsua_reg_info jarg1_, long jarg2);
+  public final static native long pjsua_reg_info_cbparam_get(long jarg1, pjsua_reg_info jarg1_);
+  public final static native long new_pjsua_reg_info();
+  public final static native void delete_pjsua_reg_info(long jarg1);
+  public final static native void pjsua_med_tp_state_info_med_idx_set(long jarg1, pjsua_med_tp_state_info jarg1_, long jarg2);
+  public final static native long pjsua_med_tp_state_info_med_idx_get(long jarg1, pjsua_med_tp_state_info jarg1_);
+  public final static native void pjsua_med_tp_state_info_state_set(long jarg1, pjsua_med_tp_state_info jarg1_, int jarg2);
+  public final static native int pjsua_med_tp_state_info_state_get(long jarg1, pjsua_med_tp_state_info jarg1_);
+  public final static native void pjsua_med_tp_state_info_status_set(long jarg1, pjsua_med_tp_state_info jarg1_, int jarg2);
+  public final static native int pjsua_med_tp_state_info_status_get(long jarg1, pjsua_med_tp_state_info jarg1_);
+  public final static native void pjsua_med_tp_state_info_sip_err_code_set(long jarg1, pjsua_med_tp_state_info jarg1_, int jarg2);
+  public final static native int pjsua_med_tp_state_info_sip_err_code_get(long jarg1, pjsua_med_tp_state_info jarg1_);
+  public final static native void pjsua_med_tp_state_info_ext_info_set(long jarg1, pjsua_med_tp_state_info jarg1_, byte[] jarg2);
+  public final static native byte[] pjsua_med_tp_state_info_ext_info_get(long jarg1, pjsua_med_tp_state_info jarg1_);
+  public final static native long new_pjsua_med_tp_state_info();
+  public final static native void delete_pjsua_med_tp_state_info(long jarg1);
+  public final static native int PJSUA_MED_TP_CLOSE_MEMBER_get();
+  public final static native int PJSUA_CONTACT_REWRITE_UNREGISTER_get();
+  public final static native int PJSUA_CONTACT_REWRITE_NO_UNREG_get();
+  public final static native int PJSUA_CONTACT_REWRITE_ALWAYS_UPDATE_get();
+  public final static native void pjsua_call_setting_flag_set(long jarg1, pjsua_call_setting jarg1_, long jarg2);
+  public final static native long pjsua_call_setting_flag_get(long jarg1, pjsua_call_setting jarg1_);
+  public final static native void pjsua_call_setting_req_keyframe_method_set(long jarg1, pjsua_call_setting jarg1_, long jarg2);
+  public final static native long pjsua_call_setting_req_keyframe_method_get(long jarg1, pjsua_call_setting jarg1_);
+  public final static native void pjsua_call_setting_aud_cnt_set(long jarg1, pjsua_call_setting jarg1_, long jarg2);
+  public final static native long pjsua_call_setting_aud_cnt_get(long jarg1, pjsua_call_setting jarg1_);
+  public final static native void pjsua_call_setting_vid_cnt_set(long jarg1, pjsua_call_setting jarg1_, long jarg2);
+  public final static native long pjsua_call_setting_vid_cnt_get(long jarg1, pjsua_call_setting jarg1_);
+  public final static native long new_pjsua_call_setting();
+  public final static native void delete_pjsua_call_setting(long jarg1);
+  public final static native void pjsua_callback_on_call_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_incoming_call_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_incoming_call_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_tsx_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_tsx_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_media_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_media_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_sdp_created_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_sdp_created_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_stream_created_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_stream_created_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_stream_destroyed_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_stream_destroyed_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_dtmf_digit_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_dtmf_digit_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_transfer_request_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_transfer_request_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_transfer_request2_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_transfer_request2_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_transfer_status_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_transfer_status_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_replace_request_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_replace_request_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_replace_request2_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_replace_request2_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_replaced_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_replaced_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_rx_offer_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_rx_offer_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_reg_started_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_reg_started_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_reg_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_reg_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_reg_state2_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_reg_state2_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_incoming_subscribe_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_incoming_subscribe_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_srv_subscribe_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_srv_subscribe_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_buddy_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_buddy_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_buddy_evsub_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_buddy_evsub_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_pager_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_pager_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_pager2_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_pager2_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_pager_status_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_pager_status_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_pager_status2_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_pager_status2_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_typing_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_typing_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_typing2_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_typing2_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_nat_detect_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_nat_detect_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_redirected_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_redirected_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_mwi_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_mwi_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_mwi_info_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_mwi_info_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_transport_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_transport_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_media_transport_state_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_media_transport_state_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_ice_transport_error_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_ice_transport_error_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_snd_dev_operation_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_snd_dev_operation_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_call_media_event_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_call_media_event_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_create_media_transport_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_create_media_transport_get(long jarg1, pjsua_callback jarg1_);
+  public final static native void pjsua_callback_on_acc_find_for_incoming_set(long jarg1, pjsua_callback jarg1_, long jarg2);
+  public final static native long pjsua_callback_on_acc_find_for_incoming_get(long jarg1, pjsua_callback jarg1_);
+  public final static native long new_pjsua_callback();
+  public final static native void delete_pjsua_callback(long jarg1);
+  public final static native void pjsua_config_max_calls_set(long jarg1, pjsua_config jarg1_, long jarg2);
+  public final static native long pjsua_config_max_calls_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_thread_cnt_set(long jarg1, pjsua_config jarg1_, long jarg2);
+  public final static native long pjsua_config_thread_cnt_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_nameserver_count_set(long jarg1, pjsua_config jarg1_, long jarg2);
+  public final static native long pjsua_config_nameserver_count_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_nameserver_set(long jarg1, pjsua_config jarg1_, long[] jarg2);
+  public final static native long[] pjsua_config_nameserver_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_force_lr_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_force_lr_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_outbound_proxy_cnt_set(long jarg1, pjsua_config jarg1_, long jarg2);
+  public final static native long pjsua_config_outbound_proxy_cnt_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_outbound_proxy_set(long jarg1, pjsua_config jarg1_, long[] jarg2);
+  public final static native long[] pjsua_config_outbound_proxy_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_stun_domain_set(long jarg1, pjsua_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_config_stun_domain_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_stun_host_set(long jarg1, pjsua_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_config_stun_host_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_stun_srv_cnt_set(long jarg1, pjsua_config jarg1_, long jarg2);
+  public final static native long pjsua_config_stun_srv_cnt_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_stun_srv_set(long jarg1, pjsua_config jarg1_, long[] jarg2);
+  public final static native long[] pjsua_config_stun_srv_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_stun_ignore_failure_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_stun_ignore_failure_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_stun_map_use_stun2_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_stun_map_use_stun2_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_nat_type_in_sdp_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_nat_type_in_sdp_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_require_100rel_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_require_100rel_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_use_timer_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_use_timer_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_enable_unsolicited_mwi_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_enable_unsolicited_mwi_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_timer_setting_set(long jarg1, pjsua_config jarg1_, long jarg2, pjsip_timer_setting jarg2_);
+  public final static native long pjsua_config_timer_setting_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_cred_count_set(long jarg1, pjsua_config jarg1_, long jarg2);
+  public final static native long pjsua_config_cred_count_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_cred_info_set(long jarg1, pjsua_config jarg1_, long jarg2, pjsip_cred_info jarg2_);
+  public final static native long pjsua_config_cred_info_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_cb_set(long jarg1, pjsua_config jarg1_, long jarg2, pjsua_callback jarg2_);
+  public final static native long pjsua_config_cb_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_user_agent_set(long jarg1, pjsua_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_config_user_agent_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_use_srtp_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_use_srtp_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_srtp_secure_signaling_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_srtp_secure_signaling_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_srtp_optional_dup_offer_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_srtp_optional_dup_offer_get(long jarg1, pjsua_config jarg1_);
+  public final static native void pjsua_config_hangup_forked_call_set(long jarg1, pjsua_config jarg1_, int jarg2);
+  public final static native int pjsua_config_hangup_forked_call_get(long jarg1, pjsua_config jarg1_);
+  public final static native long new_pjsua_config();
+  public final static native void delete_pjsua_config(long jarg1);
+  public final static native int PJSUA_DESTROY_NO_RX_MSG_get();
+  public final static native int PJSUA_DESTROY_NO_TX_MSG_get();
+  public final static native int PJSUA_DESTROY_NO_NETWORK_get();
+  public final static native void config_default(long jarg1, pjsua_config jarg1_);
+  public final static native void config_dup(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_config jarg2_, long jarg3, pjsua_config jarg3_);
+  public final static native void msg_data_init(long jarg1, pjsua_msg_data jarg1_);
+  public final static native long msg_data_clone(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_msg_data jarg2_);
+  public final static native int create();
+  public final static native int start();
+  public final static native int get_state();
+  public final static native int handle_events(long jarg1);
+  public final static native void stop_worker_threads();
+  public final static native long pool_create(String jarg1, long jarg2, long jarg3);
+  public final static native int reconfigure_logging(long jarg1, pjsua_logging_config jarg1_);
+  public final static native long get_pjsip_endpt();
+  public final static native long get_pjmedia_endpt();
+  public final static native long get_pool_factory();
+  public final static native void pj_stun_resolve_result_token_set(long jarg1, pj_stun_resolve_result jarg1_, byte[] jarg2);
+  public final static native byte[] pj_stun_resolve_result_token_get(long jarg1, pj_stun_resolve_result jarg1_);
+  public final static native void pj_stun_resolve_result_status_set(long jarg1, pj_stun_resolve_result jarg1_, int jarg2);
+  public final static native int pj_stun_resolve_result_status_get(long jarg1, pj_stun_resolve_result jarg1_);
+  public final static native void pj_stun_resolve_result_name_set(long jarg1, pj_stun_resolve_result jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pj_stun_resolve_result_name_get(long jarg1, pj_stun_resolve_result jarg1_);
+  public final static native void pj_stun_resolve_result_addr_set(long jarg1, pj_stun_resolve_result jarg1_, long jarg2);
+  public final static native long pj_stun_resolve_result_addr_get(long jarg1, pj_stun_resolve_result jarg1_);
+  public final static native long new_pj_stun_resolve_result();
+  public final static native void delete_pj_stun_resolve_result(long jarg1);
+  public final static native int detect_nat_type();
+  public final static native int get_nat_type(int[] jarg1);
+  public final static native int resolve_stun_servers(long jarg1, long[] jarg2, int jarg3, byte[] jarg4, long jarg5);
+  public final static native int cancel_stun_resolution(byte[] jarg1, int jarg2);
+  public final static native int verify_sip_url(String jarg1);
+  public final static native int verify_url(String jarg1);
+  public final static native int schedule_timer(long jarg1, long jarg2, pj_time_val jarg2_);
+  public final static native int pjsua_schedule_timer2(long jarg1, byte[] jarg2, long jarg3);
+  public final static native void cancel_timer(long jarg1);
+  public final static native void perror(String jarg1, String jarg2, int jarg3);
+  public final static native void dump(int jarg1);
+  public final static native void pjsua_transport_config_port_set(long jarg1, pjsua_transport_config jarg1_, long jarg2);
+  public final static native long pjsua_transport_config_port_get(long jarg1, pjsua_transport_config jarg1_);
+  public final static native void pjsua_transport_config_port_range_set(long jarg1, pjsua_transport_config jarg1_, long jarg2);
+  public final static native long pjsua_transport_config_port_range_get(long jarg1, pjsua_transport_config jarg1_);
+  public final static native void pjsua_transport_config_public_addr_set(long jarg1, pjsua_transport_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_transport_config_public_addr_get(long jarg1, pjsua_transport_config jarg1_);
+  public final static native void pjsua_transport_config_bound_addr_set(long jarg1, pjsua_transport_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_transport_config_bound_addr_get(long jarg1, pjsua_transport_config jarg1_);
+  public final static native void pjsua_transport_config_tls_setting_set(long jarg1, pjsua_transport_config jarg1_, long jarg2, pjsip_tls_setting jarg2_);
+  public final static native long pjsua_transport_config_tls_setting_get(long jarg1, pjsua_transport_config jarg1_);
+  public final static native void pjsua_transport_config_qos_type_set(long jarg1, pjsua_transport_config jarg1_, int jarg2);
+  public final static native int pjsua_transport_config_qos_type_get(long jarg1, pjsua_transport_config jarg1_);
+  public final static native void pjsua_transport_config_qos_params_set(long jarg1, pjsua_transport_config jarg1_, long jarg2, pj_qos_params jarg2_);
+  public final static native long pjsua_transport_config_qos_params_get(long jarg1, pjsua_transport_config jarg1_);
+  public final static native void pjsua_transport_config_sockopt_params_set(long jarg1, pjsua_transport_config jarg1_, long jarg2);
+  public final static native long pjsua_transport_config_sockopt_params_get(long jarg1, pjsua_transport_config jarg1_);
+  public final static native long new_pjsua_transport_config();
+  public final static native void delete_pjsua_transport_config(long jarg1);
+  public final static native void transport_config_default(long jarg1, pjsua_transport_config jarg1_);
+  public final static native void transport_config_dup(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_transport_config jarg2_, long jarg3, pjsua_transport_config jarg3_);
+  public final static native void pjsua_transport_info_id_set(long jarg1, pjsua_transport_info jarg1_, int jarg2);
+  public final static native int pjsua_transport_info_id_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native void pjsua_transport_info_type_set(long jarg1, pjsua_transport_info jarg1_, int jarg2);
+  public final static native int pjsua_transport_info_type_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native void pjsua_transport_info_type_name_set(long jarg1, pjsua_transport_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_transport_info_type_name_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native void pjsua_transport_info_info_set(long jarg1, pjsua_transport_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_transport_info_info_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native void pjsua_transport_info_flag_set(long jarg1, pjsua_transport_info jarg1_, long jarg2);
+  public final static native long pjsua_transport_info_flag_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native void pjsua_transport_info_addr_len_set(long jarg1, pjsua_transport_info jarg1_, long jarg2);
+  public final static native long pjsua_transport_info_addr_len_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native void pjsua_transport_info_local_addr_set(long jarg1, pjsua_transport_info jarg1_, long jarg2);
+  public final static native long pjsua_transport_info_local_addr_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native void pjsua_transport_info_local_name_set(long jarg1, pjsua_transport_info jarg1_, long jarg2);
+  public final static native long pjsua_transport_info_local_name_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native void pjsua_transport_info_usage_count_set(long jarg1, pjsua_transport_info jarg1_, long jarg2);
+  public final static native long pjsua_transport_info_usage_count_get(long jarg1, pjsua_transport_info jarg1_);
+  public final static native long new_pjsua_transport_info();
+  public final static native void delete_pjsua_transport_info(long jarg1);
+  public final static native int transport_create(int jarg1, long jarg2, pjsua_transport_config jarg2_, int[] jarg3);
+  public final static native int transport_register(long jarg1, int[] jarg2);
+  public final static native int enum_transports(int[] jarg1, long[] jarg2);
+  public final static native int transport_get_info(int jarg1, long jarg2, pjsua_transport_info jarg2_);
+  public final static native int transport_set_enable(int jarg1, int jarg2);
+  public final static native int transport_close(int jarg1, int jarg2);
+  public final static native int PJSUA_MAX_ACC_get();
+  public final static native int PJSUA_REG_INTERVAL_get();
+  public final static native int PJSUA_UNREG_TIMEOUT_get();
+  public final static native int PJSUA_DEFAULT_ACC_PRIORITY_get();
+  public final static native int PJSUA_UNPUBLISH_MAX_WAIT_TIME_MSEC_get();
+  public final static native int PJSUA_REG_RETRY_INTERVAL_get();
+  public final static native int PJSUA_REG_USE_OUTBOUND_PROXY_get();
+  public final static native int PJSUA_REG_USE_ACC_PROXY_get();
+  public final static native void pjsua_ice_config_enable_ice_set(long jarg1, pjsua_ice_config jarg1_, int jarg2);
+  public final static native int pjsua_ice_config_enable_ice_get(long jarg1, pjsua_ice_config jarg1_);
+  public final static native void pjsua_ice_config_ice_max_host_cands_set(long jarg1, pjsua_ice_config jarg1_, int jarg2);
+  public final static native int pjsua_ice_config_ice_max_host_cands_get(long jarg1, pjsua_ice_config jarg1_);
+  public final static native void pjsua_ice_config_ice_opt_set(long jarg1, pjsua_ice_config jarg1_, long jarg2, pj_ice_sess_options jarg2_);
+  public final static native long pjsua_ice_config_ice_opt_get(long jarg1, pjsua_ice_config jarg1_);
+  public final static native void pjsua_ice_config_ice_no_rtcp_set(long jarg1, pjsua_ice_config jarg1_, int jarg2);
+  public final static native int pjsua_ice_config_ice_no_rtcp_get(long jarg1, pjsua_ice_config jarg1_);
+  public final static native void pjsua_ice_config_ice_always_update_set(long jarg1, pjsua_ice_config jarg1_, int jarg2);
+  public final static native int pjsua_ice_config_ice_always_update_get(long jarg1, pjsua_ice_config jarg1_);
+  public final static native long new_pjsua_ice_config();
+  public final static native void delete_pjsua_ice_config(long jarg1);
+  public final static native void pjsua_turn_config_enable_turn_set(long jarg1, pjsua_turn_config jarg1_, int jarg2);
+  public final static native int pjsua_turn_config_enable_turn_get(long jarg1, pjsua_turn_config jarg1_);
+  public final static native void pjsua_turn_config_turn_server_set(long jarg1, pjsua_turn_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_turn_config_turn_server_get(long jarg1, pjsua_turn_config jarg1_);
+  public final static native void pjsua_turn_config_turn_conn_type_set(long jarg1, pjsua_turn_config jarg1_, int jarg2);
+  public final static native int pjsua_turn_config_turn_conn_type_get(long jarg1, pjsua_turn_config jarg1_);
+  public final static native void pjsua_turn_config_turn_auth_cred_set(long jarg1, pjsua_turn_config jarg1_, long jarg2);
+  public final static native long pjsua_turn_config_turn_auth_cred_get(long jarg1, pjsua_turn_config jarg1_);
+  public final static native long new_pjsua_turn_config();
+  public final static native void delete_pjsua_turn_config(long jarg1);
+  public final static native void pjsua_acc_config_user_data_set(long jarg1, pjsua_acc_config jarg1_, byte[] jarg2);
+  public final static native byte[] pjsua_acc_config_user_data_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_priority_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_priority_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_id_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_id_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_reg_uri_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_reg_uri_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_reg_hdr_list_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_reg_hdr_list_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_sub_hdr_list_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_sub_hdr_list_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_mwi_enabled_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_mwi_enabled_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_mwi_expires_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_mwi_expires_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_publish_enabled_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_publish_enabled_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_publish_opt_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_publish_opt_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_unpublish_max_wait_time_msec_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_unpublish_max_wait_time_msec_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_auth_pref_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pjsip_auth_clt_pref jarg2_);
+  public final static native long pjsua_acc_config_auth_pref_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_pidf_tuple_id_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_pidf_tuple_id_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_force_contact_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_force_contact_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_contact_params_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_contact_params_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_contact_uri_params_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_contact_uri_params_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_require_100rel_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_require_100rel_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_use_timer_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_use_timer_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_timer_setting_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pjsip_timer_setting jarg2_);
+  public final static native long pjsua_acc_config_timer_setting_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_proxy_cnt_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_proxy_cnt_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_proxy_set(long jarg1, pjsua_acc_config jarg1_, long[] jarg2);
+  public final static native long[] pjsua_acc_config_proxy_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_lock_codec_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_lock_codec_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_reg_timeout_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_reg_timeout_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_reg_delay_before_refresh_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_reg_delay_before_refresh_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_unreg_timeout_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_unreg_timeout_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_cred_count_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_cred_count_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_cred_info_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pjsip_cred_info jarg2_);
+  public final static native long pjsua_acc_config_cred_info_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_transport_id_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_transport_id_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_allow_contact_rewrite_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_allow_contact_rewrite_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_contact_rewrite_method_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_contact_rewrite_method_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_contact_use_src_port_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_contact_use_src_port_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_allow_via_rewrite_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_allow_via_rewrite_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_allow_sdp_nat_rewrite_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_allow_sdp_nat_rewrite_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_use_rfc5626_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_use_rfc5626_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_rfc5626_instance_id_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_rfc5626_instance_id_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_rfc5626_reg_id_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_rfc5626_reg_id_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_ka_interval_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_ka_interval_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_ka_data_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_config_ka_data_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_vid_in_auto_show_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_vid_in_auto_show_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_vid_out_auto_transmit_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_vid_out_auto_transmit_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_vid_wnd_flags_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_vid_wnd_flags_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_vid_cap_dev_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_vid_cap_dev_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_vid_rend_dev_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_vid_rend_dev_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_vid_stream_rc_cfg_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_vid_stream_rc_cfg_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_rtp_cfg_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pjsua_transport_config jarg2_);
+  public final static native long pjsua_acc_config_rtp_cfg_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_ipv6_media_use_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_ipv6_media_use_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_sip_stun_use_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_sip_stun_use_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_media_stun_use_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_media_stun_use_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_ice_cfg_use_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_ice_cfg_use_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_ice_cfg_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pjsua_ice_config jarg2_);
+  public final static native long pjsua_acc_config_ice_cfg_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_turn_cfg_use_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_turn_cfg_use_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_turn_cfg_set(long jarg1, pjsua_acc_config jarg1_, long jarg2, pjsua_turn_config jarg2_);
+  public final static native long pjsua_acc_config_turn_cfg_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_use_srtp_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_use_srtp_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_srtp_secure_signaling_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_srtp_secure_signaling_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_srtp_optional_dup_offer_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_srtp_optional_dup_offer_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_reg_retry_interval_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_reg_retry_interval_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_reg_first_retry_interval_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_reg_first_retry_interval_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_reg_retry_random_interval_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_reg_retry_random_interval_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_drop_calls_on_reg_fail_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_drop_calls_on_reg_fail_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_reg_use_proxy_set(long jarg1, pjsua_acc_config jarg1_, long jarg2);
+  public final static native long pjsua_acc_config_reg_use_proxy_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_call_hold_type_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_call_hold_type_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void pjsua_acc_config_register_on_acc_add_set(long jarg1, pjsua_acc_config jarg1_, int jarg2);
+  public final static native int pjsua_acc_config_register_on_acc_add_get(long jarg1, pjsua_acc_config jarg1_);
+  public final static native long new_pjsua_acc_config();
+  public final static native void delete_pjsua_acc_config(long jarg1);
+  public final static native void ice_config_from_media_config(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_ice_config jarg2_, long jarg3, pjsua_media_config jarg3_);
+  public final static native void ice_config_dup(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_ice_config jarg2_, long jarg3, pjsua_ice_config jarg3_);
+  public final static native void turn_config_from_media_config(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_turn_config jarg2_, long jarg3, pjsua_media_config jarg3_);
+  public final static native void turn_config_dup(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_turn_config jarg2_, long jarg3, pjsua_turn_config jarg3_);
+  public final static native void acc_config_default(long jarg1, pjsua_acc_config jarg1_);
+  public final static native void acc_config_dup(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_acc_config jarg2_, long jarg3, pjsua_acc_config jarg3_);
+  public final static native void pjsua_acc_info_id_set(long jarg1, pjsua_acc_info jarg1_, int jarg2);
+  public final static native int pjsua_acc_info_id_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_is_default_set(long jarg1, pjsua_acc_info jarg1_, int jarg2);
+  public final static native int pjsua_acc_info_is_default_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_acc_uri_set(long jarg1, pjsua_acc_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_info_acc_uri_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_has_registration_set(long jarg1, pjsua_acc_info jarg1_, int jarg2);
+  public final static native int pjsua_acc_info_has_registration_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_expires_set(long jarg1, pjsua_acc_info jarg1_, int jarg2);
+  public final static native int pjsua_acc_info_expires_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_status_set(long jarg1, pjsua_acc_info jarg1_, int jarg2);
+  public final static native int pjsua_acc_info_status_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_reg_last_err_set(long jarg1, pjsua_acc_info jarg1_, int jarg2);
+  public final static native int pjsua_acc_info_reg_last_err_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_status_text_set(long jarg1, pjsua_acc_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_info_status_text_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_online_status_set(long jarg1, pjsua_acc_info jarg1_, int jarg2);
+  public final static native int pjsua_acc_info_online_status_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_online_status_text_set(long jarg1, pjsua_acc_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_acc_info_online_status_text_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_rpid_set(long jarg1, pjsua_acc_info jarg1_, long jarg2, pjrpid_element jarg2_);
+  public final static native long pjsua_acc_info_rpid_get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native void pjsua_acc_info_buf__set(long jarg1, pjsua_acc_info jarg1_, String jarg2);
+  public final static native String pjsua_acc_info_buf__get(long jarg1, pjsua_acc_info jarg1_);
+  public final static native long new_pjsua_acc_info();
+  public final static native void delete_pjsua_acc_info(long jarg1);
+  public final static native long acc_get_count();
+  public final static native int acc_is_valid(int jarg1);
+  public final static native int acc_set_default(int jarg1);
+  public final static native int acc_get_default();
+  public final static native int acc_add(long jarg1, pjsua_acc_config jarg1_, int jarg2, int[] jarg3);
+  public final static native int acc_add_local(int jarg1, int jarg2, int[] jarg3);
+  public final static native int acc_set_user_data(int jarg1, byte[] jarg2);
+  public final static native byte[] acc_get_user_data(int jarg1);
+  public final static native int acc_del(int jarg1);
+  public final static native int acc_get_config(int jarg1, long jarg2, pj_pool_t jarg2_, long jarg3, pjsua_acc_config jarg3_);
+  public final static native int acc_modify(int jarg1, long jarg2, pjsua_acc_config jarg2_);
+  public final static native int acc_set_online_status(int jarg1, int jarg2);
+  public final static native int acc_set_online_status2(int jarg1, int jarg2, long jarg3, pjrpid_element jarg3_);
+  public final static native int acc_set_registration(int jarg1, int jarg2);
+  public final static native int acc_get_info(int jarg1, long jarg2, pjsua_acc_info jarg2_);
+  public final static native int enum_accs(int[] jarg1, long[] jarg2);
+  public final static native int acc_enum_info(long jarg1, pjsua_acc_info jarg1_, long[] jarg2);
+  public final static native int acc_find_for_outgoing(long jarg1, pj_str_t jarg1_);
+  public final static native int acc_find_for_incoming(long jarg1);
+  public final static native int acc_create_request(int jarg1, long jarg2, long jarg3, pj_str_t jarg3_, long jarg4);
+  public final static native int acc_create_uac_contact(long jarg1, pj_pool_t jarg1_, long jarg2, pj_str_t jarg2_, int jarg3, long jarg4, pj_str_t jarg4_);
+  public final static native int acc_create_uas_contact(long jarg1, pj_pool_t jarg1_, long jarg2, pj_str_t jarg2_, int jarg3, long jarg4);
+  public final static native int acc_set_transport(int jarg1, int jarg2);
+  public final static native int PJSUA_MAX_CALLS_get();
+  public final static native int PJSUA_MAX_VID_WINS_get();
+  public final static native int PJSUA_VID_REQ_KEYFRAME_SIP_INFO_get();
+  public final static native int PJSUA_VID_REQ_KEYFRAME_RTCP_PLI_get();
+  public final static native void pjsua_call_media_info_index_set(long jarg1, pjsua_call_media_info jarg1_, long jarg2);
+  public final static native long pjsua_call_media_info_index_get(long jarg1, pjsua_call_media_info jarg1_);
+  public final static native void pjsua_call_media_info_type_set(long jarg1, pjsua_call_media_info jarg1_, long jarg2);
+  public final static native long pjsua_call_media_info_type_get(long jarg1, pjsua_call_media_info jarg1_);
+  public final static native void pjsua_call_media_info_dir_set(long jarg1, pjsua_call_media_info jarg1_, int jarg2);
+  public final static native int pjsua_call_media_info_dir_get(long jarg1, pjsua_call_media_info jarg1_);
+  public final static native void pjsua_call_media_info_status_set(long jarg1, pjsua_call_media_info jarg1_, int jarg2);
+  public final static native int pjsua_call_media_info_status_get(long jarg1, pjsua_call_media_info jarg1_);
+  public final static native long new_pjsua_call_media_info();
+  public final static native void delete_pjsua_call_media_info(long jarg1);
+  public final static native void pjsua_call_info_id_set(long jarg1, pjsua_call_info jarg1_, int jarg2);
+  public final static native int pjsua_call_info_id_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_role_set(long jarg1, pjsua_call_info jarg1_, long jarg2);
+  public final static native long pjsua_call_info_role_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_acc_id_set(long jarg1, pjsua_call_info jarg1_, int jarg2);
+  public final static native int pjsua_call_info_acc_id_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_local_info_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_call_info_local_info_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_local_contact_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_call_info_local_contact_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_remote_info_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_call_info_remote_info_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_remote_contact_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_call_info_remote_contact_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_call_id_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_call_info_call_id_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_setting_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pjsua_call_setting jarg2_);
+  public final static native long pjsua_call_info_setting_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_state_set(long jarg1, pjsua_call_info jarg1_, int jarg2);
+  public final static native int pjsua_call_info_state_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_state_text_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_call_info_state_text_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_last_status_set(long jarg1, pjsua_call_info jarg1_, int jarg2);
+  public final static native int pjsua_call_info_last_status_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_last_status_text_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_call_info_last_status_text_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_media_status_set(long jarg1, pjsua_call_info jarg1_, int jarg2);
+  public final static native int pjsua_call_info_media_status_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_media_dir_set(long jarg1, pjsua_call_info jarg1_, int jarg2);
+  public final static native int pjsua_call_info_media_dir_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_conf_slot_set(long jarg1, pjsua_call_info jarg1_, int jarg2);
+  public final static native int pjsua_call_info_conf_slot_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_media_cnt_set(long jarg1, pjsua_call_info jarg1_, long jarg2);
+  public final static native long pjsua_call_info_media_cnt_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_media_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pjsua_call_media_info jarg2_);
+  public final static native long pjsua_call_info_media_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_prov_media_cnt_set(long jarg1, pjsua_call_info jarg1_, long jarg2);
+  public final static native long pjsua_call_info_prov_media_cnt_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_prov_media_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pjsua_call_media_info jarg2_);
+  public final static native long pjsua_call_info_prov_media_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_connect_duration_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_time_val jarg2_);
+  public final static native long pjsua_call_info_connect_duration_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_total_duration_set(long jarg1, pjsua_call_info jarg1_, long jarg2, pj_time_val jarg2_);
+  public final static native long pjsua_call_info_total_duration_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_rem_offerer_set(long jarg1, pjsua_call_info jarg1_, int jarg2);
+  public final static native int pjsua_call_info_rem_offerer_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_rem_aud_cnt_set(long jarg1, pjsua_call_info jarg1_, long jarg2);
+  public final static native long pjsua_call_info_rem_aud_cnt_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native void pjsua_call_info_rem_vid_cnt_set(long jarg1, pjsua_call_info jarg1_, long jarg2);
+  public final static native long pjsua_call_info_rem_vid_cnt_get(long jarg1, pjsua_call_info jarg1_);
+  public final static native long new_pjsua_call_info();
+  public final static native void delete_pjsua_call_info(long jarg1);
+  public final static native int PJSUA_CALL_UNHOLD_get();
+  public final static native int PJSUA_CALL_UPDATE_CONTACT_get();
+  public final static native int PJSUA_CALL_INCLUDE_DISABLED_MEDIA_get();
+  public final static native int PJSUA_CALL_NO_SDP_OFFER_get();
+  public final static native void pjsua_stream_info_type_set(long jarg1, pjsua_stream_info jarg1_, long jarg2);
+  public final static native long pjsua_stream_info_type_get(long jarg1, pjsua_stream_info jarg1_);
+  public final static native long new_pjsua_stream_info();
+  public final static native void delete_pjsua_stream_info(long jarg1);
+  public final static native void pjsua_stream_stat_rtcp_set(long jarg1, pjsua_stream_stat jarg1_, long jarg2);
+  public final static native long pjsua_stream_stat_rtcp_get(long jarg1, pjsua_stream_stat jarg1_);
+  public final static native void pjsua_stream_stat_jbuf_set(long jarg1, pjsua_stream_stat jarg1_, long jarg2);
+  public final static native long pjsua_stream_stat_jbuf_get(long jarg1, pjsua_stream_stat jarg1_);
+  public final static native long new_pjsua_stream_stat();
+  public final static native void delete_pjsua_stream_stat(long jarg1);
+  public final static native void pjsua_call_vid_strm_op_param_med_idx_set(long jarg1, pjsua_call_vid_strm_op_param jarg1_, int jarg2);
+  public final static native int pjsua_call_vid_strm_op_param_med_idx_get(long jarg1, pjsua_call_vid_strm_op_param jarg1_);
+  public final static native void pjsua_call_vid_strm_op_param_dir_set(long jarg1, pjsua_call_vid_strm_op_param jarg1_, int jarg2);
+  public final static native int pjsua_call_vid_strm_op_param_dir_get(long jarg1, pjsua_call_vid_strm_op_param jarg1_);
+  public final static native void pjsua_call_vid_strm_op_param_cap_dev_set(long jarg1, pjsua_call_vid_strm_op_param jarg1_, long jarg2);
+  public final static native long pjsua_call_vid_strm_op_param_cap_dev_get(long jarg1, pjsua_call_vid_strm_op_param jarg1_);
+  public final static native long new_pjsua_call_vid_strm_op_param();
+  public final static native void delete_pjsua_call_vid_strm_op_param(long jarg1);
+  public final static native void call_setting_default(long jarg1, pjsua_call_setting jarg1_);
+  public final static native void call_vid_strm_op_param_default(long jarg1, pjsua_call_vid_strm_op_param jarg1_);
+  public final static native long call_get_max_count();
+  public final static native long call_get_count();
+  public final static native int enum_calls(int[] jarg1, long[] jarg2);
+  public final static native int call_make_call(int jarg1, long jarg2, pj_str_t jarg2_, long jarg3, pjsua_call_setting jarg3_, byte[] jarg4, long jarg5, pjsua_msg_data jarg5_, int[] jarg6);
+  public final static native int call_is_active(int jarg1);
+  public final static native int call_has_media(int jarg1);
+  public final static native int call_get_conf_port(int jarg1);
+  public final static native int call_get_info(int jarg1, long jarg2, pjsua_call_info jarg2_);
+  public final static native long call_remote_has_cap(int jarg1, int jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_);
+  public final static native int call_set_user_data(int jarg1, byte[] jarg2);
+  public final static native byte[] call_get_user_data(int jarg1);
+  public final static native int call_get_rem_nat_type(int jarg1, int[] jarg2);
+  public final static native int call_answer(int jarg1, long jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pjsua_msg_data jarg4_);
+  public final static native int call_answer2(int jarg1, long jarg2, pjsua_call_setting jarg2_, long jarg3, long jarg4, pj_str_t jarg4_, long jarg5, pjsua_msg_data jarg5_);
+  public final static native int call_hangup(int jarg1, long jarg2, long jarg3, pj_str_t jarg3_, long jarg4, pjsua_msg_data jarg4_);
+  public final static native int call_process_redirect(int jarg1, int jarg2);
+  public final static native int call_set_hold(int jarg1, long jarg2, pjsua_msg_data jarg2_);
+  public final static native int call_set_hold2(int jarg1, long jarg2, long jarg3, pjsua_msg_data jarg3_);
+  public final static native int call_reinvite(int jarg1, long jarg2, long jarg3, pjsua_msg_data jarg3_);
+  public final static native int call_reinvite2(int jarg1, long jarg2, pjsua_call_setting jarg2_, long jarg3, pjsua_msg_data jarg3_);
+  public final static native int call_update(int jarg1, long jarg2, long jarg3, pjsua_msg_data jarg3_);
+  public final static native int call_update2(int jarg1, long jarg2, pjsua_call_setting jarg2_, long jarg3, pjsua_msg_data jarg3_);
+  public final static native int call_xfer(int jarg1, long jarg2, pj_str_t jarg2_, long jarg3, pjsua_msg_data jarg3_);
+  public final static native int PJSUA_XFER_NO_REQUIRE_REPLACES_get();
+  public final static native int call_xfer_replaces(int jarg1, int jarg2, long jarg3, long jarg4, pjsua_msg_data jarg4_);
+  public final static native int call_dial_dtmf(int jarg1, long jarg2, pj_str_t jarg2_);
+  public final static native int call_send_im(int jarg1, long jarg2, pj_str_t jarg2_, long jarg3, pj_str_t jarg3_, long jarg4, pjsua_msg_data jarg4_, byte[] jarg5);
+  public final static native int call_send_typing_ind(int jarg1, int jarg2, long jarg3, pjsua_msg_data jarg3_);
+  public final static native int call_send_request(int jarg1, long jarg2, pj_str_t jarg2_, long jarg3, pjsua_msg_data jarg3_);
+  public final static native void call_hangup_all();
+  public final static native int call_dump__SWIG_0(int jarg1, int jarg2, String jarg3, long jarg4, String jarg5);
+  public final static native int call_get_vid_stream_idx(int jarg1);
+  public final static native int call_vid_stream_is_running(int jarg1, int jarg2, int jarg3);
+  public final static native int call_set_vid_strm(int jarg1, int jarg2, long jarg3, pjsua_call_vid_strm_op_param jarg3_);
+  public final static native int call_get_stream_info(int jarg1, long jarg2, long jarg3, pjsua_stream_info jarg3_);
+  public final static native int call_get_stream_stat(int jarg1, long jarg2, long jarg3, pjsua_stream_stat jarg3_);
+  public final static native int call_get_med_transport_info(int jarg1, long jarg2, long jarg3);
+  public final static native int PJSUA_MAX_BUDDIES_get();
+  public final static native int PJSUA_PRES_TIMER_get();
+  public final static native void pjsua_buddy_config_uri_set(long jarg1, pjsua_buddy_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_buddy_config_uri_get(long jarg1, pjsua_buddy_config jarg1_);
+  public final static native void pjsua_buddy_config_subscribe_set(long jarg1, pjsua_buddy_config jarg1_, int jarg2);
+  public final static native int pjsua_buddy_config_subscribe_get(long jarg1, pjsua_buddy_config jarg1_);
+  public final static native void pjsua_buddy_config_user_data_set(long jarg1, pjsua_buddy_config jarg1_, byte[] jarg2);
+  public final static native byte[] pjsua_buddy_config_user_data_get(long jarg1, pjsua_buddy_config jarg1_);
+  public final static native long new_pjsua_buddy_config();
+  public final static native void delete_pjsua_buddy_config(long jarg1);
+  public final static native void pjsua_buddy_info_id_set(long jarg1, pjsua_buddy_info jarg1_, int jarg2);
+  public final static native int pjsua_buddy_info_id_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_uri_set(long jarg1, pjsua_buddy_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_buddy_info_uri_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_contact_set(long jarg1, pjsua_buddy_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_buddy_info_contact_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_status_set(long jarg1, pjsua_buddy_info jarg1_, int jarg2);
+  public final static native int pjsua_buddy_info_status_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_status_text_set(long jarg1, pjsua_buddy_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_buddy_info_status_text_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_monitor_pres_set(long jarg1, pjsua_buddy_info jarg1_, int jarg2);
+  public final static native int pjsua_buddy_info_monitor_pres_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_sub_state_set(long jarg1, pjsua_buddy_info jarg1_, long jarg2);
+  public final static native long pjsua_buddy_info_sub_state_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_sub_state_name_set(long jarg1, pjsua_buddy_info jarg1_, String jarg2);
+  public final static native String pjsua_buddy_info_sub_state_name_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_sub_term_code_set(long jarg1, pjsua_buddy_info jarg1_, long jarg2);
+  public final static native long pjsua_buddy_info_sub_term_code_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_sub_term_reason_set(long jarg1, pjsua_buddy_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_buddy_info_sub_term_reason_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_rpid_set(long jarg1, pjsua_buddy_info jarg1_, long jarg2, pjrpid_element jarg2_);
+  public final static native long pjsua_buddy_info_rpid_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_pres_status_set(long jarg1, pjsua_buddy_info jarg1_, long jarg2);
+  public final static native long pjsua_buddy_info_pres_status_get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native void pjsua_buddy_info_buf__set(long jarg1, pjsua_buddy_info jarg1_, String jarg2);
+  public final static native String pjsua_buddy_info_buf__get(long jarg1, pjsua_buddy_info jarg1_);
+  public final static native long new_pjsua_buddy_info();
+  public final static native void delete_pjsua_buddy_info(long jarg1);
+  public final static native void buddy_config_default(long jarg1, pjsua_buddy_config jarg1_);
+  public final static native long get_buddy_count();
+  public final static native int buddy_is_valid(int jarg1);
+  public final static native int enum_buddies(int[] jarg1, long[] jarg2);
+  public final static native int buddy_find(long jarg1, pj_str_t jarg1_);
+  public final static native int buddy_get_info(int jarg1, long jarg2, pjsua_buddy_info jarg2_);
+  public final static native int buddy_set_user_data(int jarg1, byte[] jarg2);
+  public final static native byte[] buddy_get_user_data(int jarg1);
+  public final static native int buddy_add(long jarg1, pjsua_buddy_config jarg1_, int[] jarg2);
+  public final static native int buddy_del(int jarg1);
+  public final static native int buddy_subscribe_pres(int jarg1, int jarg2);
+  public final static native int buddy_update_pres(int jarg1);
+  public final static native int pres_notify(int jarg1, long jarg2, long jarg3, long jarg4, pj_str_t jarg4_, long jarg5, pj_str_t jarg5_, int jarg6, long jarg7, pjsua_msg_data jarg7_);
+  public final static native void pres_dump(int jarg1);
+  public final static native long pjsip_message_method_get();
+  public final static native long pjsip_info_method_get();
+  public final static native int im_send(int jarg1, long jarg2, pj_str_t jarg2_, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_, long jarg5, pjsua_msg_data jarg5_, byte[] jarg6);
+  public final static native int im_typing(int jarg1, long jarg2, pj_str_t jarg2_, int jarg3, long jarg4, pjsua_msg_data jarg4_);
+  public final static native int PJSUA_MEDIA_HAS_PJMEDIA_get();
+  public final static native int PJSUA_THIRD_PARTY_STREAM_HAS_GET_INFO_get();
+  public final static native int PJSUA_THIRD_PARTY_STREAM_HAS_GET_STAT_get();
+  public final static native int PJSUA_MAX_CONF_PORTS_get();
+  public final static native int PJSUA_DEFAULT_CLOCK_RATE_get();
+  public final static native int PJSUA_DEFAULT_AUDIO_FRAME_PTIME_get();
+  public final static native int PJSUA_DEFAULT_CODEC_QUALITY_get();
+  public final static native int PJSUA_DEFAULT_ILBC_MODE_get();
+  public final static native int PJSUA_DEFAULT_EC_TAIL_LEN_get();
+  public final static native int PJSUA_MAX_PLAYERS_get();
+  public final static native int PJSUA_MAX_RECORDERS_get();
+  public final static native void pjsua_media_config_clock_rate_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_clock_rate_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_snd_clock_rate_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_snd_clock_rate_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_channel_count_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_channel_count_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_audio_frame_ptime_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_audio_frame_ptime_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_max_media_ports_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_max_media_ports_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_has_ioqueue_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_has_ioqueue_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_thread_cnt_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_thread_cnt_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_quality_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_quality_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_ptime_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_ptime_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_no_vad_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_no_vad_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_ilbc_mode_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_ilbc_mode_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_tx_drop_pct_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_tx_drop_pct_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_rx_drop_pct_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_rx_drop_pct_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_ec_options_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_ec_options_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_ec_tail_len_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_ec_tail_len_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_snd_rec_latency_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_snd_rec_latency_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_snd_play_latency_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_snd_play_latency_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_jb_init_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_jb_init_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_jb_min_pre_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_jb_min_pre_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_jb_max_pre_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_jb_max_pre_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_jb_max_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_jb_max_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_enable_ice_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_enable_ice_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_ice_max_host_cands_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_ice_max_host_cands_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_ice_opt_set(long jarg1, pjsua_media_config jarg1_, long jarg2, pj_ice_sess_options jarg2_);
+  public final static native long pjsua_media_config_ice_opt_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_ice_no_rtcp_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_ice_no_rtcp_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_ice_always_update_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_ice_always_update_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_enable_turn_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_enable_turn_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_turn_server_set(long jarg1, pjsua_media_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_media_config_turn_server_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_turn_conn_type_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_turn_conn_type_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_turn_auth_cred_set(long jarg1, pjsua_media_config jarg1_, long jarg2);
+  public final static native long pjsua_media_config_turn_auth_cred_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_snd_auto_close_time_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_snd_auto_close_time_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_vid_preview_enable_native_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_vid_preview_enable_native_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_no_smart_media_update_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_no_smart_media_update_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_media_config_no_rtcp_sdes_bye_set(long jarg1, pjsua_media_config jarg1_, int jarg2);
+  public final static native int pjsua_media_config_no_rtcp_sdes_bye_get(long jarg1, pjsua_media_config jarg1_);
+  public final static native long new_pjsua_media_config();
+  public final static native void delete_pjsua_media_config(long jarg1);
+  public final static native void media_config_default(long jarg1, pjsua_media_config jarg1_);
+  public final static native void pjsua_codec_info_codec_id_set(long jarg1, pjsua_codec_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_codec_info_codec_id_get(long jarg1, pjsua_codec_info jarg1_);
+  public final static native void pjsua_codec_info_priority_set(long jarg1, pjsua_codec_info jarg1_, short jarg2);
+  public final static native short pjsua_codec_info_priority_get(long jarg1, pjsua_codec_info jarg1_);
+  public final static native void pjsua_codec_info_desc_set(long jarg1, pjsua_codec_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_codec_info_desc_get(long jarg1, pjsua_codec_info jarg1_);
+  public final static native void pjsua_codec_info_buf__set(long jarg1, pjsua_codec_info jarg1_, String jarg2);
+  public final static native String pjsua_codec_info_buf__get(long jarg1, pjsua_codec_info jarg1_);
+  public final static native long new_pjsua_codec_info();
+  public final static native void delete_pjsua_codec_info(long jarg1);
+  public final static native void pjsua_conf_port_info_slot_id_set(long jarg1, pjsua_conf_port_info jarg1_, int jarg2);
+  public final static native int pjsua_conf_port_info_slot_id_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_name_set(long jarg1, pjsua_conf_port_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long pjsua_conf_port_info_name_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_format_set(long jarg1, pjsua_conf_port_info jarg1_, long jarg2);
+  public final static native long pjsua_conf_port_info_format_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_clock_rate_set(long jarg1, pjsua_conf_port_info jarg1_, long jarg2);
+  public final static native long pjsua_conf_port_info_clock_rate_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_channel_count_set(long jarg1, pjsua_conf_port_info jarg1_, long jarg2);
+  public final static native long pjsua_conf_port_info_channel_count_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_samples_per_frame_set(long jarg1, pjsua_conf_port_info jarg1_, long jarg2);
+  public final static native long pjsua_conf_port_info_samples_per_frame_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_bits_per_sample_set(long jarg1, pjsua_conf_port_info jarg1_, long jarg2);
+  public final static native long pjsua_conf_port_info_bits_per_sample_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_tx_level_adj_set(long jarg1, pjsua_conf_port_info jarg1_, float jarg2);
+  public final static native float pjsua_conf_port_info_tx_level_adj_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_rx_level_adj_set(long jarg1, pjsua_conf_port_info jarg1_, float jarg2);
+  public final static native float pjsua_conf_port_info_rx_level_adj_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_listener_cnt_set(long jarg1, pjsua_conf_port_info jarg1_, long jarg2);
+  public final static native long pjsua_conf_port_info_listener_cnt_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native void pjsua_conf_port_info_listeners_set(long jarg1, pjsua_conf_port_info jarg1_, int[] jarg2);
+  public final static native int[] pjsua_conf_port_info_listeners_get(long jarg1, pjsua_conf_port_info jarg1_);
+  public final static native long new_pjsua_conf_port_info();
+  public final static native void delete_pjsua_conf_port_info(long jarg1);
+  public final static native void pjsua_media_transport_skinfo_set(long jarg1, pjsua_media_transport jarg1_, long jarg2);
+  public final static native long pjsua_media_transport_skinfo_get(long jarg1, pjsua_media_transport jarg1_);
+  public final static native void pjsua_media_transport_transport_set(long jarg1, pjsua_media_transport jarg1_, long jarg2);
+  public final static native long pjsua_media_transport_transport_get(long jarg1, pjsua_media_transport jarg1_);
+  public final static native long new_pjsua_media_transport();
+  public final static native void delete_pjsua_media_transport(long jarg1);
+  public final static native long conf_get_max_ports();
+  public final static native long conf_get_active_ports();
+  public final static native int enum_conf_ports(int[] jarg1, long[] jarg2);
+  public final static native int conf_get_port_info(int jarg1, long jarg2, pjsua_conf_port_info jarg2_);
+  public final static native int conf_add_port(long jarg1, pj_pool_t jarg1_, long jarg2, pjmedia_port jarg2_, int[] jarg3);
+  public final static native int conf_remove_port(int jarg1);
+  public final static native int conf_connect(int jarg1, int jarg2);
+  public final static native int conf_disconnect(int jarg1, int jarg2);
+  public final static native int conf_adjust_tx_level(int jarg1, float jarg2);
+  public final static native int conf_adjust_rx_level(int jarg1, float jarg2);
+  public final static native int conf_get_signal_level(int jarg1, long[] jarg2, long[] jarg3);
+  public final static native int player_create(long jarg1, pj_str_t jarg1_, long jarg2, int[] jarg3);
+  public final static native int playlist_create(long[] jarg1, long jarg2, long jarg3, pj_str_t jarg3_, long jarg4, int[] jarg5);
+  public final static native int player_get_conf_port(int jarg1);
+  public final static native int player_get_port(int jarg1, long jarg2);
+  public final static native int player_get_info(int jarg1, long jarg2);
+  public final static native int player_get_pos(int jarg1);
+  public final static native int player_set_pos(int jarg1, long jarg2);
+  public final static native int player_destroy(int jarg1);
+  public final static native int recorder_create(long jarg1, pj_str_t jarg1_, long jarg2, byte[] jarg3, int jarg4, long jarg5, int[] jarg6);
+  public final static native int recorder_get_conf_port(int jarg1);
+  public final static native int recorder_get_port(int jarg1, long jarg2);
+  public final static native int recorder_destroy(int jarg1);
+  public final static native int enum_aud_devs(long jarg1, long[] jarg2);
+  public final static native int enum_snd_devs(long jarg1, pjmedia_snd_dev_info jarg1_, long[] jarg2);
+  public final static native int get_snd_dev(int[] jarg1, int[] jarg2);
+  public final static native int set_snd_dev(int jarg1, int jarg2);
+  public final static native int set_null_snd_dev();
+  public final static native long set_no_snd_dev();
+  public final static native int set_ec(long jarg1, long jarg2);
+  public final static native int get_ec_tail(long jarg1);
+  public final static native int snd_is_active();
+  public final static native int snd_set_setting(long jarg1, byte[] jarg2, int jarg3);
+  public final static native int snd_get_setting(long jarg1, byte[] jarg2);
+  public final static native int enum_codecs(long jarg1, pjsua_codec_info jarg1_, long[] jarg2);
+  public final static native int codec_set_priority(long jarg1, pj_str_t jarg1_, short jarg2);
+  public final static native int codec_get_param(long jarg1, pj_str_t jarg1_, long jarg2);
+  public final static native int codec_set_param(long jarg1, pj_str_t jarg1_, long jarg2);
+  public final static native long vid_dev_count();
+  public final static native int vid_dev_get_info(long jarg1, long jarg2);
+  public final static native int vid_enum_devs(long jarg1, long[] jarg2);
+  public final static native void pjsua_vid_preview_param_rend_id_set(long jarg1, pjsua_vid_preview_param jarg1_, long jarg2);
+  public final static native long pjsua_vid_preview_param_rend_id_get(long jarg1, pjsua_vid_preview_param jarg1_);
+  public final static native void pjsua_vid_preview_param_show_set(long jarg1, pjsua_vid_preview_param jarg1_, int jarg2);
+  public final static native int pjsua_vid_preview_param_show_get(long jarg1, pjsua_vid_preview_param jarg1_);
+  public final static native void pjsua_vid_preview_param_wnd_flags_set(long jarg1, pjsua_vid_preview_param jarg1_, long jarg2);
+  public final static native long pjsua_vid_preview_param_wnd_flags_get(long jarg1, pjsua_vid_preview_param jarg1_);
+  public final static native void pjsua_vid_preview_param_format_set(long jarg1, pjsua_vid_preview_param jarg1_, long jarg2);
+  public final static native long pjsua_vid_preview_param_format_get(long jarg1, pjsua_vid_preview_param jarg1_);
+  public final static native long new_pjsua_vid_preview_param();
+  public final static native void delete_pjsua_vid_preview_param(long jarg1);
+  public final static native void vid_preview_param_default(long jarg1, pjsua_vid_preview_param jarg1_);
+  public final static native int vid_preview_has_native(long jarg1);
+  public final static native int vid_preview_start(long jarg1, long jarg2, pjsua_vid_preview_param jarg2_);
+  public final static native int vid_preview_get_win(long jarg1);
+  public final static native int vid_preview_stop(long jarg1);
+  public final static native void pjsua_vid_win_info_is_native_set(long jarg1, pjsua_vid_win_info jarg1_, int jarg2);
+  public final static native int pjsua_vid_win_info_is_native_get(long jarg1, pjsua_vid_win_info jarg1_);
+  public final static native void pjsua_vid_win_info_hwnd_set(long jarg1, pjsua_vid_win_info jarg1_, long jarg2);
+  public final static native long pjsua_vid_win_info_hwnd_get(long jarg1, pjsua_vid_win_info jarg1_);
+  public final static native void pjsua_vid_win_info_rdr_dev_set(long jarg1, pjsua_vid_win_info jarg1_, long jarg2);
+  public final static native long pjsua_vid_win_info_rdr_dev_get(long jarg1, pjsua_vid_win_info jarg1_);
+  public final static native void pjsua_vid_win_info_show_set(long jarg1, pjsua_vid_win_info jarg1_, int jarg2);
+  public final static native int pjsua_vid_win_info_show_get(long jarg1, pjsua_vid_win_info jarg1_);
+  public final static native void pjsua_vid_win_info_pos_set(long jarg1, pjsua_vid_win_info jarg1_, long jarg2);
+  public final static native long pjsua_vid_win_info_pos_get(long jarg1, pjsua_vid_win_info jarg1_);
+  public final static native void pjsua_vid_win_info_size_set(long jarg1, pjsua_vid_win_info jarg1_, long jarg2);
+  public final static native long pjsua_vid_win_info_size_get(long jarg1, pjsua_vid_win_info jarg1_);
+  public final static native long new_pjsua_vid_win_info();
+  public final static native void delete_pjsua_vid_win_info(long jarg1);
+  public final static native int vid_enum_wins(int[] jarg1, long[] jarg2);
+  public final static native int vid_win_get_info(int jarg1, long jarg2, pjsua_vid_win_info jarg2_);
+  public final static native int vid_win_set_show(int jarg1, int jarg2);
+  public final static native int vid_win_set_pos(int jarg1, long jarg2);
+  public final static native int vid_win_set_size(int jarg1, long jarg2);
+  public final static native int vid_win_rotate(int jarg1, int jarg2);
+  public final static native int vid_enum_codecs(long jarg1, pjsua_codec_info jarg1_, long[] jarg2);
+  public final static native int vid_codec_set_priority(long jarg1, pj_str_t jarg1_, short jarg2);
+  public final static native int vid_codec_get_param(long jarg1, pj_str_t jarg1_, long jarg2);
+  public final static native int vid_codec_set_param(long jarg1, pj_str_t jarg1_, long jarg2);
+  public final static native void dynamic_factory_shared_lib_path_set(long jarg1, dynamic_factory jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long dynamic_factory_shared_lib_path_get(long jarg1, dynamic_factory jarg1_);
+  public final static native void dynamic_factory_init_factory_name_set(long jarg1, dynamic_factory jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long dynamic_factory_init_factory_name_get(long jarg1, dynamic_factory jarg1_);
+  public final static native long new_dynamic_factory();
+  public final static native void delete_dynamic_factory(long jarg1);
+  public final static native void csipsimple_config_use_compact_form_sdp_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_use_compact_form_sdp_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_use_compact_form_headers_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_use_compact_form_headers_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_add_bandwidth_tias_in_sdp_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_add_bandwidth_tias_in_sdp_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_use_no_update_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_use_no_update_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_use_zrtp_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_use_zrtp_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_extra_aud_codecs_cnt_set(long jarg1, csipsimple_config jarg1_, long jarg2);
+  public final static native long csipsimple_config_extra_aud_codecs_cnt_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_extra_aud_codecs_set(long jarg1, csipsimple_config jarg1_, long[] jarg2);
+  public final static native long[] csipsimple_config_extra_aud_codecs_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_extra_vid_codecs_cnt_set(long jarg1, csipsimple_config jarg1_, long jarg2);
+  public final static native long csipsimple_config_extra_vid_codecs_cnt_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_extra_vid_codecs_set(long jarg1, csipsimple_config jarg1_, long[] jarg2);
+  public final static native long[] csipsimple_config_extra_vid_codecs_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_extra_vid_codecs_destroy_set(long jarg1, csipsimple_config jarg1_, long[] jarg2);
+  public final static native long[] csipsimple_config_extra_vid_codecs_destroy_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_vid_converter_set(long jarg1, csipsimple_config jarg1_, long jarg2, dynamic_factory jarg2_);
+  public final static native long csipsimple_config_vid_converter_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_storage_folder_set(long jarg1, csipsimple_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long csipsimple_config_storage_folder_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_audio_implementation_set(long jarg1, csipsimple_config jarg1_, long jarg2, dynamic_factory jarg2_);
+  public final static native long csipsimple_config_audio_implementation_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_video_render_implementation_set(long jarg1, csipsimple_config jarg1_, long jarg2, dynamic_factory jarg2_);
+  public final static native long csipsimple_config_video_render_implementation_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_video_capture_implementation_set(long jarg1, csipsimple_config jarg1_, long jarg2, dynamic_factory jarg2_);
+  public final static native long csipsimple_config_video_capture_implementation_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_tcp_keep_alive_interval_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_tcp_keep_alive_interval_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_tls_keep_alive_interval_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_tls_keep_alive_interval_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_tsx_t1_timeout_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_tsx_t1_timeout_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_tsx_t2_timeout_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_tsx_t2_timeout_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_tsx_t4_timeout_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_tsx_t4_timeout_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_tsx_td_timeout_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_tsx_td_timeout_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_disable_tcp_switch_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_disable_tcp_switch_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_disable_rport_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_disable_rport_get(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_config_use_noise_suppressor_set(long jarg1, csipsimple_config jarg1_, int jarg2);
+  public final static native int csipsimple_config_use_noise_suppressor_get(long jarg1, csipsimple_config jarg1_);
+  public final static native long new_csipsimple_config();
+  public final static native void delete_csipsimple_config(long jarg1);
+  public final static native void csipsimple_acc_config_use_zrtp_set(long jarg1, csipsimple_acc_config jarg1_, int jarg2);
+  public final static native int csipsimple_acc_config_use_zrtp_get(long jarg1, csipsimple_acc_config jarg1_);
+  public final static native void csipsimple_acc_config_p_preferred_identity_set(long jarg1, csipsimple_acc_config jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long csipsimple_acc_config_p_preferred_identity_get(long jarg1, csipsimple_acc_config jarg1_);
+  public final static native long new_csipsimple_acc_config();
+  public final static native void delete_csipsimple_acc_config(long jarg1);
+  public final static native int send_dtmf_info(int jarg1, long jarg2, pj_str_t jarg2_);
+  public final static native long call_dump__SWIG_1(int jarg1, int jarg2, String jarg3);
+  public final static native long call_secure_media_info(int jarg1);
+  public final static native int call_secure_sig_level(int jarg1);
+  public final static native long get_error_message(int jarg1);
+  public final static native int get_event_status_code(long jarg1, pjsip_event jarg1_);
+  public final static native int get_event_reason_code(long jarg1, pjsip_event jarg1_);
+  public final static native void csipsimple_config_default(long jarg1, csipsimple_config jarg1_);
+  public final static native void csipsimple_acc_config_default(long jarg1, csipsimple_acc_config jarg1_);
+  public final static native int csipsimple_init(long jarg1, pjsua_config jarg1_, long jarg2, pjsua_logging_config jarg2_, long jarg3, pjsua_media_config jarg3_, long jarg4, csipsimple_config jarg4_, Object jarg5);
+  public final static native int csipsimple_destroy(long jarg1);
+  public final static native int csipsimple_set_acc_user_data(int jarg1, long jarg2, csipsimple_acc_config jarg2_);
+  public final static native int csipsimple_init_acc_msg_data(long jarg1, pj_pool_t jarg1_, int jarg2, long jarg3, pjsua_msg_data jarg3_);
+  public final static native int csipsimple_msg_data_add_string_hdr(long jarg1, pj_pool_t jarg1_, long jarg2, pjsua_msg_data jarg2_, long jarg3, pj_str_t jarg3_, long jarg4, pj_str_t jarg4_);
+  public final static native int pj_timer_fire(int jarg1);
+  public final static native int update_transport(long jarg1, pj_str_t jarg1_);
+  public final static native int vid_set_android_renderer(int jarg1, Object jarg2);
+  public final static native int vid_set_android_capturer(Object jarg1);
+  public final static native int set_turn_credentials(long jarg1, pj_str_t jarg1_, long jarg2, pj_str_t jarg2_, long jarg3, pj_str_t jarg3_, long jarg4);
+  public final static native long get_rx_data_header(long jarg1, pj_str_t jarg1_, long jarg2);
+  public final static native void css_on_call_state(int jarg1, long jarg2, pjsip_event jarg2_);
+  public final static native void css_on_call_media_state(int jarg1);
+  public final static native void zrtp_state_info_call_id_set(long jarg1, zrtp_state_info jarg1_, int jarg2);
+  public final static native int zrtp_state_info_call_id_get(long jarg1, zrtp_state_info jarg1_);
+  public final static native void zrtp_state_info_secure_set(long jarg1, zrtp_state_info jarg1_, int jarg2);
+  public final static native int zrtp_state_info_secure_get(long jarg1, zrtp_state_info jarg1_);
+  public final static native void zrtp_state_info_sas_set(long jarg1, zrtp_state_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long zrtp_state_info_sas_get(long jarg1, zrtp_state_info jarg1_);
+  public final static native void zrtp_state_info_cipher_set(long jarg1, zrtp_state_info jarg1_, long jarg2, pj_str_t jarg2_);
+  public final static native long zrtp_state_info_cipher_get(long jarg1, zrtp_state_info jarg1_);
+  public final static native void zrtp_state_info_sas_verified_set(long jarg1, zrtp_state_info jarg1_, int jarg2);
+  public final static native int zrtp_state_info_sas_verified_get(long jarg1, zrtp_state_info jarg1_);
+  public final static native long new_zrtp_state_info();
+  public final static native void delete_zrtp_state_info(long jarg1);
+  public final static native void jzrtp_SASVerified(int jarg1);
+  public final static native void jzrtp_SASRevoked(int jarg1);
+  public final static native long jzrtp_getInfoFromCall(int jarg1);
+  public final static native int codecs_get_nbr();
+  public final static native long codecs_get_id(int jarg1);
+  public final static native int codecs_vid_get_nbr();
+  public final static native long codecs_vid_get_id(int jarg1);
+  public final static native int codec_set_frames_per_packet(long jarg1, pj_str_t jarg1_, int jarg2);
+  public final static native int codec_h264_set_profile(long jarg1, long jarg2, long jarg3, long jarg4, long jarg5, long jarg6, long jarg7);
+
+  public static void SwigDirector_Callback_on_call_state(Callback self, int call_id, long e) {
+    self.on_call_state(call_id, (e == 0) ? null : new pjsip_event(e, false));
+  }
+  public static void SwigDirector_Callback_on_incoming_call(Callback self, int acc_id, int call_id, long rdata) {
+    self.on_incoming_call(acc_id, call_id, (rdata == 0) ? null : new SWIGTYPE_p_pjsip_rx_data(rdata, false));
+  }
+  public static void SwigDirector_Callback_on_call_tsx_state(Callback self, int call_id, long tsx, long e) {
+    self.on_call_tsx_state(call_id, (tsx == 0) ? null : new SWIGTYPE_p_pjsip_transaction(tsx, false), (e == 0) ? null : new pjsip_event(e, false));
+  }
+  public static void SwigDirector_Callback_on_call_media_state(Callback self, int call_id) {
+    self.on_call_media_state(call_id);
+  }
+  public static void SwigDirector_Callback_on_call_sdp_created(Callback self, int call_id, long sdp, long pool, long rem_sdp) {
+    self.on_call_sdp_created(call_id, (sdp == 0) ? null : new SWIGTYPE_p_pjmedia_sdp_session(sdp, false), (pool == 0) ? null : new pj_pool_t(pool, false), (rem_sdp == 0) ? null : new SWIGTYPE_p_pjmedia_sdp_session(rem_sdp, false));
+  }
+  public static void SwigDirector_Callback_on_stream_created(Callback self, int call_id, long strm, long stream_idx, long p_port) {
+    self.on_stream_created(call_id, (strm == 0) ? null : new SWIGTYPE_p_pjmedia_stream(strm, false), stream_idx, (p_port == 0) ? null : new SWIGTYPE_p_p_pjmedia_port(p_port, false));
+  }
+  public static void SwigDirector_Callback_on_stream_destroyed(Callback self, int call_id, long strm, long stream_idx) {
+    self.on_stream_destroyed(call_id, (strm == 0) ? null : new SWIGTYPE_p_pjmedia_stream(strm, false), stream_idx);
+  }
+  public static void SwigDirector_Callback_on_dtmf_digit(Callback self, int call_id, int digit) {
+    self.on_dtmf_digit(call_id, digit);
+  }
+  public static void SwigDirector_Callback_on_call_transfer_request(Callback self, int call_id, long dst, long code) {
+    self.on_call_transfer_request(call_id, (dst == 0) ? null : new pj_str_t(dst, false), (code == 0) ? null : new SWIGTYPE_p_pjsip_status_code(code, false));
+  }
+  public static void SwigDirector_Callback_on_call_transfer_status(Callback self, int call_id, int st_code, long st_text, int final_, long p_cont) {
+    self.on_call_transfer_status(call_id, st_code, (st_text == 0) ? null : new pj_str_t(st_text, false), final_, (p_cont == 0) ? null : new SWIGTYPE_p_int(p_cont, false));
+  }
+  public static void SwigDirector_Callback_on_call_replace_request(Callback self, int call_id, long rdata, long st_code, long st_text) {
+    self.on_call_replace_request(call_id, (rdata == 0) ? null : new SWIGTYPE_p_pjsip_rx_data(rdata, false), (st_code == 0) ? null : new SWIGTYPE_p_int(st_code, false), (st_text == 0) ? null : new pj_str_t(st_text, false));
+  }
+  public static void SwigDirector_Callback_on_call_replaced(Callback self, int old_call_id, int new_call_id) {
+    self.on_call_replaced(old_call_id, new_call_id);
+  }
+  public static void SwigDirector_Callback_on_reg_state(Callback self, int acc_id) {
+    self.on_reg_state(acc_id);
+  }
+  public static void SwigDirector_Callback_on_buddy_state(Callback self, int buddy_id) {
+    self.on_buddy_state(buddy_id);
+  }
+  public static void SwigDirector_Callback_on_pager(Callback self, int call_id, long from, long to, long contact, long mime_type, long body) {
+    self.on_pager(call_id, (from == 0) ? null : new pj_str_t(from, false), (to == 0) ? null : new pj_str_t(to, false), (contact == 0) ? null : new pj_str_t(contact, false), (mime_type == 0) ? null : new pj_str_t(mime_type, false), (body == 0) ? null : new pj_str_t(body, false));
+  }
+  public static void SwigDirector_Callback_on_pager2(Callback self, int call_id, long from, long to, long contact, long mime_type, long body, long rdata) {
+    self.on_pager2(call_id, (from == 0) ? null : new pj_str_t(from, false), (to == 0) ? null : new pj_str_t(to, false), (contact == 0) ? null : new pj_str_t(contact, false), (mime_type == 0) ? null : new pj_str_t(mime_type, false), (body == 0) ? null : new pj_str_t(body, false), (rdata == 0) ? null : new SWIGTYPE_p_pjsip_rx_data(rdata, false));
+  }
+  public static void SwigDirector_Callback_on_pager_status(Callback self, int call_id, long to, long body, int status, long reason) {
+    self.on_pager_status(call_id, (to == 0) ? null : new pj_str_t(to, false), (body == 0) ? null : new pj_str_t(body, false), pjsip_status_code.swigToEnum(status), (reason == 0) ? null : new pj_str_t(reason, false));
+  }
+  public static void SwigDirector_Callback_on_pager_status2(Callback self, int call_id, long to, long body, int status, long reason, long tdata, long rdata) {
+    self.on_pager_status2(call_id, (to == 0) ? null : new pj_str_t(to, false), (body == 0) ? null : new pj_str_t(body, false), pjsip_status_code.swigToEnum(status), (reason == 0) ? null : new pj_str_t(reason, false), (tdata == 0) ? null : new SWIGTYPE_p_pjsip_tx_data(tdata, false), (rdata == 0) ? null : new SWIGTYPE_p_pjsip_rx_data(rdata, false));
+  }
+  public static void SwigDirector_Callback_on_typing(Callback self, int call_id, long from, long to, long contact, int is_typing) {
+    self.on_typing(call_id, (from == 0) ? null : new pj_str_t(from, false), (to == 0) ? null : new pj_str_t(to, false), (contact == 0) ? null : new pj_str_t(contact, false), is_typing);
+  }
+  public static void SwigDirector_Callback_on_nat_detect(Callback self, long res) {
+    self.on_nat_detect((res == 0) ? null : new pj_stun_nat_detect_result(res, false));
+  }
+  public static int SwigDirector_Callback_on_call_redirected(Callback self, int call_id, long target) {
+    return (self.on_call_redirected(call_id, (target == 0) ? null : new pj_str_t(target, false))).swigValue();
+  }
+  public static void SwigDirector_Callback_on_mwi_info(Callback self, int acc_id, long mime_type, long body) {
+    self.on_mwi_info(acc_id, (mime_type == 0) ? null : new pj_str_t(mime_type, false), (body == 0) ? null : new pj_str_t(body, false));
+  }
+  public static void SwigDirector_Callback_on_call_media_transport_state(Callback self, int call_id, long info) {
+    self.on_call_media_transport_state(call_id, (info == 0) ? null : new pjsua_med_tp_state_info(info, false));
+  }
+  public static int SwigDirector_Callback_on_validate_audio_clock_rate(Callback self, int clock_rate) {
+    return self.on_validate_audio_clock_rate(clock_rate);
+  }
+  public static void SwigDirector_Callback_on_setup_audio(Callback self, int before_init) {
+    self.on_setup_audio(before_init);
+  }
+  public static void SwigDirector_Callback_on_teardown_audio(Callback self) {
+    self.on_teardown_audio();
+  }
+  public static int SwigDirector_Callback_on_set_micro_source(Callback self) {
+    return self.on_set_micro_source();
+  }
+  public static int SwigDirector_Callback_timer_schedule(Callback self, int entry, int entryId, int time) {
+    return self.timer_schedule(entry, entryId, time);
+  }
+  public static int SwigDirector_Callback_timer_cancel(Callback self, int entry, int entryId) {
+    return self.timer_cancel(entry, entryId);
+  }
+  public static void SwigDirector_ZrtpCallback_on_zrtp_show_sas(ZrtpCallback self, int call_id, long sas, int verified) {
+    self.on_zrtp_show_sas(call_id, (sas == 0) ? null : new pj_str_t(sas, false), verified);
+  }
+  public static void SwigDirector_ZrtpCallback_on_zrtp_update_transport(ZrtpCallback self, int call_id) {
+    self.on_zrtp_update_transport(call_id);
+  }
+  public static void SwigDirector_MobileRegHandlerCallback_on_save_contact(MobileRegHandlerCallback self, int acc_id, long contact, int expires) {
+    self.on_save_contact(acc_id, new pj_str_t(contact, false), expires);
+  }
+  public static long SwigDirector_MobileRegHandlerCallback_on_restore_contact(MobileRegHandlerCallback self, int acc_id) {
+    return pj_str_t.getCPtr(self.on_restore_contact(acc_id));
+  }
+  public static void SwigDirector_EarlyLockCallback_on_create_early_lock(EarlyLockCallback self) {
+    self.on_create_early_lock();
+  }
+
+  private final static native void swig_module_init();
+  static {
+    swig_module_init();
+  }
+}
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int__int.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int__int.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int__int.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int__int {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int__int(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int__int() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int__int obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_int_p_pjsip_rx_data__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_int_p_q_const__pj_str_t_int_p_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjmedia_sdp_session_p_pj_pool_t_p_q_const__pjmedia_sdp_session__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjmedia_stream_unsigned_int_p_p_pjmedia_port__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_event__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_event__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_event__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsip_event__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsip_event__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsip_event__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsip_event__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_evsub__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_evsub__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_evsub__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsip_evsub__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsip_evsub__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsip_evsub__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsip_evsub__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsip_evsub_p_pjsip_event__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsip_rx_data_p_int_p_pj_str_t_p_pjsua_call_setting__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsip_transaction_p_pjsip_event__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_mwi_info__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_mwi_info__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_mwi_info__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsua_mwi_info__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsua_mwi_info__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsua_mwi_info__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsua_mwi_info__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_reg_info__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_reg_info__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_reg_info__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsua_reg_info__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsua_reg_info__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsua_reg_info__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsua_reg_info__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsua_srv_pres_int_p_q_const__pj_str_t_p_pjsip_rx_data_p_enum_pjsip_status_code_p_pj_str_t_p_pjsua_msg_data__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_pjsua_srv_pres_p_q_const__pj_str_t_pjsip_evsub_state_p_pjsip_event__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__char_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__char_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__char_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__char_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__char_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__char_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__char_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_enum_pjsip_status_code_p_pjsua_call_setting__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_int_p_pjsip_rx_data_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_q_const__pj_str_t_p_pjsip_rx_data_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pj_str_t_p_q_const__pj_str_t_p_void_enum_pjsip_status_code_p_q_const__pj_str_t_p_pjsip_tx_data_p_pjsip_rx_data_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pjmedia_sdp_session_p_void_p_enum_pjsip_status_code_p_pjsua_call_setting__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pjsip_uri_p_q_const__pjsip_event__pjsip_redirect_op obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_p_q_const__pjsua_med_tp_state_info__int obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_pj_ice_strans_op_int_p_void__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_event__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_int_unsigned_int_p_pjmedia_transport_unsigned_int__p_pjmedia_transport obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port__int.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port__int.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port__int.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_p_pjmedia_port__int {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_p_pjmedia_port__int(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_p_pjmedia_port__int() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_p_pjmedia_port__int obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_p_pjmedia_port_enum_pjmedia_dir__p_pjmedia_clock_src obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_p_pjmedia_port_p_pjmedia_frame__int obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_p_q_const__pj_stun_nat_detect_result__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_p_q_const__pj_stun_resolve_result__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_p_q_const__pjsip_rx_data_p_int__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_void__void.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_void__void.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_f_p_void__void.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_f_p_void__void {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_f_p_void__void(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_f_p_void__void() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_f_p_void__void obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_int.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_int.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_int.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_int {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_int(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_int() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_int obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_p_pjmedia_port.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_p_pjmedia_port.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_p_pjmedia_port.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_p_pjmedia_port {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_p_pjmedia_port(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_p_pjmedia_port() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_p_pjmedia_port obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_p_pjsip_tx_data.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_p_pjsip_tx_data.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_p_pjsip_tx_data.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_p_pjsip_tx_data {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_p_pjsip_tx_data(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_p_pjsip_tx_data() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_p_pjsip_tx_data obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_block.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_block.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_block.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_pool_block {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_pool_block(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_pool_block() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_pool_block obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_callback.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_callback.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_callback.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_pool_callback {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_pool_callback(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_pool_callback() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_pool_callback obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_factory.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_factory.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_pool_factory.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_pool_factory {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_pool_factory(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_pool_factory() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_pool_factory obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_qos_wmm_prio.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_qos_wmm_prio.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_qos_wmm_prio.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_qos_wmm_prio {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_qos_wmm_prio(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_qos_wmm_prio() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_qos_wmm_prio obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_sockaddr.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_sockaddr.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_sockaddr.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_sockaddr {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_sockaddr(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_sockaddr() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_sockaddr obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_sockopt_params.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_sockopt_params.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_sockopt_params.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_sockopt_params {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_sockopt_params(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_sockopt_params() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_sockopt_params obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_ssl_cipher.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_ssl_cipher.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_ssl_cipher.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_ssl_cipher {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_ssl_cipher(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_ssl_cipher() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_ssl_cipher obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_stun_auth_cred.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_stun_auth_cred.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_stun_auth_cred.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_stun_auth_cred {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_stun_auth_cred(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_stun_auth_cred() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_stun_auth_cred obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_timer_entry.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_timer_entry.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pj_timer_entry.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pj_timer_entry {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pj_timer_entry(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pj_timer_entry() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pj_timer_entry obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_aud_dev_cap.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_aud_dev_cap.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_aud_dev_cap.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_aud_dev_cap {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_aud_dev_cap(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_aud_dev_cap() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_aud_dev_cap obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_aud_dev_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_aud_dev_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_aud_dev_info.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_aud_dev_info {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_aud_dev_info(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_aud_dev_info() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_aud_dev_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_codec_param.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_codec_param.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_codec_param.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_codec_param {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_codec_param(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_codec_param() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_codec_param obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_coord.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_coord.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_coord.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_coord {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_coord(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_coord() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_coord obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_endpt.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_endpt.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_endpt.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_endpt {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_endpt(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_endpt() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_endpt obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_format.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_format.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_format.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_format {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_format(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_format() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_format obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_jb_state.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_jb_state.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_jb_state.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_jb_state {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_jb_state(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_jb_state() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_jb_state obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_rect_size.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_rect_size.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_rect_size.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_rect_size {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_rect_size(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_rect_size() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_rect_size obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_rtcp_stat.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_rtcp_stat.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_rtcp_stat.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_rtcp_stat {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_rtcp_stat(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_rtcp_stat() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_rtcp_stat obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_sdp_session.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_sdp_session.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_sdp_session.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_sdp_session {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_sdp_session(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_sdp_session() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_sdp_session obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_sock_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_sock_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_sock_info.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_sock_info {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_sock_info(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_sock_info() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_sock_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_stream.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_stream.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_stream.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_stream {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_stream(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_stream() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_stream obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_transport.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_transport.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_transport.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_transport {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_transport(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_transport() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_transport obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_transport_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_transport_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_transport_info.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_transport_info {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_transport_info(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_transport_info() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_transport_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_type.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_type.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_type.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_type {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_type(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_type() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_type obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_codec_param.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_codec_param.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_codec_param.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_vid_codec_param {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_vid_codec_param(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_vid_codec_param() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_vid_codec_param obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_hwnd.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_hwnd.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_hwnd.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_vid_dev_hwnd {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_vid_dev_hwnd(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_vid_dev_hwnd() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_vid_dev_hwnd obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_index.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_index.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_index.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_vid_dev_index {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_vid_dev_index(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_vid_dev_index() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_vid_dev_index obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_dev_info.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_vid_dev_info {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_vid_dev_info(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_vid_dev_info() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_vid_dev_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_stream_rc_config.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_stream_rc_config.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_vid_stream_rc_config.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_vid_stream_rc_config {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_vid_stream_rc_config(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_vid_stream_rc_config() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_vid_stream_rc_config obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_wav_player_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_wav_player_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjmedia_wav_player_info.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjmedia_wav_player_info {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjmedia_wav_player_info(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjmedia_wav_player_info() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjmedia_wav_player_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjrpid_element_type.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjrpid_element_type.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjrpid_element_type.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjrpid_element_type {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjrpid_element_type(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjrpid_element_type() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjrpid_element_type obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_dialog_cap_status.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_dialog_cap_status.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_dialog_cap_status.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_dialog_cap_status {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_dialog_cap_status(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_dialog_cap_status() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_dialog_cap_status obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_endpoint.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_endpoint.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_endpoint.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_endpoint {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_endpoint(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_endpoint() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_endpoint obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_evsub.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_evsub.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_evsub.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_evsub {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_evsub(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_evsub() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_evsub obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_evsub_state.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_evsub_state.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_evsub_state.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_evsub_state {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_evsub_state(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_evsub_state() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_evsub_state obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_hdr.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_hdr.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_hdr.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_hdr {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_hdr(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_hdr() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_hdr obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_host_port.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_host_port.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_host_port.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_host_port {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_host_port(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_host_port() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_host_port obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_media_type.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_media_type.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_media_type.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_media_type {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_media_type(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_media_type() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_media_type obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_method.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_method.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_method.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_method {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_method(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_method() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_method obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_multipart_part.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_multipart_part.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_multipart_part.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_multipart_part {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_multipart_part(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_multipart_part() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_multipart_part obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_pres_status.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_pres_status.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_pres_status.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_pres_status {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_pres_status(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_pres_status() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_pres_status obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_publishc_opt.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_publishc_opt.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_publishc_opt.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_publishc_opt {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_publishc_opt(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_publishc_opt() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_publishc_opt obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_regc_cbparam.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_regc_cbparam.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_regc_cbparam.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_regc_cbparam {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_regc_cbparam(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_regc_cbparam() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_regc_cbparam obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_role_e.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_role_e.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_role_e.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_role_e {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_role_e(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_role_e() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_role_e obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_rx_data.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_rx_data.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_rx_data.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_rx_data {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_rx_data(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_rx_data() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_rx_data obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_status_code.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_status_code.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_status_code.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_status_code {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_status_code(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_status_code() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_status_code obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_tp_state_callback.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_tp_state_callback.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_tp_state_callback.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_tp_state_callback {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_tp_state_callback(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_tp_state_callback() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_tp_state_callback obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_transaction.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_transaction.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_transaction.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_transaction {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_transaction(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_transaction() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_transaction obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_transport.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_transport.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_transport.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_transport {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_transport(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_transport() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_transport obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_tx_data.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_tx_data.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsip_tx_data.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsip_tx_data {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsip_tx_data(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsip_tx_data() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsip_tx_data obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsua_srv_pres.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsua_srv_pres.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_pjsua_srv_pres.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_pjsua_srv_pres {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_pjsua_srv_pres(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_pjsua_srv_pres() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_pjsua_srv_pres obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_unsigned_int.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_unsigned_int.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/SWIGTYPE_p_unsigned_int.java	(working copy)
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class SWIGTYPE_p_unsigned_int {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_unsigned_int(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_unsigned_int() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_unsigned_int obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
Index: CSipSimple/src/org/pjsip/pjsua/zrtp_state_info.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/zrtp_state_info.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/zrtp_state_info.java	(working copy)
@@ -0,0 +1,84 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class zrtp_state_info {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected zrtp_state_info(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(zrtp_state_info obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_zrtp_state_info(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public void setCall_id(int value) {
+    pjsuaJNI.zrtp_state_info_call_id_set(swigCPtr, this, value);
+  }
+
+  public int getCall_id() {
+    return pjsuaJNI.zrtp_state_info_call_id_get(swigCPtr, this);
+  }
+
+  public void setSecure(int value) {
+    pjsuaJNI.zrtp_state_info_secure_set(swigCPtr, this, value);
+  }
+
+  public int getSecure() {
+    return pjsuaJNI.zrtp_state_info_secure_get(swigCPtr, this);
+  }
+
+  public void setSas(pj_str_t value) {
+    pjsuaJNI.zrtp_state_info_sas_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getSas() {
+    long cPtr = pjsuaJNI.zrtp_state_info_sas_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setCipher(pj_str_t value) {
+    pjsuaJNI.zrtp_state_info_cipher_set(swigCPtr, this, pj_str_t.getCPtr(value), value);
+  }
+
+  public pj_str_t getCipher() {
+    long cPtr = pjsuaJNI.zrtp_state_info_cipher_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new pj_str_t(cPtr, false);
+  }
+
+  public void setSas_verified(int value) {
+    pjsuaJNI.zrtp_state_info_sas_verified_set(swigCPtr, this, value);
+  }
+
+  public int getSas_verified() {
+    return pjsuaJNI.zrtp_state_info_sas_verified_get(swigCPtr, this);
+  }
+
+  public zrtp_state_info() {
+    this(pjsuaJNI.new_zrtp_state_info(), true);
+  }
+
+}
Index: CSipSimple/src/org/pjsip/pjsua/ZrtpCallback.java
===================================================================
--- CSipSimple/src/org/pjsip/pjsua/ZrtpCallback.java	(revision 0)
+++ CSipSimple/src/org/pjsip/pjsua/ZrtpCallback.java	(working copy)
@@ -0,0 +1,67 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.11
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package org.pjsip.pjsua;
+
+public class ZrtpCallback {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected ZrtpCallback(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  protected static long getCPtr(ZrtpCallback obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        pjsuaJNI.delete_ZrtpCallback(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  protected void swigDirectorDisconnect() {
+    swigCMemOwn = false;
+    delete();
+  }
+
+  public void swigReleaseOwnership() {
+    swigCMemOwn = false;
+    pjsuaJNI.ZrtpCallback_change_ownership(this, swigCPtr, false);
+  }
+
+  public void swigTakeOwnership() {
+    swigCMemOwn = true;
+    pjsuaJNI.ZrtpCallback_change_ownership(this, swigCPtr, true);
+  }
+
+  public void on_zrtp_show_sas(int call_id, pj_str_t sas, int verified) {
+    if (getClass() == ZrtpCallback.class) pjsuaJNI.ZrtpCallback_on_zrtp_show_sas(swigCPtr, this, call_id, pj_str_t.getCPtr(sas), sas, verified); else pjsuaJNI.ZrtpCallback_on_zrtp_show_sasSwigExplicitZrtpCallback(swigCPtr, this, call_id, pj_str_t.getCPtr(sas), sas, verified);
+  }
+
+  public void on_zrtp_update_transport(int call_id) {
+    if (getClass() == ZrtpCallback.class) pjsuaJNI.ZrtpCallback_on_zrtp_update_transport(swigCPtr, this, call_id); else pjsuaJNI.ZrtpCallback_on_zrtp_update_transportSwigExplicitZrtpCallback(swigCPtr, this, call_id);
+  }
+
+  public ZrtpCallback() {
+    this(pjsuaJNI.new_ZrtpCallback(), true);
+    pjsuaJNI.ZrtpCallback_director_connect(this, swigCPtr, swigCMemOwn, false);
+  }
+
+}
+
Index: CSipSimple/src/ro/callromania/util/Base64.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Base64.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Base64.java	(working copy)
@@ -0,0 +1,570 @@
+// Portions copyright 2002, Google, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ro.callromania.util;
+
+// This code was converted from code at http://iharder.sourceforge.net/base64/
+// Lots of extraneous features were removed.
+/* The original code said:
+ * <p>
+ * I am placing this code in the Public Domain. Do with it as you will.
+ * This software comes with no guarantees or warranties but with
+ * plenty of well-wishing instead!
+ * Please visit
+ * <a href="http://iharder.net/xmlizable">http://iharder.net/xmlizable</a>
+ * periodically to check for updates or to contribute improvements.
+ * </p>
+ *
+ * @author Robert Harder
+ * @author rharder@usa.net
+ * @version 1.3
+ */
+
+/**
+ * Base64 converter class. This code is not a complete MIME encoder;
+ * it simply converts binary data to base64 data and back.
+ *
+ * <p>Note {@link CharBase64} is a GWT-compatible implementation of this
+ * class.
+ */
+public class Base64 {
+    /** Specify encoding (value is {@code true}). */
+    public final static boolean ENCODE = true;
+
+    /** Specify decoding (value is {@code false}). */
+    public final static boolean DECODE = false;
+
+    /** The equals sign (=) as a byte. */
+    private final static byte EQUALS_SIGN = (byte) '=';
+
+    /** The new line character (\n) as a byte. */
+    private final static byte NEW_LINE = (byte) '\n';
+
+    /**
+     * The 64 valid Base64 values.
+     */
+    private final static byte[] ALPHABET =
+        {(byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
+        (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
+        (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
+        (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
+        (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
+        (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
+        (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',
+        (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
+        (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't',
+        (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y',
+        (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
+        (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
+        (byte) '9', (byte) '+', (byte) '/'};
+
+    /**
+     * The 64 valid web safe Base64 values.
+     */
+    private final static byte[] WEBSAFE_ALPHABET =
+        {(byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
+        (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
+        (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
+        (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
+        (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
+        (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
+        (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',
+        (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
+        (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't',
+        (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y',
+        (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
+        (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
+        (byte) '9', (byte) '-', (byte) '_'};
+
+    /**
+     * Translates a Base64 value to either its 6-bit reconstruction value
+     * or a negative number indicating some other meaning.
+     **/
+    private final static byte[] DECODABET = {-9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
+        -5, -5, // Whitespace: Tab and Linefeed
+        -9, -9, // Decimal 11 - 12
+        -5, // Whitespace: Carriage Return
+        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
+        -9, -9, -9, -9, -9, // Decimal 27 - 31
+        -5, // Whitespace: Space
+        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
+        62, // Plus sign at decimal 43
+        -9, -9, -9, // Decimal 44 - 46
+        63, // Slash at decimal 47
+        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
+        -9, -9, -9, // Decimal 58 - 60
+        -1, // Equals sign at decimal 61
+        -9, -9, -9, // Decimal 62 - 64
+        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
+        14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
+        -9, -9, -9, -9, -9, -9, // Decimal 91 - 96
+        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
+        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
+        -9, -9, -9, -9, -9 // Decimal 123 - 127
+        /*  ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
+    };
+
+    /** The web safe decodabet */
+    private final static byte[] WEBSAFE_DECODABET =
+        {-9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
+        -5, -5, // Whitespace: Tab and Linefeed
+        -9, -9, // Decimal 11 - 12
+        -5, // Whitespace: Carriage Return
+        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
+        -9, -9, -9, -9, -9, // Decimal 27 - 31
+        -5, // Whitespace: Space
+        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 44
+        62, // Dash '-' sign at decimal 45
+        -9, -9, // Decimal 46-47
+        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
+        -9, -9, -9, // Decimal 58 - 60
+        -1, // Equals sign at decimal 61
+        -9, -9, -9, // Decimal 62 - 64
+        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
+        14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
+        -9, -9, -9, -9, // Decimal 91-94
+        63, // Underscore '_' at decimal 95
+        -9, // Decimal 96
+        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
+        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
+        -9, -9, -9, -9, -9 // Decimal 123 - 127
+        /*  ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
+        };
+
+    // Indicates white space in encoding
+    private final static byte WHITE_SPACE_ENC = -5;
+    // Indicates equals sign in encoding
+    private final static byte EQUALS_SIGN_ENC = -1;
+
+    /** Defeats instantiation. */
+    private Base64() {
+    }
+
+    /* ********  E N C O D I N G   M E T H O D S  ******** */
+
+    /**
+     * Encodes up to three bytes of the array <var>source</var>
+     * and writes the resulting four Base64 bytes to <var>destination</var>.
+     * The source and destination arrays can be manipulated
+     * anywhere along their length by specifying
+     * <var>srcOffset</var> and <var>destOffset</var>.
+     * This method does not check to make sure your arrays
+     * are large enough to accommodate <var>srcOffset</var> + 3 for
+     * the <var>source</var> array or <var>destOffset</var> + 4 for
+     * the <var>destination</var> array.
+     * The actual number of significant bytes in your array is
+     * given by <var>numSigBytes</var>.
+     *
+     * @param source the array to convert
+     * @param srcOffset the index where conversion begins
+     * @param numSigBytes the number of significant bytes in your array
+     * @param destination the array to hold the conversion
+     * @param destOffset the index where output will be put
+     * @param alphabet is the encoding alphabet
+     * @return the <var>destination</var> array
+     * @since 1.3
+     */
+    private static byte[] encode3to4(byte[] source, int srcOffset,
+            int numSigBytes, byte[] destination, int destOffset, byte[] alphabet) {
+        //           1         2         3
+        // 01234567890123456789012345678901 Bit position
+        // --------000000001111111122222222 Array position from threeBytes
+        // --------|    ||    ||    ||    | Six bit groups to index alphabet
+        //          >>18  >>12  >> 6  >> 0  Right shift necessary
+        //                0x3f  0x3f  0x3f  Additional AND
+
+        // Create buffer with zero-padding if there are only one or two
+        // significant bytes passed in the array.
+        // We have to shift left 24 in order to flush out the 1's that appear
+        // when Java treats a value as negative that is cast from a byte to an int.
+        int inBuff =
+                (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0)
+                | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0)
+                | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);
+
+        switch (numSigBytes) {
+            case 3:
+                destination[destOffset] = alphabet[(inBuff >>> 18)];
+                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
+                destination[destOffset + 2] = alphabet[(inBuff >>> 6) & 0x3f];
+                destination[destOffset + 3] = alphabet[(inBuff) & 0x3f];
+                return destination;
+            case 2:
+                destination[destOffset] = alphabet[(inBuff >>> 18)];
+                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
+                destination[destOffset + 2] = alphabet[(inBuff >>> 6) & 0x3f];
+                destination[destOffset + 3] = EQUALS_SIGN;
+                return destination;
+            case 1:
+                destination[destOffset] = alphabet[(inBuff >>> 18)];
+                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
+                destination[destOffset + 2] = EQUALS_SIGN;
+                destination[destOffset + 3] = EQUALS_SIGN;
+                return destination;
+            default:
+                return destination;
+        } // end switch
+    } // end encode3to4
+
+    /**
+     * Encodes a byte array into Base64 notation.
+     * Equivalent to calling
+     * {@code encodeBytes(source, 0, source.length)}
+     *
+     * @param source The data to convert
+     * @since 1.4
+     */
+    public static String encode(byte[] source) {
+        return encode(source, 0, source.length, ALPHABET, true);
+    }
+
+    /**
+     * Encodes a byte array into web safe Base64 notation.
+     *
+     * @param source The data to convert
+     * @param doPadding is {@code true} to pad result with '=' chars
+     *        if it does not fall on 3 byte boundaries
+     */
+    public static String encodeWebSafe(byte[] source, boolean doPadding) {
+        return encode(source, 0, source.length, WEBSAFE_ALPHABET, doPadding);
+    }
+
+    /**
+     * Encodes a byte array into Base64 notation.
+     *
+     * @param source the data to convert
+     * @param off offset in array where conversion should begin
+     * @param len length of data to convert
+     * @param alphabet the encoding alphabet
+     * @param doPadding is {@code true} to pad result with '=' chars
+     * if it does not fall on 3 byte boundaries
+     * @since 1.4
+     */
+    public static String encode(byte[] source, int off, int len, byte[] alphabet,
+            boolean doPadding) {
+        byte[] outBuff = encode(source, off, len, alphabet, Integer.MAX_VALUE);
+        int outLen = outBuff.length;
+
+        // If doPadding is false, set length to truncate '='
+        // padding characters
+        while (doPadding == false && outLen > 0) {
+            if (outBuff[outLen - 1] != '=') {
+                break;
+            }
+            outLen -= 1;
+        }
+
+        return new String(outBuff, 0, outLen);
+    }
+
+    /**
+     * Encodes a byte array into Base64 notation.
+     *
+     * @param source the data to convert
+     * @param off offset in array where conversion should begin
+     * @param len length of data to convert
+     * @param alphabet is the encoding alphabet
+     * @param maxLineLength maximum length of one line.
+     * @return the BASE64-encoded byte array
+     */
+    public static byte[] encode(byte[] source, int off, int len, byte[] alphabet,
+            int maxLineLength) {
+        int lenDiv3 = (len + 2) / 3; // ceil(len / 3)
+        int len43 = lenDiv3 * 4;
+        byte[] outBuff = new byte[len43 // Main 4:3
+                                  + (len43 / maxLineLength)]; // New lines
+
+        int d = 0;
+        int e = 0;
+        int len2 = len - 2;
+        int lineLength = 0;
+        for (; d < len2; d += 3, e += 4) {
+
+            // The following block of code is the same as
+            // encode3to4( source, d + off, 3, outBuff, e, alphabet );
+            // but inlined for faster encoding (~20% improvement)
+            int inBuff =
+                    ((source[d + off] << 24) >>> 8)
+                    | ((source[d + 1 + off] << 24) >>> 16)
+                    | ((source[d + 2 + off] << 24) >>> 24);
+            outBuff[e] = alphabet[(inBuff >>> 18)];
+            outBuff[e + 1] = alphabet[(inBuff >>> 12) & 0x3f];
+            outBuff[e + 2] = alphabet[(inBuff >>> 6) & 0x3f];
+            outBuff[e + 3] = alphabet[(inBuff) & 0x3f];
+
+            lineLength += 4;
+            if (lineLength == maxLineLength) {
+                outBuff[e + 4] = NEW_LINE;
+                e++;
+                lineLength = 0;
+            } // end if: end of line
+        } // end for: each piece of array
+
+        if (d < len) {
+            encode3to4(source, d + off, len - d, outBuff, e, alphabet);
+
+            lineLength += 4;
+            if (lineLength == maxLineLength) {
+                // Add a last newline
+                outBuff[e + 4] = NEW_LINE;
+                e++;
+            }
+            e += 4;
+        }
+
+        assert (e == outBuff.length);
+        return outBuff;
+    }
+
+
+    /* ********  D E C O D I N G   M E T H O D S  ******** */
+
+
+    /**
+     * Decodes four bytes from array <var>source</var>
+     * and writes the resulting bytes (up to three of them)
+     * to <var>destination</var>.
+     * The source and destination arrays can be manipulated
+     * anywhere along their length by specifying
+     * <var>srcOffset</var> and <var>destOffset</var>.
+     * This method does not check to make sure your arrays
+     * are large enough to accommodate <var>srcOffset</var> + 4 for
+     * the <var>source</var> array or <var>destOffset</var> + 3 for
+     * the <var>destination</var> array.
+     * This method returns the actual number of bytes that
+     * were converted from the Base64 encoding.
+     *
+     *
+     * @param source the array to convert
+     * @param srcOffset the index where conversion begins
+     * @param destination the array to hold the conversion
+     * @param destOffset the index where output will be put
+     * @param decodabet the decodabet for decoding Base64 content
+     * @return the number of decoded bytes converted
+     * @since 1.3
+     */
+    private static int decode4to3(byte[] source, int srcOffset,
+            byte[] destination, int destOffset, byte[] decodabet) {
+        // Example: Dk==
+        if (source[srcOffset + 2] == EQUALS_SIGN) {
+            int outBuff =
+                    ((decodabet[source[srcOffset]] << 24) >>> 6)
+                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12);
+
+            destination[destOffset] = (byte) (outBuff >>> 16);
+            return 1;
+        } else if (source[srcOffset + 3] == EQUALS_SIGN) {
+            // Example: DkL=
+            int outBuff =
+                    ((decodabet[source[srcOffset]] << 24) >>> 6)
+                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)
+                    | ((decodabet[source[srcOffset + 2]] << 24) >>> 18);
+
+            destination[destOffset] = (byte) (outBuff >>> 16);
+            destination[destOffset + 1] = (byte) (outBuff >>> 8);
+            return 2;
+        } else {
+            // Example: DkLE
+            int outBuff =
+                    ((decodabet[source[srcOffset]] << 24) >>> 6)
+                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)
+                    | ((decodabet[source[srcOffset + 2]] << 24) >>> 18)
+                    | ((decodabet[source[srcOffset + 3]] << 24) >>> 24);
+
+            destination[destOffset] = (byte) (outBuff >> 16);
+            destination[destOffset + 1] = (byte) (outBuff >> 8);
+            destination[destOffset + 2] = (byte) (outBuff);
+            return 3;
+        }
+    } // end decodeToBytes
+
+
+    /**
+     * Decodes data from Base64 notation.
+     *
+     * @param s the string to decode (decoded in default encoding)
+     * @return the decoded data
+     * @since 1.4
+     */
+    public static byte[] decode(String s) throws Base64DecoderException {
+        byte[] bytes = s.getBytes();
+        return decode(bytes, 0, bytes.length);
+    }
+
+    /**
+     * Decodes data from web safe Base64 notation.
+     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
+     *
+     * @param s the string to decode (decoded in default encoding)
+     * @return the decoded data
+     */
+    public static byte[] decodeWebSafe(String s) throws Base64DecoderException {
+        byte[] bytes = s.getBytes();
+        return decodeWebSafe(bytes, 0, bytes.length);
+    }
+
+    /**
+     * Decodes Base64 content in byte array format and returns
+     * the decoded byte array.
+     *
+     * @param source The Base64 encoded data
+     * @return decoded data
+     * @since 1.3
+     * @throws Base64DecoderException
+     */
+    public static byte[] decode(byte[] source) throws Base64DecoderException {
+        return decode(source, 0, source.length);
+    }
+
+    /**
+     * Decodes web safe Base64 content in byte array format and returns
+     * the decoded data.
+     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
+     *
+     * @param source the string to decode (decoded in default encoding)
+     * @return the decoded data
+     */
+    public static byte[] decodeWebSafe(byte[] source)
+            throws Base64DecoderException {
+        return decodeWebSafe(source, 0, source.length);
+    }
+
+    /**
+     * Decodes Base64 content in byte array format and returns
+     * the decoded byte array.
+     *
+     * @param source the Base64 encoded data
+     * @param off    the offset of where to begin decoding
+     * @param len    the length of characters to decode
+     * @return decoded data
+     * @since 1.3
+     * @throws Base64DecoderException
+     */
+    public static byte[] decode(byte[] source, int off, int len)
+            throws Base64DecoderException {
+        return decode(source, off, len, DECODABET);
+    }
+
+    /**
+     * Decodes web safe Base64 content in byte array format and returns
+     * the decoded byte array.
+     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
+     *
+     * @param source the Base64 encoded data
+     * @param off    the offset of where to begin decoding
+     * @param len    the length of characters to decode
+     * @return decoded data
+     */
+    public static byte[] decodeWebSafe(byte[] source, int off, int len)
+            throws Base64DecoderException {
+        return decode(source, off, len, WEBSAFE_DECODABET);
+    }
+
+    /**
+     * Decodes Base64 content using the supplied decodabet and returns
+     * the decoded byte array.
+     *
+     * @param source the Base64 encoded data
+     * @param off the offset of where to begin decoding
+     * @param len the length of characters to decode
+     * @param decodabet the decodabet for decoding Base64 content
+     * @return decoded data
+     */
+    public static byte[] decode(byte[] source, int off, int len, byte[] decodabet)
+            throws Base64DecoderException {
+        int len34 = len * 3 / 4;
+        byte[] outBuff = new byte[2 + len34]; // Upper limit on size of output
+        int outBuffPosn = 0;
+
+        byte[] b4 = new byte[4];
+        int b4Posn = 0;
+        int i = 0;
+        byte sbiCrop = 0;
+        byte sbiDecode = 0;
+        for (i = 0; i < len; i++) {
+            sbiCrop = (byte) (source[i + off] & 0x7f); // Only the low seven bits
+            sbiDecode = decodabet[sbiCrop];
+
+            if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better
+                if (sbiDecode >= EQUALS_SIGN_ENC) {
+                    // An equals sign (for padding) must not occur at position 0 or 1
+                    // and must be the last byte[s] in the encoded value
+                    if (sbiCrop == EQUALS_SIGN) {
+                        int bytesLeft = len - i;
+                        byte lastByte = (byte) (source[len - 1 + off] & 0x7f);
+                        if (b4Posn == 0 || b4Posn == 1) {
+                            throw new Base64DecoderException(
+                                    "invalid padding byte '=' at byte offset " + i);
+                        } else if ((b4Posn == 3 && bytesLeft > 2)
+                                || (b4Posn == 4 && bytesLeft > 1)) {
+                            throw new Base64DecoderException(
+                                    "padding byte '=' falsely signals end of encoded value "
+                                            + "at offset " + i);
+                        } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {
+                            throw new Base64DecoderException(
+                                    "encoded value has invalid trailing byte");
+                        }
+                        break;
+                    }
+
+                    b4[b4Posn++] = sbiCrop;
+                    if (b4Posn == 4) {
+                        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);
+                        b4Posn = 0;
+                    }
+                }
+            } else {
+                throw new Base64DecoderException("Bad Base64 input character at " + i
+                        + ": " + source[i + off] + "(decimal)");
+            }
+        }
+
+        // Because web safe encoding allows non padding base64 encodes, we
+        // need to pad the rest of the b4 buffer with equal signs when
+        // b4Posn != 0.  There can be at most 2 equal signs at the end of
+        // four characters, so the b4 buffer must have two or three
+        // characters.  This also catches the case where the input is
+        // padded with EQUALS_SIGN
+        if (b4Posn != 0) {
+            if (b4Posn == 1) {
+                throw new Base64DecoderException("single trailing character at offset "
+                        + (len - 1));
+            }
+            b4[b4Posn++] = EQUALS_SIGN;
+            outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);
+        }
+
+        byte[] out = new byte[outBuffPosn];
+        System.arraycopy(outBuff, 0, out, 0, outBuffPosn);
+        return out;
+    }
+}
Index: CSipSimple/src/ro/callromania/util/Base64DecoderException.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Base64DecoderException.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Base64DecoderException.java	(working copy)
@@ -0,0 +1,32 @@
+// Copyright 2002, Google, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ro.callromania.util;
+
+/**
+ * Exception thrown when encountering an invalid Base64 input character.
+ *
+ * @author nelson
+ */
+public class Base64DecoderException extends Exception {
+    public Base64DecoderException() {
+        super();
+    }
+
+    public Base64DecoderException(String s) {
+        super(s);
+    }
+
+    private static final long serialVersionUID = 1L;
+}
Index: CSipSimple/src/ro/callromania/util/GcmBroadcastReceiver.java
===================================================================
--- CSipSimple/src/ro/callromania/util/GcmBroadcastReceiver.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/GcmBroadcastReceiver.java	(working copy)
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2013 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ro.callromania.util;
+
+import android.app.Activity;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.support.v4.content.WakefulBroadcastReceiver;
+
+
+/**
+ * This {@code WakefulBroadcastReceiver} takes care of creating and managing a
+ * partial wake lock for your app. It passes off the work of processing the GCM
+ * message to an {@code IntentService}, while ensuring that the device does not
+ * go back to sleep in the transition. The {@code IntentService} calls
+ * {@code GcmBroadcastReceiver.completeWakefulIntent()} when it is ready to
+ * release the wake lock.
+ */
+
+public class GcmBroadcastReceiver extends WakefulBroadcastReceiver 
+{
+
+    @Override
+    public void onReceive(Context context, Intent intent) 
+    {
+        // Explicitly specify that GcmIntentService will handle the intent.
+        ComponentName comp = new ComponentName(context.getPackageName(), GcmIntentService.class.getName());
+        // Start the service, keeping the device awake while it is launching.
+        startWakefulService(context, (intent.setComponent(comp)));
+        setResultCode(Activity.RESULT_OK);
+    }
+}
Index: CSipSimple/src/ro/callromania/util/GcmIntentService.java
===================================================================
--- CSipSimple/src/ro/callromania/util/GcmIntentService.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/GcmIntentService.java	(working copy)
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import ro.callromania.R;
+import android.app.IntentService;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.media.RingtoneManager;
+import android.os.Bundle;
+import android.support.v4.app.NotificationCompat;
+
+import com.csipsimple.ui.SipHome;
+import com.google.android.gms.gcm.GoogleCloudMessaging;
+
+/**
+ * This {@code IntentService} does the actual handling of the GCM message.
+ * {@code GcmBroadcastReceiver} (a {@code WakefulBroadcastReceiver}) holds a
+ * partial wake lock for this service while the service does its work. When the
+ * service is finished, it calls {@code completeWakefulIntent()} to release the
+ * wake lock.
+ */
+public class GcmIntentService extends IntentService 
+{
+    public static int NOTIFICATION_ID = 1;
+    private NotificationManager mNotificationManager;
+    NotificationCompat.Builder builder;
+
+    public GcmIntentService() 
+    {
+        super("GcmIntentService");
+    }
+    public static final String TAG = "GCM Demo";
+
+    @Override
+    protected void onHandleIntent(Intent intent) 
+    {
+        Bundle extras = intent.getExtras();
+        GoogleCloudMessaging gcm = GoogleCloudMessaging.getInstance(this);
+        // The getMessageType() intent parameter must be the intent you received
+        // in your BroadcastReceiver.
+        String messageType = gcm.getMessageType(intent);
+
+        if (!extras.isEmpty()) {  // has effect of unparcelling Bundle
+            /*
+             * Filter messages based on message type. Since it is likely that GCM will be
+             * extended in the future with new message types, just ignore any message types you're
+             * not interested in, or that you don't recognize.
+             */
+            if (GoogleCloudMessaging.MESSAGE_TYPE_SEND_ERROR.equals(messageType)) 
+            {
+            	//TODO: really ceck this out
+//                sendNotification("Send error: " + extras.toString());
+            }
+            else if (GoogleCloudMessaging.MESSAGE_TYPE_DELETED.equals(messageType)) 
+            {
+            	//TODO: really ceck this out
+//                sendNotification("Deleted messages on server: " + extras.toString());
+            // If it's a regular GCM message, do some work.
+            } 
+            else if (GoogleCloudMessaging.MESSAGE_TYPE_MESSAGE.equals(messageType)) 
+            {
+                // This loop represents the service doing some work.
+//                for (int i = 0; i < 5; i++) 
+//                {
+//                    Log.i(TAG, "Working... " + (i + 1)
+//                            + "/5 @ " + SystemClock.elapsedRealtime());
+//                    try {
+//                        Thread.sleep(5000);
+//                    } catch (InterruptedException e) {
+//                    }
+//                }
+//                Log.i(TAG, "Completed work @ " + SystemClock.elapsedRealtime());
+            	
+                // Post notification of received message.
+                sendNotification(extras);
+//                Log.i(TAG, "Received: " + extras.toString());
+            }
+        }
+        // Release the wake lock provided by the WakefulBroadcastReceiver.
+        GcmBroadcastReceiver.completeWakefulIntent(intent);
+    }
+
+    // Put the message into a notification and post it.
+    // This is just one simple example of what you might choose to do with
+    // a GCM message.
+    private void sendNotification(Bundle msg) 
+    {    	
+        mNotificationManager = (NotificationManager) this.getSystemService(Context.NOTIFICATION_SERVICE);
+
+        PendingIntent contentIntent = PendingIntent.getActivity(this, 0, new Intent(this, SipHome.class), PendingIntent.FLAG_UPDATE_CURRENT);
+        
+        String title = msg.getString("title");
+        if (title == null) title = "CallRomania";
+        
+        String subtitle = msg.getString("subtitle");
+        if (subtitle == null) subtitle = "";
+
+        String message = msg.getString("message");
+        if (message == null) message = "";
+        
+        String tickerText = msg.getString("tickerText");
+        if (tickerText == null) tickerText = title;
+
+        NotificationCompat.Builder mBuilder = 
+        		new NotificationCompat.Builder(this)
+			        .setSmallIcon(R.drawable.ic_wizard_callromania)
+			        .setContentTitle(title)
+//			        .setStyle(new NotificationCompat.BigTextStyle()
+//			        .bigText(message))
+//			        .setContentText(subtitle)
+			        .setContentText(message)
+			        .setAutoCancel(true)
+			        .setSound(RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION))
+			        .setTicker(tickerText);
+
+        mBuilder.setContentIntent(contentIntent);
+        mNotificationManager.notify(NOTIFICATION_ID++, mBuilder.build());
+    }
+}
Index: CSipSimple/src/ro/callromania/util/IabException.java
===================================================================
--- CSipSimple/src/ro/callromania/util/IabException.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/IabException.java	(working copy)
@@ -0,0 +1,43 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+/**
+ * Exception thrown when something went wrong with in-app billing.
+ * An IabException has an associated IabResult (an error).
+ * To get the IAB result that caused this exception to be thrown,
+ * call {@link #getResult()}.
+ */
+public class IabException extends Exception {
+    IabResult mResult;
+
+    public IabException(IabResult r) {
+        this(r, null);
+    }
+    public IabException(int response, String message) {
+        this(new IabResult(response, message));
+    }
+    public IabException(IabResult r, Exception cause) {
+        super(r.getMessage(), cause);
+        mResult = r;
+    }
+    public IabException(int response, String message, Exception cause) {
+        this(new IabResult(response, message), cause);
+    }
+
+    /** Returns the IAB result (error) that this exception signals. */
+    public IabResult getResult() { return mResult; }
+}
\ No newline at end of file
Index: CSipSimple/src/ro/callromania/util/IabHelper.java
===================================================================
--- CSipSimple/src/ro/callromania/util/IabHelper.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/IabHelper.java	(working copy)
@@ -0,0 +1,991 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import android.app.Activity;
+import android.app.PendingIntent;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentSender.SendIntentException;
+import android.content.ServiceConnection;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.android.vending.billing.IInAppBillingService;
+
+import org.json.JSONException;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * Provides convenience methods for in-app billing. You can create one instance of this
+ * class for your application and use it to process in-app billing operations.
+ * It provides synchronous (blocking) and asynchronous (non-blocking) methods for
+ * many common in-app billing operations, as well as automatic signature
+ * verification.
+ *
+ * After instantiating, you must perform setup in order to start using the object.
+ * To perform setup, call the {@link #startSetup} method and provide a listener;
+ * that listener will be notified when setup is complete, after which (and not before)
+ * you may call other methods.
+ *
+ * After setup is complete, you will typically want to request an inventory of owned
+ * items and subscriptions. See {@link #queryInventory}, {@link #queryInventoryAsync}
+ * and related methods.
+ *
+ * When you are done with this object, don't forget to call {@link #dispose}
+ * to ensure proper cleanup. This object holds a binding to the in-app billing
+ * service, which will leak unless you dispose of it correctly. If you created
+ * the object on an Activity's onCreate method, then the recommended
+ * place to dispose of it is the Activity's onDestroy method.
+ *
+ * A note about threading: When using this object from a background thread, you may
+ * call the blocking versions of methods; when using from a UI thread, call
+ * only the asynchronous versions and handle the results via callbacks.
+ * Also, notice that you can only call one asynchronous operation at a time;
+ * attempting to start a second asynchronous operation while the first one
+ * has not yet completed will result in an exception being thrown.
+ *
+ * @author Bruno Oliveira (Google)
+ *
+ */
+public class IabHelper {
+    // Is debug logging enabled?
+    boolean mDebugLog = false;
+    String mDebugTag = "IabHelper";
+
+    // Is setup done?
+    boolean mSetupDone = false;
+
+    // Has this object been disposed of? (If so, we should ignore callbacks, etc)
+    boolean mDisposed = false;
+
+    // Are subscriptions supported?
+    boolean mSubscriptionsSupported = false;
+
+    // Is an asynchronous operation in progress?
+    // (only one at a time can be in progress)
+    boolean mAsyncInProgress = false;
+
+    // (for logging/debugging)
+    // if mAsyncInProgress == true, what asynchronous operation is in progress?
+    String mAsyncOperation = "";
+
+    // Context we were passed during initialization
+    Context mContext;
+
+    // Connection to the service
+    IInAppBillingService mService;
+    ServiceConnection mServiceConn;
+
+    // The request code used to launch purchase flow
+    int mRequestCode;
+
+    // The item type of the current purchase flow
+    String mPurchasingItemType;
+
+    // Public key for verifying signature, in base64 encoding
+    String mSignatureBase64 = null;
+
+    // Billing response codes
+    public static final int BILLING_RESPONSE_RESULT_OK = 0;
+    public static final int BILLING_RESPONSE_RESULT_USER_CANCELED = 1;
+    public static final int BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE = 3;
+    public static final int BILLING_RESPONSE_RESULT_ITEM_UNAVAILABLE = 4;
+    public static final int BILLING_RESPONSE_RESULT_DEVELOPER_ERROR = 5;
+    public static final int BILLING_RESPONSE_RESULT_ERROR = 6;
+    public static final int BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED = 7;
+    public static final int BILLING_RESPONSE_RESULT_ITEM_NOT_OWNED = 8;
+
+    // IAB Helper error codes
+    public static final int IABHELPER_ERROR_BASE = -1000;
+    public static final int IABHELPER_REMOTE_EXCEPTION = -1001;
+    public static final int IABHELPER_BAD_RESPONSE = -1002;
+    public static final int IABHELPER_VERIFICATION_FAILED = -1003;
+    public static final int IABHELPER_SEND_INTENT_FAILED = -1004;
+    public static final int IABHELPER_USER_CANCELLED = -1005;
+    public static final int IABHELPER_UNKNOWN_PURCHASE_RESPONSE = -1006;
+    public static final int IABHELPER_MISSING_TOKEN = -1007;
+    public static final int IABHELPER_UNKNOWN_ERROR = -1008;
+    public static final int IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE = -1009;
+    public static final int IABHELPER_INVALID_CONSUMPTION = -1010;
+
+    // Keys for the responses from InAppBillingService
+    public static final String RESPONSE_CODE = "RESPONSE_CODE";
+    public static final String RESPONSE_GET_SKU_DETAILS_LIST = "DETAILS_LIST";
+    public static final String RESPONSE_BUY_INTENT = "BUY_INTENT";
+    public static final String RESPONSE_INAPP_PURCHASE_DATA = "INAPP_PURCHASE_DATA";
+    public static final String RESPONSE_INAPP_SIGNATURE = "INAPP_DATA_SIGNATURE";
+    public static final String RESPONSE_INAPP_ITEM_LIST = "INAPP_PURCHASE_ITEM_LIST";
+    public static final String RESPONSE_INAPP_PURCHASE_DATA_LIST = "INAPP_PURCHASE_DATA_LIST";
+    public static final String RESPONSE_INAPP_SIGNATURE_LIST = "INAPP_DATA_SIGNATURE_LIST";
+    public static final String INAPP_CONTINUATION_TOKEN = "INAPP_CONTINUATION_TOKEN";
+
+    // Item types
+    public static final String ITEM_TYPE_INAPP = "inapp";
+    public static final String ITEM_TYPE_SUBS = "subs";
+
+    // some fields on the getSkuDetails response bundle
+    public static final String GET_SKU_DETAILS_ITEM_LIST = "ITEM_ID_LIST";
+    public static final String GET_SKU_DETAILS_ITEM_TYPE_LIST = "ITEM_TYPE_LIST";
+
+    /**
+     * Creates an instance. After creation, it will not yet be ready to use. You must perform
+     * setup by calling {@link #startSetup} and wait for setup to complete. This constructor does not
+     * block and is safe to call from a UI thread.
+     *
+     * @param ctx Your application or Activity context. Needed to bind to the in-app billing service.
+     * @param base64PublicKey Your application's public key, encoded in base64.
+     *     This is used for verification of purchase signatures. You can find your app's base64-encoded
+     *     public key in your application's page on Google Play Developer Console. Note that this
+     *     is NOT your "developer public key".
+     */
+    public IabHelper(Context ctx, String base64PublicKey) {
+        mContext = ctx.getApplicationContext();
+        mSignatureBase64 = base64PublicKey;
+        logDebug("IAB helper created.");
+    }
+
+    /**
+     * Enables or disable debug logging through LogCat.
+     */
+    public void enableDebugLogging(boolean enable, String tag) {
+        checkNotDisposed();
+        mDebugLog = enable;
+        mDebugTag = tag;
+    }
+
+    public void enableDebugLogging(boolean enable) {
+        checkNotDisposed();
+        mDebugLog = enable;
+    }
+
+    /**
+     * Callback for setup process. This listener's {@link #onIabSetupFinished} method is called
+     * when the setup process is complete.
+     */
+    public interface OnIabSetupFinishedListener {
+        /**
+         * Called to notify that setup is complete.
+         *
+         * @param result The result of the setup process.
+         */
+        public void onIabSetupFinished(IabResult result);
+    }
+
+    /**
+     * Starts the setup process. This will start up the setup process asynchronously.
+     * You will be notified through the listener when the setup process is complete.
+     * This method is safe to call from a UI thread.
+     *
+     * @param listener The listener to notify when the setup process is complete.
+     */
+    public void startSetup(final OnIabSetupFinishedListener listener) {
+        // If already set up, can't do it again.
+        checkNotDisposed();
+        if (mSetupDone) throw new IllegalStateException("IAB helper is already set up.");
+
+        // Connection to IAB service
+        logDebug("Starting in-app billing setup.");
+        mServiceConn = new ServiceConnection() {
+            @Override
+            public void onServiceDisconnected(ComponentName name) {
+                logDebug("Billing service disconnected.");
+                mService = null;
+            }
+
+            @Override
+            public void onServiceConnected(ComponentName name, IBinder service) {
+                if (mDisposed) return;
+                logDebug("Billing service connected.");
+                mService = IInAppBillingService.Stub.asInterface(service);
+                String packageName = mContext.getPackageName();
+                try {
+                    logDebug("Checking for in-app billing 3 support.");
+
+                    // check for in-app billing v3 support
+                    int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);
+                    if (response != BILLING_RESPONSE_RESULT_OK) {
+                        if (listener != null) listener.onIabSetupFinished(new IabResult(response,
+                                "Error checking for billing v3 support."));
+
+                        // if in-app purchases aren't supported, neither are subscriptions.
+                        mSubscriptionsSupported = false;
+                        return;
+                    }
+                    logDebug("In-app billing version 3 supported for " + packageName);
+
+                    // check for v3 subscriptions support
+                    response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);
+                    if (response == BILLING_RESPONSE_RESULT_OK) {
+                        logDebug("Subscriptions AVAILABLE.");
+                        mSubscriptionsSupported = true;
+                    }
+                    else {
+                        logDebug("Subscriptions NOT AVAILABLE. Response: " + response);
+                    }
+
+                    mSetupDone = true;
+                }
+                catch (RemoteException e) {
+                    if (listener != null) {
+                        listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION,
+                                                    "RemoteException while setting up in-app billing."));
+                    }
+                    e.printStackTrace();
+                    return;
+                }
+
+                if (listener != null) {
+                    listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Setup successful."));
+                }
+            }
+        };
+
+        Intent serviceIntent = new Intent("com.android.vending.billing.InAppBillingService.BIND");
+        serviceIntent.setPackage("com.android.vending");
+        if (!mContext.getPackageManager().queryIntentServices(serviceIntent, 0).isEmpty()) {
+            // service available to handle that Intent
+            mContext.bindService(serviceIntent, mServiceConn, Context.BIND_AUTO_CREATE);
+        }
+        else {
+            // no service available to handle that Intent
+            if (listener != null) {
+                listener.onIabSetupFinished(
+                        new IabResult(BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE,
+                        "Billing service unavailable on device."));
+            }
+        }
+    }
+
+    /**
+     * Dispose of object, releasing resources. It's very important to call this
+     * method when you are done with this object. It will release any resources
+     * used by it such as service connections. Naturally, once the object is
+     * disposed of, it can't be used again.
+     */
+    public void dispose() {
+        logDebug("Disposing.");
+        mSetupDone = false;
+        if (mServiceConn != null) {
+            logDebug("Unbinding from service.");
+            if (mContext != null) mContext.unbindService(mServiceConn);
+        }
+        mDisposed = true;
+        mContext = null;
+        mServiceConn = null;
+        mService = null;
+        mPurchaseListener = null;
+    }
+
+    private void checkNotDisposed() {
+        if (mDisposed) throw new IllegalStateException("IabHelper was disposed of, so it cannot be used.");
+    }
+
+    /** Returns whether subscriptions are supported. */
+    public boolean subscriptionsSupported() {
+        checkNotDisposed();
+        return mSubscriptionsSupported;
+    }
+
+
+    /**
+     * Callback that notifies when a purchase is finished.
+     */
+    public interface OnIabPurchaseFinishedListener {
+        /**
+         * Called to notify that an in-app purchase finished. If the purchase was successful,
+         * then the sku parameter specifies which item was purchased. If the purchase failed,
+         * the sku and extraData parameters may or may not be null, depending on how far the purchase
+         * process went.
+         *
+         * @param result The result of the purchase.
+         * @param info The purchase information (null if purchase failed)
+         */
+        public void onIabPurchaseFinished(IabResult result, Purchase info);
+    }
+
+    // The listener registered on launchPurchaseFlow, which we have to call back when
+    // the purchase finishes
+    OnIabPurchaseFinishedListener mPurchaseListener;
+
+    public void launchPurchaseFlow(Activity act, String sku, int requestCode, OnIabPurchaseFinishedListener listener) {
+        launchPurchaseFlow(act, sku, requestCode, listener, "");
+    }
+
+    public void launchPurchaseFlow(Activity act, String sku, int requestCode,
+            OnIabPurchaseFinishedListener listener, String extraData) {
+        launchPurchaseFlow(act, sku, ITEM_TYPE_INAPP, requestCode, listener, extraData);
+    }
+
+    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
+            OnIabPurchaseFinishedListener listener) {
+        launchSubscriptionPurchaseFlow(act, sku, requestCode, listener, "");
+    }
+
+    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
+            OnIabPurchaseFinishedListener listener, String extraData) {
+        launchPurchaseFlow(act, sku, ITEM_TYPE_SUBS, requestCode, listener, extraData);
+    }
+
+    /**
+     * Initiate the UI flow for an in-app purchase. Call this method to initiate an in-app purchase,
+     * which will involve bringing up the Google Play screen. The calling activity will be paused while
+     * the user interacts with Google Play, and the result will be delivered via the activity's
+     * {@link android.app.Activity#onActivityResult} method, at which point you must call
+     * this object's {@link #handleActivityResult} method to continue the purchase flow. This method
+     * MUST be called from the UI thread of the Activity.
+     *
+     * @param act The calling activity.
+     * @param sku The sku of the item to purchase.
+     * @param itemType indicates if it's a product or a subscription (ITEM_TYPE_INAPP or ITEM_TYPE_SUBS)
+     * @param requestCode A request code (to differentiate from other responses --
+     *     as in {@link android.app.Activity#startActivityForResult}).
+     * @param listener The listener to notify when the purchase process finishes
+     * @param extraData Extra data (developer payload), which will be returned with the purchase data
+     *     when the purchase completes. This extra data will be permanently bound to that purchase
+     *     and will always be returned when the purchase is queried.
+     */
+    public void launchPurchaseFlow(Activity act, String sku, String itemType, int requestCode,
+                        OnIabPurchaseFinishedListener listener, String extraData) {
+        checkNotDisposed();
+        checkSetupDone("launchPurchaseFlow");
+        flagStartAsync("launchPurchaseFlow");
+        IabResult result;
+
+        if (itemType.equals(ITEM_TYPE_SUBS) && !mSubscriptionsSupported) {
+            IabResult r = new IabResult(IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE,
+                    "Subscriptions are not available.");
+            flagEndAsync();
+            if (listener != null) listener.onIabPurchaseFinished(r, null);
+            return;
+        }
+
+        try {
+            logDebug("Constructing buy intent for " + sku + ", item type: " + itemType);
+            Bundle buyIntentBundle = mService.getBuyIntent(3, mContext.getPackageName(), sku, itemType, extraData);
+            int response = getResponseCodeFromBundle(buyIntentBundle);
+            if (response != BILLING_RESPONSE_RESULT_OK) {
+                logError("Unable to buy item, Error response: " + getResponseDesc(response));
+                flagEndAsync();
+                result = new IabResult(response, "Unable to buy item");
+                if (listener != null) listener.onIabPurchaseFinished(result, null);
+                return;
+            }
+
+            PendingIntent pendingIntent = buyIntentBundle.getParcelable(RESPONSE_BUY_INTENT);
+            logDebug("Launching buy intent for " + sku + ". Request code: " + requestCode);
+            mRequestCode = requestCode;
+            mPurchaseListener = listener;
+            mPurchasingItemType = itemType;
+            act.startIntentSenderForResult(pendingIntent.getIntentSender(),
+                                           requestCode, new Intent(),
+                                           Integer.valueOf(0), Integer.valueOf(0),
+                                           Integer.valueOf(0));
+        }
+        catch (SendIntentException e) {
+            logError("SendIntentException while launching purchase flow for sku " + sku);
+            e.printStackTrace();
+            flagEndAsync();
+
+            result = new IabResult(IABHELPER_SEND_INTENT_FAILED, "Failed to send intent.");
+            if (listener != null) listener.onIabPurchaseFinished(result, null);
+        }
+        catch (RemoteException e) {
+            logError("RemoteException while launching purchase flow for sku " + sku);
+            e.printStackTrace();
+            flagEndAsync();
+
+            result = new IabResult(IABHELPER_REMOTE_EXCEPTION, "Remote exception while starting purchase flow");
+            if (listener != null) listener.onIabPurchaseFinished(result, null);
+        }
+    }
+
+    /**
+     * Handles an activity result that's part of the purchase flow in in-app billing. If you
+     * are calling {@link #launchPurchaseFlow}, then you must call this method from your
+     * Activity's {@link android.app.Activity@onActivityResult} method. This method
+     * MUST be called from the UI thread of the Activity.
+     *
+     * @param requestCode The requestCode as you received it.
+     * @param resultCode The resultCode as you received it.
+     * @param data The data (Intent) as you received it.
+     * @return Returns true if the result was related to a purchase flow and was handled;
+     *     false if the result was not related to a purchase, in which case you should
+     *     handle it normally.
+     */
+    public boolean handleActivityResult(int requestCode, int resultCode, Intent data) {
+        IabResult result;
+        if (requestCode != mRequestCode) return false;
+
+        checkNotDisposed();
+        checkSetupDone("handleActivityResult");
+
+        // end of async purchase operation that started on launchPurchaseFlow
+        flagEndAsync();
+
+        if (data == null) {
+            logError("Null data in IAB activity result.");
+            result = new IabResult(IABHELPER_BAD_RESPONSE, "Null data in IAB result");
+            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+            return true;
+        }
+
+        int responseCode = getResponseCodeFromIntent(data);
+        String purchaseData = data.getStringExtra(RESPONSE_INAPP_PURCHASE_DATA);
+        String dataSignature = data.getStringExtra(RESPONSE_INAPP_SIGNATURE);
+
+        if (resultCode == Activity.RESULT_OK && responseCode == BILLING_RESPONSE_RESULT_OK) {
+            logDebug("Successful resultcode from purchase activity.");
+            logDebug("Purchase data: " + purchaseData);
+            logDebug("Data signature: " + dataSignature);
+            logDebug("Extras: " + data.getExtras());
+            logDebug("Expected item type: " + mPurchasingItemType);
+
+            if (purchaseData == null || dataSignature == null) {
+                logError("BUG: either purchaseData or dataSignature is null.");
+                logDebug("Extras: " + data.getExtras().toString());
+                result = new IabResult(IABHELPER_UNKNOWN_ERROR, "IAB returned null purchaseData or dataSignature");
+                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+                return true;
+            }
+
+            Purchase purchase = null;
+            try {
+                purchase = new Purchase(mPurchasingItemType, purchaseData, dataSignature);
+                String sku = purchase.getSku();
+
+                // Verify signature
+                if (!Security.verifyPurchase(mSignatureBase64, purchaseData, dataSignature)) {
+                    logError("Purchase signature verification FAILED for sku " + sku);
+                    result = new IabResult(IABHELPER_VERIFICATION_FAILED, "Signature verification failed for sku " + sku);
+                    if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, purchase);
+                    return true;
+                }
+                logDebug("Purchase signature successfully verified.");
+            }
+            catch (JSONException e) {
+                logError("Failed to parse purchase data.");
+                e.printStackTrace();
+                result = new IabResult(IABHELPER_BAD_RESPONSE, "Failed to parse purchase data.");
+                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+                return true;
+            }
+
+            if (mPurchaseListener != null) {
+                mPurchaseListener.onIabPurchaseFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Success"), purchase);
+            }
+        }
+        else if (resultCode == Activity.RESULT_OK) {
+            // result code was OK, but in-app billing response was not OK.
+            logDebug("Result code was OK but in-app billing response was not OK: " + getResponseDesc(responseCode));
+            if (mPurchaseListener != null) {
+                result = new IabResult(responseCode, "Problem purchashing item.");
+                mPurchaseListener.onIabPurchaseFinished(result, null);
+            }
+        }
+        else if (resultCode == Activity.RESULT_CANCELED) {
+            logDebug("Purchase canceled - Response: " + getResponseDesc(responseCode));
+            result = new IabResult(IABHELPER_USER_CANCELLED, "User canceled.");
+            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+        }
+        else {
+            logError("Purchase failed. Result code: " + Integer.toString(resultCode)
+                    + ". Response: " + getResponseDesc(responseCode));
+            result = new IabResult(IABHELPER_UNKNOWN_PURCHASE_RESPONSE, "Unknown purchase response.");
+            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+        }
+        return true;
+    }
+
+    public Inventory queryInventory(boolean querySkuDetails, List<String> moreSkus) throws IabException {
+        return queryInventory(querySkuDetails, moreSkus, null);
+    }
+
+    /**
+     * Queries the inventory. This will query all owned items from the server, as well as
+     * information on additional skus, if specified. This method may block or take long to execute.
+     * Do not call from a UI thread. For that, use the non-blocking version {@link #refreshInventoryAsync}.
+     *
+     * @param querySkuDetails if true, SKU details (price, description, etc) will be queried as well
+     *     as purchase information.
+     * @param moreItemSkus additional PRODUCT skus to query information on, regardless of ownership.
+     *     Ignored if null or if querySkuDetails is false.
+     * @param moreSubsSkus additional SUBSCRIPTIONS skus to query information on, regardless of ownership.
+     *     Ignored if null or if querySkuDetails is false.
+     * @throws IabException if a problem occurs while refreshing the inventory.
+     */
+    public Inventory queryInventory(boolean querySkuDetails, List<String> moreItemSkus,
+                                        List<String> moreSubsSkus) throws IabException {
+        checkNotDisposed();
+        checkSetupDone("queryInventory");
+        try {
+            Inventory inv = new Inventory();
+            int r = queryPurchases(inv, ITEM_TYPE_INAPP);
+            if (r != BILLING_RESPONSE_RESULT_OK) {
+                throw new IabException(r, "Error refreshing inventory (querying owned items).");
+            }
+
+            if (querySkuDetails) {
+                r = querySkuDetails(ITEM_TYPE_INAPP, inv, moreItemSkus);
+                if (r != BILLING_RESPONSE_RESULT_OK) {
+                    throw new IabException(r, "Error refreshing inventory (querying prices of items).");
+                }
+            }
+
+            // if subscriptions are supported, then also query for subscriptions
+            if (mSubscriptionsSupported) {
+                r = queryPurchases(inv, ITEM_TYPE_SUBS);
+                if (r != BILLING_RESPONSE_RESULT_OK) {
+                    throw new IabException(r, "Error refreshing inventory (querying owned subscriptions).");
+                }
+
+                if (querySkuDetails) {
+                    r = querySkuDetails(ITEM_TYPE_SUBS, inv, moreItemSkus);
+                    if (r != BILLING_RESPONSE_RESULT_OK) {
+                        throw new IabException(r, "Error refreshing inventory (querying prices of subscriptions).");
+                    }
+                }
+            }
+
+            return inv;
+        }
+        catch (RemoteException e) {
+            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while refreshing inventory.", e);
+        }
+        catch (JSONException e) {
+            throw new IabException(IABHELPER_BAD_RESPONSE, "Error parsing JSON response while refreshing inventory.", e);
+        }
+    }
+
+    /**
+     * Listener that notifies when an inventory query operation completes.
+     */
+    public interface QueryInventoryFinishedListener {
+        /**
+         * Called to notify that an inventory query operation completed.
+         *
+         * @param result The result of the operation.
+         * @param inv The inventory.
+         */
+        public void onQueryInventoryFinished(IabResult result, Inventory inv);
+    }
+
+
+    /**
+     * Asynchronous wrapper for inventory query. This will perform an inventory
+     * query as described in {@link #queryInventory}, but will do so asynchronously
+     * and call back the specified listener upon completion. This method is safe to
+     * call from a UI thread.
+     *
+     * @param querySkuDetails as in {@link #queryInventory}
+     * @param moreSkus as in {@link #queryInventory}
+     * @param listener The listener to notify when the refresh operation completes.
+     */
+    public void queryInventoryAsync(final boolean querySkuDetails,
+                               final List<String> moreSkus,
+                               final QueryInventoryFinishedListener listener) {
+        final Handler handler = new Handler();
+        checkNotDisposed();
+        checkSetupDone("queryInventory");
+        flagStartAsync("refresh inventory");
+        (new Thread(new Runnable() {
+            public void run() {
+                IabResult result = new IabResult(BILLING_RESPONSE_RESULT_OK, "Inventory refresh successful.");
+                Inventory inv = null;
+                try {
+                    inv = queryInventory(querySkuDetails, moreSkus);
+                }
+                catch (IabException ex) {
+                    result = ex.getResult();
+                }
+
+                flagEndAsync();
+
+                final IabResult result_f = result;
+                final Inventory inv_f = inv;
+                if (!mDisposed && listener != null) {
+                    handler.post(new Runnable() {
+                        public void run() {
+                            listener.onQueryInventoryFinished(result_f, inv_f);
+                        }
+                    });
+                }
+            }
+        })).start();
+    }
+
+    public void queryInventoryAsync(QueryInventoryFinishedListener listener) {
+        queryInventoryAsync(true, null, listener);
+    }
+
+    public void queryInventoryAsync(boolean querySkuDetails, QueryInventoryFinishedListener listener) {
+        queryInventoryAsync(querySkuDetails, null, listener);
+    }
+
+
+    /**
+     * Consumes a given in-app product. Consuming can only be done on an item
+     * that's owned, and as a result of consumption, the user will no longer own it.
+     * This method may block or take long to return. Do not call from the UI thread.
+     * For that, see {@link #consumeAsync}.
+     *
+     * @param itemInfo The PurchaseInfo that represents the item to consume.
+     * @throws IabException if there is a problem during consumption.
+     */
+    void consume(Purchase itemInfo) throws IabException {
+        checkNotDisposed();
+        checkSetupDone("consume");
+
+        if (!itemInfo.mItemType.equals(ITEM_TYPE_INAPP)) {
+            throw new IabException(IABHELPER_INVALID_CONSUMPTION,
+                    "Items of type '" + itemInfo.mItemType + "' can't be consumed.");
+        }
+
+        try {
+            String token = itemInfo.getToken();
+            String sku = itemInfo.getSku();
+            if (token == null || token.equals("")) {
+               logError("Can't consume "+ sku + ". No token.");
+               throw new IabException(IABHELPER_MISSING_TOKEN, "PurchaseInfo is missing token for sku: "
+                   + sku + " " + itemInfo);
+            }
+
+            logDebug("Consuming sku: " + sku + ", token: " + token);
+            int response = mService.consumePurchase(3, mContext.getPackageName(), token);
+            if (response == BILLING_RESPONSE_RESULT_OK) {
+               logDebug("Successfully consumed sku: " + sku);
+            }
+            else {
+               logDebug("Error consuming consuming sku " + sku + ". " + getResponseDesc(response));
+               throw new IabException(response, "Error consuming sku " + sku);
+            }
+        }
+        catch (RemoteException e) {
+            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while consuming. PurchaseInfo: " + itemInfo, e);
+        }
+    }
+
+    /**
+     * Callback that notifies when a consumption operation finishes.
+     */
+    public interface OnConsumeFinishedListener {
+        /**
+         * Called to notify that a consumption has finished.
+         *
+         * @param purchase The purchase that was (or was to be) consumed.
+         * @param result The result of the consumption operation.
+         */
+        public void onConsumeFinished(Purchase purchase, IabResult result);
+    }
+
+    /**
+     * Callback that notifies when a multi-item consumption operation finishes.
+     */
+    public interface OnConsumeMultiFinishedListener {
+        /**
+         * Called to notify that a consumption of multiple items has finished.
+         *
+         * @param purchases The purchases that were (or were to be) consumed.
+         * @param results The results of each consumption operation, corresponding to each
+         *     sku.
+         */
+        public void onConsumeMultiFinished(List<Purchase> purchases, List<IabResult> results);
+    }
+
+    /**
+     * Asynchronous wrapper to item consumption. Works like {@link #consume}, but
+     * performs the consumption in the background and notifies completion through
+     * the provided listener. This method is safe to call from a UI thread.
+     *
+     * @param purchase The purchase to be consumed.
+     * @param listener The listener to notify when the consumption operation finishes.
+     */
+    public void consumeAsync(Purchase purchase, OnConsumeFinishedListener listener) {
+        checkNotDisposed();
+        checkSetupDone("consume");
+        List<Purchase> purchases = new ArrayList<Purchase>();
+        purchases.add(purchase);
+        consumeAsyncInternal(purchases, listener, null);
+    }
+
+    /**
+     * Same as {@link consumeAsync}, but for multiple items at once.
+     * @param purchases The list of PurchaseInfo objects representing the purchases to consume.
+     * @param listener The listener to notify when the consumption operation finishes.
+     */
+    public void consumeAsync(List<Purchase> purchases, OnConsumeMultiFinishedListener listener) {
+        checkNotDisposed();
+        checkSetupDone("consume");
+        consumeAsyncInternal(purchases, null, listener);
+    }
+
+    /**
+     * Returns a human-readable description for the given response code.
+     *
+     * @param code The response code
+     * @return A human-readable string explaining the result code.
+     *     It also includes the result code numerically.
+     */
+    public static String getResponseDesc(int code) {
+        String[] iab_msgs = ("0:OK/1:User Canceled/2:Unknown/" +
+                "3:Billing Unavailable/4:Item unavailable/" +
+                "5:Developer Error/6:Error/7:Item Already Owned/" +
+                "8:Item not owned").split("/");
+        String[] iabhelper_msgs = ("0:OK/-1001:Remote exception during initialization/" +
+                                   "-1002:Bad response received/" +
+                                   "-1003:Purchase signature verification failed/" +
+                                   "-1004:Send intent failed/" +
+                                   "-1005:User cancelled/" +
+                                   "-1006:Unknown purchase response/" +
+                                   "-1007:Missing token/" +
+                                   "-1008:Unknown error/" +
+                                   "-1009:Subscriptions not available/" +
+                                   "-1010:Invalid consumption attempt").split("/");
+
+        if (code <= IABHELPER_ERROR_BASE) {
+            int index = IABHELPER_ERROR_BASE - code;
+            if (index >= 0 && index < iabhelper_msgs.length) return iabhelper_msgs[index];
+            else return String.valueOf(code) + ":Unknown IAB Helper Error";
+        }
+        else if (code < 0 || code >= iab_msgs.length)
+            return String.valueOf(code) + ":Unknown";
+        else
+            return iab_msgs[code];
+    }
+
+
+    // Checks that setup was done; if not, throws an exception.
+    void checkSetupDone(String operation) {
+        if (!mSetupDone) {
+            logError("Illegal state for operation (" + operation + "): IAB helper is not set up.");
+            throw new IllegalStateException("IAB helper is not set up. Can't perform operation: " + operation);
+        }
+    }
+
+    // Workaround to bug where sometimes response codes come as Long instead of Integer
+    int getResponseCodeFromBundle(Bundle b) {
+        Object o = b.get(RESPONSE_CODE);
+        if (o == null) {
+            logDebug("Bundle with null response code, assuming OK (known issue)");
+            return BILLING_RESPONSE_RESULT_OK;
+        }
+        else if (o instanceof Integer) return ((Integer)o).intValue();
+        else if (o instanceof Long) return (int)((Long)o).longValue();
+        else {
+            logError("Unexpected type for bundle response code.");
+            logError(o.getClass().getName());
+            throw new RuntimeException("Unexpected type for bundle response code: " + o.getClass().getName());
+        }
+    }
+
+    // Workaround to bug where sometimes response codes come as Long instead of Integer
+    int getResponseCodeFromIntent(Intent i) {
+        Object o = i.getExtras().get(RESPONSE_CODE);
+        if (o == null) {
+            logError("Intent with no response code, assuming OK (known issue)");
+            return BILLING_RESPONSE_RESULT_OK;
+        }
+        else if (o instanceof Integer) return ((Integer)o).intValue();
+        else if (o instanceof Long) return (int)((Long)o).longValue();
+        else {
+            logError("Unexpected type for intent response code.");
+            logError(o.getClass().getName());
+            throw new RuntimeException("Unexpected type for intent response code: " + o.getClass().getName());
+        }
+    }
+
+    void flagStartAsync(String operation) {
+        if (mAsyncInProgress) throw new IllegalStateException("Can't start async operation (" +
+                operation + ") because another async operation(" + mAsyncOperation + ") is in progress.");
+        mAsyncOperation = operation;
+        mAsyncInProgress = true;
+        logDebug("Starting async operation: " + operation);
+    }
+
+    void flagEndAsync() {
+        logDebug("Ending async operation: " + mAsyncOperation);
+        mAsyncOperation = "";
+        mAsyncInProgress = false;
+    }
+
+
+    int queryPurchases(Inventory inv, String itemType) throws JSONException, RemoteException {
+        // Query purchases
+        logDebug("Querying owned items, item type: " + itemType);
+        logDebug("Package name: " + mContext.getPackageName());
+        boolean verificationFailed = false;
+        String continueToken = null;
+
+        do {
+            logDebug("Calling getPurchases with continuation token: " + continueToken);
+            Bundle ownedItems = mService.getPurchases(3, mContext.getPackageName(),
+                    itemType, continueToken);
+
+            int response = getResponseCodeFromBundle(ownedItems);
+            logDebug("Owned items response: " + String.valueOf(response));
+            if (response != BILLING_RESPONSE_RESULT_OK) {
+                logDebug("getPurchases() failed: " + getResponseDesc(response));
+                return response;
+            }
+            if (!ownedItems.containsKey(RESPONSE_INAPP_ITEM_LIST)
+                    || !ownedItems.containsKey(RESPONSE_INAPP_PURCHASE_DATA_LIST)
+                    || !ownedItems.containsKey(RESPONSE_INAPP_SIGNATURE_LIST)) {
+                logError("Bundle returned from getPurchases() doesn't contain required fields.");
+                return IABHELPER_BAD_RESPONSE;
+            }
+
+            ArrayList<String> ownedSkus = ownedItems.getStringArrayList(
+                        RESPONSE_INAPP_ITEM_LIST);
+            ArrayList<String> purchaseDataList = ownedItems.getStringArrayList(
+                        RESPONSE_INAPP_PURCHASE_DATA_LIST);
+            ArrayList<String> signatureList = ownedItems.getStringArrayList(
+                        RESPONSE_INAPP_SIGNATURE_LIST);
+
+            for (int i = 0; i < purchaseDataList.size(); ++i) {
+                String purchaseData = purchaseDataList.get(i);
+                String signature = signatureList.get(i);
+                String sku = ownedSkus.get(i);
+                if (Security.verifyPurchase(mSignatureBase64, purchaseData, signature)) {
+                    logDebug("Sku is owned: " + sku);
+                    Purchase purchase = new Purchase(itemType, purchaseData, signature);
+
+                    if (TextUtils.isEmpty(purchase.getToken())) {
+                        logWarn("BUG: empty/null token!");
+                        logDebug("Purchase data: " + purchaseData);
+                    }
+
+                    // Record ownership and token
+                    inv.addPurchase(purchase);
+                }
+                else {
+                    logWarn("Purchase signature verification **FAILED**. Not adding item.");
+                    logDebug("   Purchase data: " + purchaseData);
+                    logDebug("   Signature: " + signature);
+                    verificationFailed = true;
+                }
+            }
+
+            continueToken = ownedItems.getString(INAPP_CONTINUATION_TOKEN);
+            logDebug("Continuation token: " + continueToken);
+        } while (!TextUtils.isEmpty(continueToken));
+
+        return verificationFailed ? IABHELPER_VERIFICATION_FAILED : BILLING_RESPONSE_RESULT_OK;
+    }
+
+    int querySkuDetails(String itemType, Inventory inv, List<String> moreSkus)
+                                throws RemoteException, JSONException {
+        logDebug("Querying SKU details.");
+        ArrayList<String> skuList = new ArrayList<String>();
+        skuList.addAll(inv.getAllOwnedSkus(itemType));
+        if (moreSkus != null) {
+            for (String sku : moreSkus) {
+                if (!skuList.contains(sku)) {
+                    skuList.add(sku);
+                }
+            }
+        }
+
+        if (skuList.size() == 0) {
+            logDebug("queryPrices: nothing to do because there are no SKUs.");
+            return BILLING_RESPONSE_RESULT_OK;
+        }
+
+        Bundle querySkus = new Bundle();
+        querySkus.putStringArrayList(GET_SKU_DETAILS_ITEM_LIST, skuList);
+        Bundle skuDetails = mService.getSkuDetails(3, mContext.getPackageName(),
+                itemType, querySkus);
+
+        if (!skuDetails.containsKey(RESPONSE_GET_SKU_DETAILS_LIST)) {
+            int response = getResponseCodeFromBundle(skuDetails);
+            if (response != BILLING_RESPONSE_RESULT_OK) {
+                logDebug("getSkuDetails() failed: " + getResponseDesc(response));
+                return response;
+            }
+            else {
+                logError("getSkuDetails() returned a bundle with neither an error nor a detail list.");
+                return IABHELPER_BAD_RESPONSE;
+            }
+        }
+
+        ArrayList<String> responseList = skuDetails.getStringArrayList(
+                RESPONSE_GET_SKU_DETAILS_LIST);
+
+        for (String thisResponse : responseList) {
+            SkuDetails d = new SkuDetails(itemType, thisResponse);
+            logDebug("Got sku details: " + d);
+            inv.addSkuDetails(d);
+        }
+        return BILLING_RESPONSE_RESULT_OK;
+    }
+
+
+    void consumeAsyncInternal(final List<Purchase> purchases,
+                              final OnConsumeFinishedListener singleListener,
+                              final OnConsumeMultiFinishedListener multiListener) {
+        final Handler handler = new Handler();
+        flagStartAsync("consume");
+        (new Thread(new Runnable() {
+            public void run() {
+                final List<IabResult> results = new ArrayList<IabResult>();
+                for (Purchase purchase : purchases) {
+                    try {
+                        consume(purchase);
+                        results.add(new IabResult(BILLING_RESPONSE_RESULT_OK, "Successful consume of sku " + purchase.getSku()));
+                    }
+                    catch (IabException ex) {
+                        results.add(ex.getResult());
+                    }
+                }
+
+                flagEndAsync();
+                if (!mDisposed && singleListener != null) {
+                    handler.post(new Runnable() {
+                        public void run() {
+                            singleListener.onConsumeFinished(purchases.get(0), results.get(0));
+                        }
+                    });
+                }
+                if (!mDisposed && multiListener != null) {
+                    handler.post(new Runnable() {
+                        public void run() {
+                            multiListener.onConsumeMultiFinished(purchases, results);
+                        }
+                    });
+                }
+            }
+        })).start();
+    }
+
+    void logDebug(String msg) {
+        if (mDebugLog) Log.d(mDebugTag, msg);
+    }
+
+    void logError(String msg) {
+        Log.e(mDebugTag, "In-app billing error: " + msg);
+    }
+
+    void logWarn(String msg) {
+        Log.w(mDebugTag, "In-app billing warning: " + msg);
+    }
+}
Index: CSipSimple/src/ro/callromania/util/IabResult.java
===================================================================
--- CSipSimple/src/ro/callromania/util/IabResult.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/IabResult.java	(working copy)
@@ -0,0 +1,45 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+/**
+ * Represents the result of an in-app billing operation.
+ * A result is composed of a response code (an integer) and possibly a
+ * message (String). You can get those by calling
+ * {@link #getResponse} and {@link #getMessage()}, respectively. You
+ * can also inquire whether a result is a success or a failure by
+ * calling {@link #isSuccess()} and {@link #isFailure()}.
+ */
+public class IabResult {
+    int mResponse;
+    String mMessage;
+
+    public IabResult(int response, String message) {
+        mResponse = response;
+        if (message == null || message.trim().length() == 0) {
+            mMessage = IabHelper.getResponseDesc(response);
+        }
+        else {
+            mMessage = message + " (response: " + IabHelper.getResponseDesc(response) + ")";
+        }
+    }
+    public int getResponse() { return mResponse; }
+    public String getMessage() { return mMessage; }
+    public boolean isSuccess() { return ((mResponse == IabHelper.BILLING_RESPONSE_RESULT_OK) || (mResponse == IabHelper.BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED)); }
+    public boolean isFailure() { return !isSuccess(); }
+    public String toString() { return "IabResult: " + getMessage(); }
+}
+
Index: CSipSimple/src/ro/callromania/util/Inventory.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Inventory.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Inventory.java	(working copy)
@@ -0,0 +1,91 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Represents a block of information about in-app items.
+ * An Inventory is returned by such methods as {@link IabHelper#queryInventory}.
+ */
+public class Inventory {
+    Map<String,SkuDetails> mSkuMap = new HashMap<String,SkuDetails>();
+    Map<String,Purchase> mPurchaseMap = new HashMap<String,Purchase>();
+
+    Inventory() { }
+
+    /** Returns the listing details for an in-app product. */
+    public SkuDetails getSkuDetails(String sku) {
+        return mSkuMap.get(sku);
+    }
+
+    /** Returns purchase information for a given product, or null if there is no purchase. */
+    public Purchase getPurchase(String sku) {
+        return mPurchaseMap.get(sku);
+    }
+
+    /** Returns whether or not there exists a purchase of the given product. */
+    public boolean hasPurchase(String sku) {
+        return mPurchaseMap.containsKey(sku);
+    }
+
+    /** Return whether or not details about the given product are available. */
+    public boolean hasDetails(String sku) {
+        return mSkuMap.containsKey(sku);
+    }
+
+    /**
+     * Erase a purchase (locally) from the inventory, given its product ID. This just
+     * modifies the Inventory object locally and has no effect on the server! This is
+     * useful when you have an existing Inventory object which you know to be up to date,
+     * and you have just consumed an item successfully, which means that erasing its
+     * purchase data from the Inventory you already have is quicker than querying for
+     * a new Inventory.
+     */
+    public void erasePurchase(String sku) {
+        if (mPurchaseMap.containsKey(sku)) mPurchaseMap.remove(sku);
+    }
+
+    /** Returns a list of all owned product IDs. */
+    List<String> getAllOwnedSkus() {
+        return new ArrayList<String>(mPurchaseMap.keySet());
+    }
+
+    /** Returns a list of all owned product IDs of a given type */
+    List<String> getAllOwnedSkus(String itemType) {
+        List<String> result = new ArrayList<String>();
+        for (Purchase p : mPurchaseMap.values()) {
+            if (p.getItemType().equals(itemType)) result.add(p.getSku());
+        }
+        return result;
+    }
+
+    /** Returns a list of all purchases. */
+    List<Purchase> getAllPurchases() {
+        return new ArrayList<Purchase>(mPurchaseMap.values());
+    }
+
+    void addSkuDetails(SkuDetails d) {
+        mSkuMap.put(d.getSku(), d);
+    }
+
+    void addPurchase(Purchase p) {
+        mPurchaseMap.put(p.getSku(), p);
+    }
+}
Index: CSipSimple/src/ro/callromania/util/Purchase.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Purchase.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Purchase.java	(working copy)
@@ -0,0 +1,63 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Represents an in-app billing purchase.
+ */
+public class Purchase {
+    String mItemType;  // ITEM_TYPE_INAPP or ITEM_TYPE_SUBS
+    String mOrderId;
+    String mPackageName;
+    String mSku;
+    long mPurchaseTime;
+    int mPurchaseState;
+    String mDeveloperPayload;
+    String mToken;
+    String mOriginalJson;
+    String mSignature;
+
+    public Purchase(String itemType, String jsonPurchaseInfo, String signature) throws JSONException {
+        mItemType = itemType;
+        mOriginalJson = jsonPurchaseInfo;
+        JSONObject o = new JSONObject(mOriginalJson);
+        mOrderId = o.optString("orderId");
+        mPackageName = o.optString("packageName");
+        mSku = o.optString("productId");
+        mPurchaseTime = o.optLong("purchaseTime");
+        mPurchaseState = o.optInt("purchaseState");
+        mDeveloperPayload = o.optString("developerPayload");
+        mToken = o.optString("token", o.optString("purchaseToken"));
+        mSignature = signature;
+    }
+
+    public String getItemType() { return mItemType; }
+    public String getOrderId() { return mOrderId; }
+    public String getPackageName() { return mPackageName; }
+    public String getSku() { return mSku; }
+    public long getPurchaseTime() { return mPurchaseTime; }
+    public int getPurchaseState() { return mPurchaseState; }
+    public String getDeveloperPayload() { return mDeveloperPayload; }
+    public String getToken() { return mToken; }
+    public String getOriginalJson() { return mOriginalJson; }
+    public String getSignature() { return mSignature; }
+
+    @Override
+    public String toString() { return "PurchaseInfo(type:" + mItemType + "):" + mOriginalJson; }
+}
Index: CSipSimple/src/ro/callromania/util/Security.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Security.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Security.java	(working copy)
@@ -0,0 +1,123 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import android.text.TextUtils;
+import android.util.Log;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+
+import java.security.InvalidKeyException;
+import java.security.KeyFactory;
+import java.security.NoSuchAlgorithmException;
+import java.security.PublicKey;
+import java.security.Signature;
+import java.security.SignatureException;
+import java.security.spec.InvalidKeySpecException;
+import java.security.spec.X509EncodedKeySpec;
+
+/**
+ * Security-related methods. For a secure implementation, all of this code
+ * should be implemented on a server that communicates with the
+ * application on the device. For the sake of simplicity and clarity of this
+ * example, this code is included here and is executed on the device. If you
+ * must verify the purchases on the phone, you should obfuscate this code to
+ * make it harder for an attacker to replace the code with stubs that treat all
+ * purchases as verified.
+ */
+public class Security {
+    private static final String TAG = "IABUtil/Security";
+
+    private static final String KEY_FACTORY_ALGORITHM = "RSA";
+    private static final String SIGNATURE_ALGORITHM = "SHA1withRSA";
+
+    /**
+     * Verifies that the data was signed with the given signature, and returns
+     * the verified purchase. The data is in JSON format and signed
+     * with a private key. The data also contains the {@link PurchaseState}
+     * and product ID of the purchase.
+     * @param base64PublicKey the base64-encoded public key to use for verifying.
+     * @param signedData the signed JSON string (signed, not encrypted)
+     * @param signature the signature for the data, signed with the private key
+     */
+    public static boolean verifyPurchase(String base64PublicKey, String signedData, String signature) {
+        if (TextUtils.isEmpty(signedData) || TextUtils.isEmpty(base64PublicKey) ||
+                TextUtils.isEmpty(signature)) {
+            Log.e(TAG, "Purchase verification failed: missing data.");
+            return false;
+        }
+
+        PublicKey key = Security.generatePublicKey(base64PublicKey);
+        return Security.verify(key, signedData, signature);
+    }
+
+    /**
+     * Generates a PublicKey instance from a string containing the
+     * Base64-encoded public key.
+     *
+     * @param encodedPublicKey Base64-encoded public key
+     * @throws IllegalArgumentException if encodedPublicKey is invalid
+     */
+    public static PublicKey generatePublicKey(String encodedPublicKey) {
+        try {
+            byte[] decodedKey = Base64.decode(encodedPublicKey);
+            KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);
+            return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey));
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+        } catch (InvalidKeySpecException e) {
+            Log.e(TAG, "Invalid key specification.");
+            throw new IllegalArgumentException(e);
+        } catch (Base64DecoderException e) {
+            Log.e(TAG, "Base64 decoding failed.");
+            throw new IllegalArgumentException(e);
+        }
+    }
+
+    /**
+     * Verifies that the signature from the server matches the computed
+     * signature on the data.  Returns true if the data is correctly signed.
+     *
+     * @param publicKey public key associated with the developer account
+     * @param signedData signed data from server
+     * @param signature server signature
+     * @return true if the data and signature match
+     */
+    public static boolean verify(PublicKey publicKey, String signedData, String signature) {
+        Signature sig;
+        try {
+            sig = Signature.getInstance(SIGNATURE_ALGORITHM);
+            sig.initVerify(publicKey);
+            sig.update(signedData.getBytes());
+            if (!sig.verify(Base64.decode(signature))) {
+                Log.e(TAG, "Signature verification failed.");
+                return false;
+            }
+            return true;
+        } catch (NoSuchAlgorithmException e) {
+            Log.e(TAG, "NoSuchAlgorithmException.");
+        } catch (InvalidKeyException e) {
+            Log.e(TAG, "Invalid key specification.");
+        } catch (SignatureException e) {
+            Log.e(TAG, "Signature exception.");
+        } catch (Base64DecoderException e) {
+            Log.e(TAG, "Base64 decoding failed.");
+        }
+        return false;
+    }
+}
Index: CSipSimple/src/ro/callromania/util/SkuDetails.java
===================================================================
--- CSipSimple/src/ro/callromania/util/SkuDetails.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/SkuDetails.java	(working copy)
@@ -0,0 +1,58 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Represents an in-app product's listing details.
+ */
+public class SkuDetails {
+    String mItemType;
+    String mSku;
+    String mType;
+    String mPrice;
+    String mTitle;
+    String mDescription;
+    String mJson;
+
+    public SkuDetails(String jsonSkuDetails) throws JSONException {
+        this(IabHelper.ITEM_TYPE_INAPP, jsonSkuDetails);
+    }
+
+    public SkuDetails(String itemType, String jsonSkuDetails) throws JSONException {
+        mItemType = itemType;
+        mJson = jsonSkuDetails;
+        JSONObject o = new JSONObject(mJson);
+        mSku = o.optString("productId");
+        mType = o.optString("type");
+        mPrice = o.optString("price");
+        mTitle = o.optString("title");
+        mDescription = o.optString("description");
+    }
+
+    public String getSku() { return mSku; }
+    public String getType() { return mType; }
+    public String getPrice() { return mPrice; }
+    public String getTitle() { return mTitle; }
+    public String getDescription() { return mDescription; }
+
+    @Override
+    public String toString() {
+        return "SkuDetails:" + mJson;
+    }
+}
Index: CSipSimple/src/ro/callromania/util/Base64.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Base64.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Base64.java	(working copy)
@@ -0,0 +1,570 @@
+// Portions copyright 2002, Google, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ro.callromania.util;
+
+// This code was converted from code at http://iharder.sourceforge.net/base64/
+// Lots of extraneous features were removed.
+/* The original code said:
+ * <p>
+ * I am placing this code in the Public Domain. Do with it as you will.
+ * This software comes with no guarantees or warranties but with
+ * plenty of well-wishing instead!
+ * Please visit
+ * <a href="http://iharder.net/xmlizable">http://iharder.net/xmlizable</a>
+ * periodically to check for updates or to contribute improvements.
+ * </p>
+ *
+ * @author Robert Harder
+ * @author rharder@usa.net
+ * @version 1.3
+ */
+
+/**
+ * Base64 converter class. This code is not a complete MIME encoder;
+ * it simply converts binary data to base64 data and back.
+ *
+ * <p>Note {@link CharBase64} is a GWT-compatible implementation of this
+ * class.
+ */
+public class Base64 {
+    /** Specify encoding (value is {@code true}). */
+    public final static boolean ENCODE = true;
+
+    /** Specify decoding (value is {@code false}). */
+    public final static boolean DECODE = false;
+
+    /** The equals sign (=) as a byte. */
+    private final static byte EQUALS_SIGN = (byte) '=';
+
+    /** The new line character (\n) as a byte. */
+    private final static byte NEW_LINE = (byte) '\n';
+
+    /**
+     * The 64 valid Base64 values.
+     */
+    private final static byte[] ALPHABET =
+        {(byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
+        (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
+        (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
+        (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
+        (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
+        (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
+        (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',
+        (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
+        (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't',
+        (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y',
+        (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
+        (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
+        (byte) '9', (byte) '+', (byte) '/'};
+
+    /**
+     * The 64 valid web safe Base64 values.
+     */
+    private final static byte[] WEBSAFE_ALPHABET =
+        {(byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
+        (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
+        (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
+        (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
+        (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
+        (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
+        (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',
+        (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
+        (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't',
+        (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y',
+        (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
+        (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
+        (byte) '9', (byte) '-', (byte) '_'};
+
+    /**
+     * Translates a Base64 value to either its 6-bit reconstruction value
+     * or a negative number indicating some other meaning.
+     **/
+    private final static byte[] DECODABET = {-9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
+        -5, -5, // Whitespace: Tab and Linefeed
+        -9, -9, // Decimal 11 - 12
+        -5, // Whitespace: Carriage Return
+        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
+        -9, -9, -9, -9, -9, // Decimal 27 - 31
+        -5, // Whitespace: Space
+        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
+        62, // Plus sign at decimal 43
+        -9, -9, -9, // Decimal 44 - 46
+        63, // Slash at decimal 47
+        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
+        -9, -9, -9, // Decimal 58 - 60
+        -1, // Equals sign at decimal 61
+        -9, -9, -9, // Decimal 62 - 64
+        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
+        14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
+        -9, -9, -9, -9, -9, -9, // Decimal 91 - 96
+        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
+        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
+        -9, -9, -9, -9, -9 // Decimal 123 - 127
+        /*  ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
+    };
+
+    /** The web safe decodabet */
+    private final static byte[] WEBSAFE_DECODABET =
+        {-9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
+        -5, -5, // Whitespace: Tab and Linefeed
+        -9, -9, // Decimal 11 - 12
+        -5, // Whitespace: Carriage Return
+        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
+        -9, -9, -9, -9, -9, // Decimal 27 - 31
+        -5, // Whitespace: Space
+        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 44
+        62, // Dash '-' sign at decimal 45
+        -9, -9, // Decimal 46-47
+        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
+        -9, -9, -9, // Decimal 58 - 60
+        -1, // Equals sign at decimal 61
+        -9, -9, -9, // Decimal 62 - 64
+        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
+        14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
+        -9, -9, -9, -9, // Decimal 91-94
+        63, // Underscore '_' at decimal 95
+        -9, // Decimal 96
+        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
+        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
+        -9, -9, -9, -9, -9 // Decimal 123 - 127
+        /*  ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
+        };
+
+    // Indicates white space in encoding
+    private final static byte WHITE_SPACE_ENC = -5;
+    // Indicates equals sign in encoding
+    private final static byte EQUALS_SIGN_ENC = -1;
+
+    /** Defeats instantiation. */
+    private Base64() {
+    }
+
+    /* ********  E N C O D I N G   M E T H O D S  ******** */
+
+    /**
+     * Encodes up to three bytes of the array <var>source</var>
+     * and writes the resulting four Base64 bytes to <var>destination</var>.
+     * The source and destination arrays can be manipulated
+     * anywhere along their length by specifying
+     * <var>srcOffset</var> and <var>destOffset</var>.
+     * This method does not check to make sure your arrays
+     * are large enough to accommodate <var>srcOffset</var> + 3 for
+     * the <var>source</var> array or <var>destOffset</var> + 4 for
+     * the <var>destination</var> array.
+     * The actual number of significant bytes in your array is
+     * given by <var>numSigBytes</var>.
+     *
+     * @param source the array to convert
+     * @param srcOffset the index where conversion begins
+     * @param numSigBytes the number of significant bytes in your array
+     * @param destination the array to hold the conversion
+     * @param destOffset the index where output will be put
+     * @param alphabet is the encoding alphabet
+     * @return the <var>destination</var> array
+     * @since 1.3
+     */
+    private static byte[] encode3to4(byte[] source, int srcOffset,
+            int numSigBytes, byte[] destination, int destOffset, byte[] alphabet) {
+        //           1         2         3
+        // 01234567890123456789012345678901 Bit position
+        // --------000000001111111122222222 Array position from threeBytes
+        // --------|    ||    ||    ||    | Six bit groups to index alphabet
+        //          >>18  >>12  >> 6  >> 0  Right shift necessary
+        //                0x3f  0x3f  0x3f  Additional AND
+
+        // Create buffer with zero-padding if there are only one or two
+        // significant bytes passed in the array.
+        // We have to shift left 24 in order to flush out the 1's that appear
+        // when Java treats a value as negative that is cast from a byte to an int.
+        int inBuff =
+                (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0)
+                | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0)
+                | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);
+
+        switch (numSigBytes) {
+            case 3:
+                destination[destOffset] = alphabet[(inBuff >>> 18)];
+                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
+                destination[destOffset + 2] = alphabet[(inBuff >>> 6) & 0x3f];
+                destination[destOffset + 3] = alphabet[(inBuff) & 0x3f];
+                return destination;
+            case 2:
+                destination[destOffset] = alphabet[(inBuff >>> 18)];
+                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
+                destination[destOffset + 2] = alphabet[(inBuff >>> 6) & 0x3f];
+                destination[destOffset + 3] = EQUALS_SIGN;
+                return destination;
+            case 1:
+                destination[destOffset] = alphabet[(inBuff >>> 18)];
+                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
+                destination[destOffset + 2] = EQUALS_SIGN;
+                destination[destOffset + 3] = EQUALS_SIGN;
+                return destination;
+            default:
+                return destination;
+        } // end switch
+    } // end encode3to4
+
+    /**
+     * Encodes a byte array into Base64 notation.
+     * Equivalent to calling
+     * {@code encodeBytes(source, 0, source.length)}
+     *
+     * @param source The data to convert
+     * @since 1.4
+     */
+    public static String encode(byte[] source) {
+        return encode(source, 0, source.length, ALPHABET, true);
+    }
+
+    /**
+     * Encodes a byte array into web safe Base64 notation.
+     *
+     * @param source The data to convert
+     * @param doPadding is {@code true} to pad result with '=' chars
+     *        if it does not fall on 3 byte boundaries
+     */
+    public static String encodeWebSafe(byte[] source, boolean doPadding) {
+        return encode(source, 0, source.length, WEBSAFE_ALPHABET, doPadding);
+    }
+
+    /**
+     * Encodes a byte array into Base64 notation.
+     *
+     * @param source the data to convert
+     * @param off offset in array where conversion should begin
+     * @param len length of data to convert
+     * @param alphabet the encoding alphabet
+     * @param doPadding is {@code true} to pad result with '=' chars
+     * if it does not fall on 3 byte boundaries
+     * @since 1.4
+     */
+    public static String encode(byte[] source, int off, int len, byte[] alphabet,
+            boolean doPadding) {
+        byte[] outBuff = encode(source, off, len, alphabet, Integer.MAX_VALUE);
+        int outLen = outBuff.length;
+
+        // If doPadding is false, set length to truncate '='
+        // padding characters
+        while (doPadding == false && outLen > 0) {
+            if (outBuff[outLen - 1] != '=') {
+                break;
+            }
+            outLen -= 1;
+        }
+
+        return new String(outBuff, 0, outLen);
+    }
+
+    /**
+     * Encodes a byte array into Base64 notation.
+     *
+     * @param source the data to convert
+     * @param off offset in array where conversion should begin
+     * @param len length of data to convert
+     * @param alphabet is the encoding alphabet
+     * @param maxLineLength maximum length of one line.
+     * @return the BASE64-encoded byte array
+     */
+    public static byte[] encode(byte[] source, int off, int len, byte[] alphabet,
+            int maxLineLength) {
+        int lenDiv3 = (len + 2) / 3; // ceil(len / 3)
+        int len43 = lenDiv3 * 4;
+        byte[] outBuff = new byte[len43 // Main 4:3
+                                  + (len43 / maxLineLength)]; // New lines
+
+        int d = 0;
+        int e = 0;
+        int len2 = len - 2;
+        int lineLength = 0;
+        for (; d < len2; d += 3, e += 4) {
+
+            // The following block of code is the same as
+            // encode3to4( source, d + off, 3, outBuff, e, alphabet );
+            // but inlined for faster encoding (~20% improvement)
+            int inBuff =
+                    ((source[d + off] << 24) >>> 8)
+                    | ((source[d + 1 + off] << 24) >>> 16)
+                    | ((source[d + 2 + off] << 24) >>> 24);
+            outBuff[e] = alphabet[(inBuff >>> 18)];
+            outBuff[e + 1] = alphabet[(inBuff >>> 12) & 0x3f];
+            outBuff[e + 2] = alphabet[(inBuff >>> 6) & 0x3f];
+            outBuff[e + 3] = alphabet[(inBuff) & 0x3f];
+
+            lineLength += 4;
+            if (lineLength == maxLineLength) {
+                outBuff[e + 4] = NEW_LINE;
+                e++;
+                lineLength = 0;
+            } // end if: end of line
+        } // end for: each piece of array
+
+        if (d < len) {
+            encode3to4(source, d + off, len - d, outBuff, e, alphabet);
+
+            lineLength += 4;
+            if (lineLength == maxLineLength) {
+                // Add a last newline
+                outBuff[e + 4] = NEW_LINE;
+                e++;
+            }
+            e += 4;
+        }
+
+        assert (e == outBuff.length);
+        return outBuff;
+    }
+
+
+    /* ********  D E C O D I N G   M E T H O D S  ******** */
+
+
+    /**
+     * Decodes four bytes from array <var>source</var>
+     * and writes the resulting bytes (up to three of them)
+     * to <var>destination</var>.
+     * The source and destination arrays can be manipulated
+     * anywhere along their length by specifying
+     * <var>srcOffset</var> and <var>destOffset</var>.
+     * This method does not check to make sure your arrays
+     * are large enough to accommodate <var>srcOffset</var> + 4 for
+     * the <var>source</var> array or <var>destOffset</var> + 3 for
+     * the <var>destination</var> array.
+     * This method returns the actual number of bytes that
+     * were converted from the Base64 encoding.
+     *
+     *
+     * @param source the array to convert
+     * @param srcOffset the index where conversion begins
+     * @param destination the array to hold the conversion
+     * @param destOffset the index where output will be put
+     * @param decodabet the decodabet for decoding Base64 content
+     * @return the number of decoded bytes converted
+     * @since 1.3
+     */
+    private static int decode4to3(byte[] source, int srcOffset,
+            byte[] destination, int destOffset, byte[] decodabet) {
+        // Example: Dk==
+        if (source[srcOffset + 2] == EQUALS_SIGN) {
+            int outBuff =
+                    ((decodabet[source[srcOffset]] << 24) >>> 6)
+                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12);
+
+            destination[destOffset] = (byte) (outBuff >>> 16);
+            return 1;
+        } else if (source[srcOffset + 3] == EQUALS_SIGN) {
+            // Example: DkL=
+            int outBuff =
+                    ((decodabet[source[srcOffset]] << 24) >>> 6)
+                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)
+                    | ((decodabet[source[srcOffset + 2]] << 24) >>> 18);
+
+            destination[destOffset] = (byte) (outBuff >>> 16);
+            destination[destOffset + 1] = (byte) (outBuff >>> 8);
+            return 2;
+        } else {
+            // Example: DkLE
+            int outBuff =
+                    ((decodabet[source[srcOffset]] << 24) >>> 6)
+                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)
+                    | ((decodabet[source[srcOffset + 2]] << 24) >>> 18)
+                    | ((decodabet[source[srcOffset + 3]] << 24) >>> 24);
+
+            destination[destOffset] = (byte) (outBuff >> 16);
+            destination[destOffset + 1] = (byte) (outBuff >> 8);
+            destination[destOffset + 2] = (byte) (outBuff);
+            return 3;
+        }
+    } // end decodeToBytes
+
+
+    /**
+     * Decodes data from Base64 notation.
+     *
+     * @param s the string to decode (decoded in default encoding)
+     * @return the decoded data
+     * @since 1.4
+     */
+    public static byte[] decode(String s) throws Base64DecoderException {
+        byte[] bytes = s.getBytes();
+        return decode(bytes, 0, bytes.length);
+    }
+
+    /**
+     * Decodes data from web safe Base64 notation.
+     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
+     *
+     * @param s the string to decode (decoded in default encoding)
+     * @return the decoded data
+     */
+    public static byte[] decodeWebSafe(String s) throws Base64DecoderException {
+        byte[] bytes = s.getBytes();
+        return decodeWebSafe(bytes, 0, bytes.length);
+    }
+
+    /**
+     * Decodes Base64 content in byte array format and returns
+     * the decoded byte array.
+     *
+     * @param source The Base64 encoded data
+     * @return decoded data
+     * @since 1.3
+     * @throws Base64DecoderException
+     */
+    public static byte[] decode(byte[] source) throws Base64DecoderException {
+        return decode(source, 0, source.length);
+    }
+
+    /**
+     * Decodes web safe Base64 content in byte array format and returns
+     * the decoded data.
+     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
+     *
+     * @param source the string to decode (decoded in default encoding)
+     * @return the decoded data
+     */
+    public static byte[] decodeWebSafe(byte[] source)
+            throws Base64DecoderException {
+        return decodeWebSafe(source, 0, source.length);
+    }
+
+    /**
+     * Decodes Base64 content in byte array format and returns
+     * the decoded byte array.
+     *
+     * @param source the Base64 encoded data
+     * @param off    the offset of where to begin decoding
+     * @param len    the length of characters to decode
+     * @return decoded data
+     * @since 1.3
+     * @throws Base64DecoderException
+     */
+    public static byte[] decode(byte[] source, int off, int len)
+            throws Base64DecoderException {
+        return decode(source, off, len, DECODABET);
+    }
+
+    /**
+     * Decodes web safe Base64 content in byte array format and returns
+     * the decoded byte array.
+     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
+     *
+     * @param source the Base64 encoded data
+     * @param off    the offset of where to begin decoding
+     * @param len    the length of characters to decode
+     * @return decoded data
+     */
+    public static byte[] decodeWebSafe(byte[] source, int off, int len)
+            throws Base64DecoderException {
+        return decode(source, off, len, WEBSAFE_DECODABET);
+    }
+
+    /**
+     * Decodes Base64 content using the supplied decodabet and returns
+     * the decoded byte array.
+     *
+     * @param source the Base64 encoded data
+     * @param off the offset of where to begin decoding
+     * @param len the length of characters to decode
+     * @param decodabet the decodabet for decoding Base64 content
+     * @return decoded data
+     */
+    public static byte[] decode(byte[] source, int off, int len, byte[] decodabet)
+            throws Base64DecoderException {
+        int len34 = len * 3 / 4;
+        byte[] outBuff = new byte[2 + len34]; // Upper limit on size of output
+        int outBuffPosn = 0;
+
+        byte[] b4 = new byte[4];
+        int b4Posn = 0;
+        int i = 0;
+        byte sbiCrop = 0;
+        byte sbiDecode = 0;
+        for (i = 0; i < len; i++) {
+            sbiCrop = (byte) (source[i + off] & 0x7f); // Only the low seven bits
+            sbiDecode = decodabet[sbiCrop];
+
+            if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better
+                if (sbiDecode >= EQUALS_SIGN_ENC) {
+                    // An equals sign (for padding) must not occur at position 0 or 1
+                    // and must be the last byte[s] in the encoded value
+                    if (sbiCrop == EQUALS_SIGN) {
+                        int bytesLeft = len - i;
+                        byte lastByte = (byte) (source[len - 1 + off] & 0x7f);
+                        if (b4Posn == 0 || b4Posn == 1) {
+                            throw new Base64DecoderException(
+                                    "invalid padding byte '=' at byte offset " + i);
+                        } else if ((b4Posn == 3 && bytesLeft > 2)
+                                || (b4Posn == 4 && bytesLeft > 1)) {
+                            throw new Base64DecoderException(
+                                    "padding byte '=' falsely signals end of encoded value "
+                                            + "at offset " + i);
+                        } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {
+                            throw new Base64DecoderException(
+                                    "encoded value has invalid trailing byte");
+                        }
+                        break;
+                    }
+
+                    b4[b4Posn++] = sbiCrop;
+                    if (b4Posn == 4) {
+                        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);
+                        b4Posn = 0;
+                    }
+                }
+            } else {
+                throw new Base64DecoderException("Bad Base64 input character at " + i
+                        + ": " + source[i + off] + "(decimal)");
+            }
+        }
+
+        // Because web safe encoding allows non padding base64 encodes, we
+        // need to pad the rest of the b4 buffer with equal signs when
+        // b4Posn != 0.  There can be at most 2 equal signs at the end of
+        // four characters, so the b4 buffer must have two or three
+        // characters.  This also catches the case where the input is
+        // padded with EQUALS_SIGN
+        if (b4Posn != 0) {
+            if (b4Posn == 1) {
+                throw new Base64DecoderException("single trailing character at offset "
+                        + (len - 1));
+            }
+            b4[b4Posn++] = EQUALS_SIGN;
+            outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);
+        }
+
+        byte[] out = new byte[outBuffPosn];
+        System.arraycopy(outBuff, 0, out, 0, outBuffPosn);
+        return out;
+    }
+}
Index: CSipSimple/src/ro/callromania/util/Base64DecoderException.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Base64DecoderException.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Base64DecoderException.java	(working copy)
@@ -0,0 +1,32 @@
+// Copyright 2002, Google, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ro.callromania.util;
+
+/**
+ * Exception thrown when encountering an invalid Base64 input character.
+ *
+ * @author nelson
+ */
+public class Base64DecoderException extends Exception {
+    public Base64DecoderException() {
+        super();
+    }
+
+    public Base64DecoderException(String s) {
+        super(s);
+    }
+
+    private static final long serialVersionUID = 1L;
+}
Index: CSipSimple/src/ro/callromania/util/GcmBroadcastReceiver.java
===================================================================
--- CSipSimple/src/ro/callromania/util/GcmBroadcastReceiver.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/GcmBroadcastReceiver.java	(working copy)
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2013 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ro.callromania.util;
+
+import android.app.Activity;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.support.v4.content.WakefulBroadcastReceiver;
+
+
+/**
+ * This {@code WakefulBroadcastReceiver} takes care of creating and managing a
+ * partial wake lock for your app. It passes off the work of processing the GCM
+ * message to an {@code IntentService}, while ensuring that the device does not
+ * go back to sleep in the transition. The {@code IntentService} calls
+ * {@code GcmBroadcastReceiver.completeWakefulIntent()} when it is ready to
+ * release the wake lock.
+ */
+
+public class GcmBroadcastReceiver extends WakefulBroadcastReceiver 
+{
+
+    @Override
+    public void onReceive(Context context, Intent intent) 
+    {
+        // Explicitly specify that GcmIntentService will handle the intent.
+        ComponentName comp = new ComponentName(context.getPackageName(), GcmIntentService.class.getName());
+        // Start the service, keeping the device awake while it is launching.
+        startWakefulService(context, (intent.setComponent(comp)));
+        setResultCode(Activity.RESULT_OK);
+    }
+}
Index: CSipSimple/src/ro/callromania/util/GcmIntentService.java
===================================================================
--- CSipSimple/src/ro/callromania/util/GcmIntentService.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/GcmIntentService.java	(working copy)
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import ro.callromania.R;
+import android.app.IntentService;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.media.RingtoneManager;
+import android.os.Bundle;
+import android.support.v4.app.NotificationCompat;
+
+import com.csipsimple.ui.SipHome;
+import com.google.android.gms.gcm.GoogleCloudMessaging;
+
+/**
+ * This {@code IntentService} does the actual handling of the GCM message.
+ * {@code GcmBroadcastReceiver} (a {@code WakefulBroadcastReceiver}) holds a
+ * partial wake lock for this service while the service does its work. When the
+ * service is finished, it calls {@code completeWakefulIntent()} to release the
+ * wake lock.
+ */
+public class GcmIntentService extends IntentService 
+{
+    public static int NOTIFICATION_ID = 1;
+    private NotificationManager mNotificationManager;
+    NotificationCompat.Builder builder;
+
+    public GcmIntentService() 
+    {
+        super("GcmIntentService");
+    }
+    public static final String TAG = "GCM Demo";
+
+    @Override
+    protected void onHandleIntent(Intent intent) 
+    {
+        Bundle extras = intent.getExtras();
+        GoogleCloudMessaging gcm = GoogleCloudMessaging.getInstance(this);
+        // The getMessageType() intent parameter must be the intent you received
+        // in your BroadcastReceiver.
+        String messageType = gcm.getMessageType(intent);
+
+        if (!extras.isEmpty()) {  // has effect of unparcelling Bundle
+            /*
+             * Filter messages based on message type. Since it is likely that GCM will be
+             * extended in the future with new message types, just ignore any message types you're
+             * not interested in, or that you don't recognize.
+             */
+            if (GoogleCloudMessaging.MESSAGE_TYPE_SEND_ERROR.equals(messageType)) 
+            {
+            	//TODO: really ceck this out
+//                sendNotification("Send error: " + extras.toString());
+            }
+            else if (GoogleCloudMessaging.MESSAGE_TYPE_DELETED.equals(messageType)) 
+            {
+            	//TODO: really ceck this out
+//                sendNotification("Deleted messages on server: " + extras.toString());
+            // If it's a regular GCM message, do some work.
+            } 
+            else if (GoogleCloudMessaging.MESSAGE_TYPE_MESSAGE.equals(messageType)) 
+            {
+                // This loop represents the service doing some work.
+//                for (int i = 0; i < 5; i++) 
+//                {
+//                    Log.i(TAG, "Working... " + (i + 1)
+//                            + "/5 @ " + SystemClock.elapsedRealtime());
+//                    try {
+//                        Thread.sleep(5000);
+//                    } catch (InterruptedException e) {
+//                    }
+//                }
+//                Log.i(TAG, "Completed work @ " + SystemClock.elapsedRealtime());
+            	
+                // Post notification of received message.
+                sendNotification(extras);
+//                Log.i(TAG, "Received: " + extras.toString());
+            }
+        }
+        // Release the wake lock provided by the WakefulBroadcastReceiver.
+        GcmBroadcastReceiver.completeWakefulIntent(intent);
+    }
+
+    // Put the message into a notification and post it.
+    // This is just one simple example of what you might choose to do with
+    // a GCM message.
+    private void sendNotification(Bundle msg) 
+    {    	
+        mNotificationManager = (NotificationManager) this.getSystemService(Context.NOTIFICATION_SERVICE);
+
+        PendingIntent contentIntent = PendingIntent.getActivity(this, 0, new Intent(this, SipHome.class), PendingIntent.FLAG_UPDATE_CURRENT);
+        
+        String title = msg.getString("title");
+        if (title == null) title = "CallRomania";
+        
+        String subtitle = msg.getString("subtitle");
+        if (subtitle == null) subtitle = "";
+
+        String message = msg.getString("message");
+        if (message == null) message = "";
+        
+        String tickerText = msg.getString("tickerText");
+        if (tickerText == null) tickerText = title;
+
+        NotificationCompat.Builder mBuilder = 
+        		new NotificationCompat.Builder(this)
+			        .setSmallIcon(R.drawable.ic_wizard_callromania)
+			        .setContentTitle(title)
+//			        .setStyle(new NotificationCompat.BigTextStyle()
+//			        .bigText(message))
+//			        .setContentText(subtitle)
+			        .setContentText(message)
+			        .setAutoCancel(true)
+			        .setSound(RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION))
+			        .setTicker(tickerText);
+
+        mBuilder.setContentIntent(contentIntent);
+        mNotificationManager.notify(NOTIFICATION_ID++, mBuilder.build());
+    }
+}
Index: CSipSimple/src/ro/callromania/util/IabException.java
===================================================================
--- CSipSimple/src/ro/callromania/util/IabException.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/IabException.java	(working copy)
@@ -0,0 +1,43 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+/**
+ * Exception thrown when something went wrong with in-app billing.
+ * An IabException has an associated IabResult (an error).
+ * To get the IAB result that caused this exception to be thrown,
+ * call {@link #getResult()}.
+ */
+public class IabException extends Exception {
+    IabResult mResult;
+
+    public IabException(IabResult r) {
+        this(r, null);
+    }
+    public IabException(int response, String message) {
+        this(new IabResult(response, message));
+    }
+    public IabException(IabResult r, Exception cause) {
+        super(r.getMessage(), cause);
+        mResult = r;
+    }
+    public IabException(int response, String message, Exception cause) {
+        this(new IabResult(response, message), cause);
+    }
+
+    /** Returns the IAB result (error) that this exception signals. */
+    public IabResult getResult() { return mResult; }
+}
\ No newline at end of file
Index: CSipSimple/src/ro/callromania/util/IabHelper.java
===================================================================
--- CSipSimple/src/ro/callromania/util/IabHelper.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/IabHelper.java	(working copy)
@@ -0,0 +1,991 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import android.app.Activity;
+import android.app.PendingIntent;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentSender.SendIntentException;
+import android.content.ServiceConnection;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.android.vending.billing.IInAppBillingService;
+
+import org.json.JSONException;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * Provides convenience methods for in-app billing. You can create one instance of this
+ * class for your application and use it to process in-app billing operations.
+ * It provides synchronous (blocking) and asynchronous (non-blocking) methods for
+ * many common in-app billing operations, as well as automatic signature
+ * verification.
+ *
+ * After instantiating, you must perform setup in order to start using the object.
+ * To perform setup, call the {@link #startSetup} method and provide a listener;
+ * that listener will be notified when setup is complete, after which (and not before)
+ * you may call other methods.
+ *
+ * After setup is complete, you will typically want to request an inventory of owned
+ * items and subscriptions. See {@link #queryInventory}, {@link #queryInventoryAsync}
+ * and related methods.
+ *
+ * When you are done with this object, don't forget to call {@link #dispose}
+ * to ensure proper cleanup. This object holds a binding to the in-app billing
+ * service, which will leak unless you dispose of it correctly. If you created
+ * the object on an Activity's onCreate method, then the recommended
+ * place to dispose of it is the Activity's onDestroy method.
+ *
+ * A note about threading: When using this object from a background thread, you may
+ * call the blocking versions of methods; when using from a UI thread, call
+ * only the asynchronous versions and handle the results via callbacks.
+ * Also, notice that you can only call one asynchronous operation at a time;
+ * attempting to start a second asynchronous operation while the first one
+ * has not yet completed will result in an exception being thrown.
+ *
+ * @author Bruno Oliveira (Google)
+ *
+ */
+public class IabHelper {
+    // Is debug logging enabled?
+    boolean mDebugLog = false;
+    String mDebugTag = "IabHelper";
+
+    // Is setup done?
+    boolean mSetupDone = false;
+
+    // Has this object been disposed of? (If so, we should ignore callbacks, etc)
+    boolean mDisposed = false;
+
+    // Are subscriptions supported?
+    boolean mSubscriptionsSupported = false;
+
+    // Is an asynchronous operation in progress?
+    // (only one at a time can be in progress)
+    boolean mAsyncInProgress = false;
+
+    // (for logging/debugging)
+    // if mAsyncInProgress == true, what asynchronous operation is in progress?
+    String mAsyncOperation = "";
+
+    // Context we were passed during initialization
+    Context mContext;
+
+    // Connection to the service
+    IInAppBillingService mService;
+    ServiceConnection mServiceConn;
+
+    // The request code used to launch purchase flow
+    int mRequestCode;
+
+    // The item type of the current purchase flow
+    String mPurchasingItemType;
+
+    // Public key for verifying signature, in base64 encoding
+    String mSignatureBase64 = null;
+
+    // Billing response codes
+    public static final int BILLING_RESPONSE_RESULT_OK = 0;
+    public static final int BILLING_RESPONSE_RESULT_USER_CANCELED = 1;
+    public static final int BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE = 3;
+    public static final int BILLING_RESPONSE_RESULT_ITEM_UNAVAILABLE = 4;
+    public static final int BILLING_RESPONSE_RESULT_DEVELOPER_ERROR = 5;
+    public static final int BILLING_RESPONSE_RESULT_ERROR = 6;
+    public static final int BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED = 7;
+    public static final int BILLING_RESPONSE_RESULT_ITEM_NOT_OWNED = 8;
+
+    // IAB Helper error codes
+    public static final int IABHELPER_ERROR_BASE = -1000;
+    public static final int IABHELPER_REMOTE_EXCEPTION = -1001;
+    public static final int IABHELPER_BAD_RESPONSE = -1002;
+    public static final int IABHELPER_VERIFICATION_FAILED = -1003;
+    public static final int IABHELPER_SEND_INTENT_FAILED = -1004;
+    public static final int IABHELPER_USER_CANCELLED = -1005;
+    public static final int IABHELPER_UNKNOWN_PURCHASE_RESPONSE = -1006;
+    public static final int IABHELPER_MISSING_TOKEN = -1007;
+    public static final int IABHELPER_UNKNOWN_ERROR = -1008;
+    public static final int IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE = -1009;
+    public static final int IABHELPER_INVALID_CONSUMPTION = -1010;
+
+    // Keys for the responses from InAppBillingService
+    public static final String RESPONSE_CODE = "RESPONSE_CODE";
+    public static final String RESPONSE_GET_SKU_DETAILS_LIST = "DETAILS_LIST";
+    public static final String RESPONSE_BUY_INTENT = "BUY_INTENT";
+    public static final String RESPONSE_INAPP_PURCHASE_DATA = "INAPP_PURCHASE_DATA";
+    public static final String RESPONSE_INAPP_SIGNATURE = "INAPP_DATA_SIGNATURE";
+    public static final String RESPONSE_INAPP_ITEM_LIST = "INAPP_PURCHASE_ITEM_LIST";
+    public static final String RESPONSE_INAPP_PURCHASE_DATA_LIST = "INAPP_PURCHASE_DATA_LIST";
+    public static final String RESPONSE_INAPP_SIGNATURE_LIST = "INAPP_DATA_SIGNATURE_LIST";
+    public static final String INAPP_CONTINUATION_TOKEN = "INAPP_CONTINUATION_TOKEN";
+
+    // Item types
+    public static final String ITEM_TYPE_INAPP = "inapp";
+    public static final String ITEM_TYPE_SUBS = "subs";
+
+    // some fields on the getSkuDetails response bundle
+    public static final String GET_SKU_DETAILS_ITEM_LIST = "ITEM_ID_LIST";
+    public static final String GET_SKU_DETAILS_ITEM_TYPE_LIST = "ITEM_TYPE_LIST";
+
+    /**
+     * Creates an instance. After creation, it will not yet be ready to use. You must perform
+     * setup by calling {@link #startSetup} and wait for setup to complete. This constructor does not
+     * block and is safe to call from a UI thread.
+     *
+     * @param ctx Your application or Activity context. Needed to bind to the in-app billing service.
+     * @param base64PublicKey Your application's public key, encoded in base64.
+     *     This is used for verification of purchase signatures. You can find your app's base64-encoded
+     *     public key in your application's page on Google Play Developer Console. Note that this
+     *     is NOT your "developer public key".
+     */
+    public IabHelper(Context ctx, String base64PublicKey) {
+        mContext = ctx.getApplicationContext();
+        mSignatureBase64 = base64PublicKey;
+        logDebug("IAB helper created.");
+    }
+
+    /**
+     * Enables or disable debug logging through LogCat.
+     */
+    public void enableDebugLogging(boolean enable, String tag) {
+        checkNotDisposed();
+        mDebugLog = enable;
+        mDebugTag = tag;
+    }
+
+    public void enableDebugLogging(boolean enable) {
+        checkNotDisposed();
+        mDebugLog = enable;
+    }
+
+    /**
+     * Callback for setup process. This listener's {@link #onIabSetupFinished} method is called
+     * when the setup process is complete.
+     */
+    public interface OnIabSetupFinishedListener {
+        /**
+         * Called to notify that setup is complete.
+         *
+         * @param result The result of the setup process.
+         */
+        public void onIabSetupFinished(IabResult result);
+    }
+
+    /**
+     * Starts the setup process. This will start up the setup process asynchronously.
+     * You will be notified through the listener when the setup process is complete.
+     * This method is safe to call from a UI thread.
+     *
+     * @param listener The listener to notify when the setup process is complete.
+     */
+    public void startSetup(final OnIabSetupFinishedListener listener) {
+        // If already set up, can't do it again.
+        checkNotDisposed();
+        if (mSetupDone) throw new IllegalStateException("IAB helper is already set up.");
+
+        // Connection to IAB service
+        logDebug("Starting in-app billing setup.");
+        mServiceConn = new ServiceConnection() {
+            @Override
+            public void onServiceDisconnected(ComponentName name) {
+                logDebug("Billing service disconnected.");
+                mService = null;
+            }
+
+            @Override
+            public void onServiceConnected(ComponentName name, IBinder service) {
+                if (mDisposed) return;
+                logDebug("Billing service connected.");
+                mService = IInAppBillingService.Stub.asInterface(service);
+                String packageName = mContext.getPackageName();
+                try {
+                    logDebug("Checking for in-app billing 3 support.");
+
+                    // check for in-app billing v3 support
+                    int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);
+                    if (response != BILLING_RESPONSE_RESULT_OK) {
+                        if (listener != null) listener.onIabSetupFinished(new IabResult(response,
+                                "Error checking for billing v3 support."));
+
+                        // if in-app purchases aren't supported, neither are subscriptions.
+                        mSubscriptionsSupported = false;
+                        return;
+                    }
+                    logDebug("In-app billing version 3 supported for " + packageName);
+
+                    // check for v3 subscriptions support
+                    response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);
+                    if (response == BILLING_RESPONSE_RESULT_OK) {
+                        logDebug("Subscriptions AVAILABLE.");
+                        mSubscriptionsSupported = true;
+                    }
+                    else {
+                        logDebug("Subscriptions NOT AVAILABLE. Response: " + response);
+                    }
+
+                    mSetupDone = true;
+                }
+                catch (RemoteException e) {
+                    if (listener != null) {
+                        listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION,
+                                                    "RemoteException while setting up in-app billing."));
+                    }
+                    e.printStackTrace();
+                    return;
+                }
+
+                if (listener != null) {
+                    listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Setup successful."));
+                }
+            }
+        };
+
+        Intent serviceIntent = new Intent("com.android.vending.billing.InAppBillingService.BIND");
+        serviceIntent.setPackage("com.android.vending");
+        if (!mContext.getPackageManager().queryIntentServices(serviceIntent, 0).isEmpty()) {
+            // service available to handle that Intent
+            mContext.bindService(serviceIntent, mServiceConn, Context.BIND_AUTO_CREATE);
+        }
+        else {
+            // no service available to handle that Intent
+            if (listener != null) {
+                listener.onIabSetupFinished(
+                        new IabResult(BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE,
+                        "Billing service unavailable on device."));
+            }
+        }
+    }
+
+    /**
+     * Dispose of object, releasing resources. It's very important to call this
+     * method when you are done with this object. It will release any resources
+     * used by it such as service connections. Naturally, once the object is
+     * disposed of, it can't be used again.
+     */
+    public void dispose() {
+        logDebug("Disposing.");
+        mSetupDone = false;
+        if (mServiceConn != null) {
+            logDebug("Unbinding from service.");
+            if (mContext != null) mContext.unbindService(mServiceConn);
+        }
+        mDisposed = true;
+        mContext = null;
+        mServiceConn = null;
+        mService = null;
+        mPurchaseListener = null;
+    }
+
+    private void checkNotDisposed() {
+        if (mDisposed) throw new IllegalStateException("IabHelper was disposed of, so it cannot be used.");
+    }
+
+    /** Returns whether subscriptions are supported. */
+    public boolean subscriptionsSupported() {
+        checkNotDisposed();
+        return mSubscriptionsSupported;
+    }
+
+
+    /**
+     * Callback that notifies when a purchase is finished.
+     */
+    public interface OnIabPurchaseFinishedListener {
+        /**
+         * Called to notify that an in-app purchase finished. If the purchase was successful,
+         * then the sku parameter specifies which item was purchased. If the purchase failed,
+         * the sku and extraData parameters may or may not be null, depending on how far the purchase
+         * process went.
+         *
+         * @param result The result of the purchase.
+         * @param info The purchase information (null if purchase failed)
+         */
+        public void onIabPurchaseFinished(IabResult result, Purchase info);
+    }
+
+    // The listener registered on launchPurchaseFlow, which we have to call back when
+    // the purchase finishes
+    OnIabPurchaseFinishedListener mPurchaseListener;
+
+    public void launchPurchaseFlow(Activity act, String sku, int requestCode, OnIabPurchaseFinishedListener listener) {
+        launchPurchaseFlow(act, sku, requestCode, listener, "");
+    }
+
+    public void launchPurchaseFlow(Activity act, String sku, int requestCode,
+            OnIabPurchaseFinishedListener listener, String extraData) {
+        launchPurchaseFlow(act, sku, ITEM_TYPE_INAPP, requestCode, listener, extraData);
+    }
+
+    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
+            OnIabPurchaseFinishedListener listener) {
+        launchSubscriptionPurchaseFlow(act, sku, requestCode, listener, "");
+    }
+
+    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
+            OnIabPurchaseFinishedListener listener, String extraData) {
+        launchPurchaseFlow(act, sku, ITEM_TYPE_SUBS, requestCode, listener, extraData);
+    }
+
+    /**
+     * Initiate the UI flow for an in-app purchase. Call this method to initiate an in-app purchase,
+     * which will involve bringing up the Google Play screen. The calling activity will be paused while
+     * the user interacts with Google Play, and the result will be delivered via the activity's
+     * {@link android.app.Activity#onActivityResult} method, at which point you must call
+     * this object's {@link #handleActivityResult} method to continue the purchase flow. This method
+     * MUST be called from the UI thread of the Activity.
+     *
+     * @param act The calling activity.
+     * @param sku The sku of the item to purchase.
+     * @param itemType indicates if it's a product or a subscription (ITEM_TYPE_INAPP or ITEM_TYPE_SUBS)
+     * @param requestCode A request code (to differentiate from other responses --
+     *     as in {@link android.app.Activity#startActivityForResult}).
+     * @param listener The listener to notify when the purchase process finishes
+     * @param extraData Extra data (developer payload), which will be returned with the purchase data
+     *     when the purchase completes. This extra data will be permanently bound to that purchase
+     *     and will always be returned when the purchase is queried.
+     */
+    public void launchPurchaseFlow(Activity act, String sku, String itemType, int requestCode,
+                        OnIabPurchaseFinishedListener listener, String extraData) {
+        checkNotDisposed();
+        checkSetupDone("launchPurchaseFlow");
+        flagStartAsync("launchPurchaseFlow");
+        IabResult result;
+
+        if (itemType.equals(ITEM_TYPE_SUBS) && !mSubscriptionsSupported) {
+            IabResult r = new IabResult(IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE,
+                    "Subscriptions are not available.");
+            flagEndAsync();
+            if (listener != null) listener.onIabPurchaseFinished(r, null);
+            return;
+        }
+
+        try {
+            logDebug("Constructing buy intent for " + sku + ", item type: " + itemType);
+            Bundle buyIntentBundle = mService.getBuyIntent(3, mContext.getPackageName(), sku, itemType, extraData);
+            int response = getResponseCodeFromBundle(buyIntentBundle);
+            if (response != BILLING_RESPONSE_RESULT_OK) {
+                logError("Unable to buy item, Error response: " + getResponseDesc(response));
+                flagEndAsync();
+                result = new IabResult(response, "Unable to buy item");
+                if (listener != null) listener.onIabPurchaseFinished(result, null);
+                return;
+            }
+
+            PendingIntent pendingIntent = buyIntentBundle.getParcelable(RESPONSE_BUY_INTENT);
+            logDebug("Launching buy intent for " + sku + ". Request code: " + requestCode);
+            mRequestCode = requestCode;
+            mPurchaseListener = listener;
+            mPurchasingItemType = itemType;
+            act.startIntentSenderForResult(pendingIntent.getIntentSender(),
+                                           requestCode, new Intent(),
+                                           Integer.valueOf(0), Integer.valueOf(0),
+                                           Integer.valueOf(0));
+        }
+        catch (SendIntentException e) {
+            logError("SendIntentException while launching purchase flow for sku " + sku);
+            e.printStackTrace();
+            flagEndAsync();
+
+            result = new IabResult(IABHELPER_SEND_INTENT_FAILED, "Failed to send intent.");
+            if (listener != null) listener.onIabPurchaseFinished(result, null);
+        }
+        catch (RemoteException e) {
+            logError("RemoteException while launching purchase flow for sku " + sku);
+            e.printStackTrace();
+            flagEndAsync();
+
+            result = new IabResult(IABHELPER_REMOTE_EXCEPTION, "Remote exception while starting purchase flow");
+            if (listener != null) listener.onIabPurchaseFinished(result, null);
+        }
+    }
+
+    /**
+     * Handles an activity result that's part of the purchase flow in in-app billing. If you
+     * are calling {@link #launchPurchaseFlow}, then you must call this method from your
+     * Activity's {@link android.app.Activity@onActivityResult} method. This method
+     * MUST be called from the UI thread of the Activity.
+     *
+     * @param requestCode The requestCode as you received it.
+     * @param resultCode The resultCode as you received it.
+     * @param data The data (Intent) as you received it.
+     * @return Returns true if the result was related to a purchase flow and was handled;
+     *     false if the result was not related to a purchase, in which case you should
+     *     handle it normally.
+     */
+    public boolean handleActivityResult(int requestCode, int resultCode, Intent data) {
+        IabResult result;
+        if (requestCode != mRequestCode) return false;
+
+        checkNotDisposed();
+        checkSetupDone("handleActivityResult");
+
+        // end of async purchase operation that started on launchPurchaseFlow
+        flagEndAsync();
+
+        if (data == null) {
+            logError("Null data in IAB activity result.");
+            result = new IabResult(IABHELPER_BAD_RESPONSE, "Null data in IAB result");
+            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+            return true;
+        }
+
+        int responseCode = getResponseCodeFromIntent(data);
+        String purchaseData = data.getStringExtra(RESPONSE_INAPP_PURCHASE_DATA);
+        String dataSignature = data.getStringExtra(RESPONSE_INAPP_SIGNATURE);
+
+        if (resultCode == Activity.RESULT_OK && responseCode == BILLING_RESPONSE_RESULT_OK) {
+            logDebug("Successful resultcode from purchase activity.");
+            logDebug("Purchase data: " + purchaseData);
+            logDebug("Data signature: " + dataSignature);
+            logDebug("Extras: " + data.getExtras());
+            logDebug("Expected item type: " + mPurchasingItemType);
+
+            if (purchaseData == null || dataSignature == null) {
+                logError("BUG: either purchaseData or dataSignature is null.");
+                logDebug("Extras: " + data.getExtras().toString());
+                result = new IabResult(IABHELPER_UNKNOWN_ERROR, "IAB returned null purchaseData or dataSignature");
+                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+                return true;
+            }
+
+            Purchase purchase = null;
+            try {
+                purchase = new Purchase(mPurchasingItemType, purchaseData, dataSignature);
+                String sku = purchase.getSku();
+
+                // Verify signature
+                if (!Security.verifyPurchase(mSignatureBase64, purchaseData, dataSignature)) {
+                    logError("Purchase signature verification FAILED for sku " + sku);
+                    result = new IabResult(IABHELPER_VERIFICATION_FAILED, "Signature verification failed for sku " + sku);
+                    if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, purchase);
+                    return true;
+                }
+                logDebug("Purchase signature successfully verified.");
+            }
+            catch (JSONException e) {
+                logError("Failed to parse purchase data.");
+                e.printStackTrace();
+                result = new IabResult(IABHELPER_BAD_RESPONSE, "Failed to parse purchase data.");
+                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+                return true;
+            }
+
+            if (mPurchaseListener != null) {
+                mPurchaseListener.onIabPurchaseFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Success"), purchase);
+            }
+        }
+        else if (resultCode == Activity.RESULT_OK) {
+            // result code was OK, but in-app billing response was not OK.
+            logDebug("Result code was OK but in-app billing response was not OK: " + getResponseDesc(responseCode));
+            if (mPurchaseListener != null) {
+                result = new IabResult(responseCode, "Problem purchashing item.");
+                mPurchaseListener.onIabPurchaseFinished(result, null);
+            }
+        }
+        else if (resultCode == Activity.RESULT_CANCELED) {
+            logDebug("Purchase canceled - Response: " + getResponseDesc(responseCode));
+            result = new IabResult(IABHELPER_USER_CANCELLED, "User canceled.");
+            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+        }
+        else {
+            logError("Purchase failed. Result code: " + Integer.toString(resultCode)
+                    + ". Response: " + getResponseDesc(responseCode));
+            result = new IabResult(IABHELPER_UNKNOWN_PURCHASE_RESPONSE, "Unknown purchase response.");
+            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+        }
+        return true;
+    }
+
+    public Inventory queryInventory(boolean querySkuDetails, List<String> moreSkus) throws IabException {
+        return queryInventory(querySkuDetails, moreSkus, null);
+    }
+
+    /**
+     * Queries the inventory. This will query all owned items from the server, as well as
+     * information on additional skus, if specified. This method may block or take long to execute.
+     * Do not call from a UI thread. For that, use the non-blocking version {@link #refreshInventoryAsync}.
+     *
+     * @param querySkuDetails if true, SKU details (price, description, etc) will be queried as well
+     *     as purchase information.
+     * @param moreItemSkus additional PRODUCT skus to query information on, regardless of ownership.
+     *     Ignored if null or if querySkuDetails is false.
+     * @param moreSubsSkus additional SUBSCRIPTIONS skus to query information on, regardless of ownership.
+     *     Ignored if null or if querySkuDetails is false.
+     * @throws IabException if a problem occurs while refreshing the inventory.
+     */
+    public Inventory queryInventory(boolean querySkuDetails, List<String> moreItemSkus,
+                                        List<String> moreSubsSkus) throws IabException {
+        checkNotDisposed();
+        checkSetupDone("queryInventory");
+        try {
+            Inventory inv = new Inventory();
+            int r = queryPurchases(inv, ITEM_TYPE_INAPP);
+            if (r != BILLING_RESPONSE_RESULT_OK) {
+                throw new IabException(r, "Error refreshing inventory (querying owned items).");
+            }
+
+            if (querySkuDetails) {
+                r = querySkuDetails(ITEM_TYPE_INAPP, inv, moreItemSkus);
+                if (r != BILLING_RESPONSE_RESULT_OK) {
+                    throw new IabException(r, "Error refreshing inventory (querying prices of items).");
+                }
+            }
+
+            // if subscriptions are supported, then also query for subscriptions
+            if (mSubscriptionsSupported) {
+                r = queryPurchases(inv, ITEM_TYPE_SUBS);
+                if (r != BILLING_RESPONSE_RESULT_OK) {
+                    throw new IabException(r, "Error refreshing inventory (querying owned subscriptions).");
+                }
+
+                if (querySkuDetails) {
+                    r = querySkuDetails(ITEM_TYPE_SUBS, inv, moreItemSkus);
+                    if (r != BILLING_RESPONSE_RESULT_OK) {
+                        throw new IabException(r, "Error refreshing inventory (querying prices of subscriptions).");
+                    }
+                }
+            }
+
+            return inv;
+        }
+        catch (RemoteException e) {
+            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while refreshing inventory.", e);
+        }
+        catch (JSONException e) {
+            throw new IabException(IABHELPER_BAD_RESPONSE, "Error parsing JSON response while refreshing inventory.", e);
+        }
+    }
+
+    /**
+     * Listener that notifies when an inventory query operation completes.
+     */
+    public interface QueryInventoryFinishedListener {
+        /**
+         * Called to notify that an inventory query operation completed.
+         *
+         * @param result The result of the operation.
+         * @param inv The inventory.
+         */
+        public void onQueryInventoryFinished(IabResult result, Inventory inv);
+    }
+
+
+    /**
+     * Asynchronous wrapper for inventory query. This will perform an inventory
+     * query as described in {@link #queryInventory}, but will do so asynchronously
+     * and call back the specified listener upon completion. This method is safe to
+     * call from a UI thread.
+     *
+     * @param querySkuDetails as in {@link #queryInventory}
+     * @param moreSkus as in {@link #queryInventory}
+     * @param listener The listener to notify when the refresh operation completes.
+     */
+    public void queryInventoryAsync(final boolean querySkuDetails,
+                               final List<String> moreSkus,
+                               final QueryInventoryFinishedListener listener) {
+        final Handler handler = new Handler();
+        checkNotDisposed();
+        checkSetupDone("queryInventory");
+        flagStartAsync("refresh inventory");
+        (new Thread(new Runnable() {
+            public void run() {
+                IabResult result = new IabResult(BILLING_RESPONSE_RESULT_OK, "Inventory refresh successful.");
+                Inventory inv = null;
+                try {
+                    inv = queryInventory(querySkuDetails, moreSkus);
+                }
+                catch (IabException ex) {
+                    result = ex.getResult();
+                }
+
+                flagEndAsync();
+
+                final IabResult result_f = result;
+                final Inventory inv_f = inv;
+                if (!mDisposed && listener != null) {
+                    handler.post(new Runnable() {
+                        public void run() {
+                            listener.onQueryInventoryFinished(result_f, inv_f);
+                        }
+                    });
+                }
+            }
+        })).start();
+    }
+
+    public void queryInventoryAsync(QueryInventoryFinishedListener listener) {
+        queryInventoryAsync(true, null, listener);
+    }
+
+    public void queryInventoryAsync(boolean querySkuDetails, QueryInventoryFinishedListener listener) {
+        queryInventoryAsync(querySkuDetails, null, listener);
+    }
+
+
+    /**
+     * Consumes a given in-app product. Consuming can only be done on an item
+     * that's owned, and as a result of consumption, the user will no longer own it.
+     * This method may block or take long to return. Do not call from the UI thread.
+     * For that, see {@link #consumeAsync}.
+     *
+     * @param itemInfo The PurchaseInfo that represents the item to consume.
+     * @throws IabException if there is a problem during consumption.
+     */
+    void consume(Purchase itemInfo) throws IabException {
+        checkNotDisposed();
+        checkSetupDone("consume");
+
+        if (!itemInfo.mItemType.equals(ITEM_TYPE_INAPP)) {
+            throw new IabException(IABHELPER_INVALID_CONSUMPTION,
+                    "Items of type '" + itemInfo.mItemType + "' can't be consumed.");
+        }
+
+        try {
+            String token = itemInfo.getToken();
+            String sku = itemInfo.getSku();
+            if (token == null || token.equals("")) {
+               logError("Can't consume "+ sku + ". No token.");
+               throw new IabException(IABHELPER_MISSING_TOKEN, "PurchaseInfo is missing token for sku: "
+                   + sku + " " + itemInfo);
+            }
+
+            logDebug("Consuming sku: " + sku + ", token: " + token);
+            int response = mService.consumePurchase(3, mContext.getPackageName(), token);
+            if (response == BILLING_RESPONSE_RESULT_OK) {
+               logDebug("Successfully consumed sku: " + sku);
+            }
+            else {
+               logDebug("Error consuming consuming sku " + sku + ". " + getResponseDesc(response));
+               throw new IabException(response, "Error consuming sku " + sku);
+            }
+        }
+        catch (RemoteException e) {
+            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while consuming. PurchaseInfo: " + itemInfo, e);
+        }
+    }
+
+    /**
+     * Callback that notifies when a consumption operation finishes.
+     */
+    public interface OnConsumeFinishedListener {
+        /**
+         * Called to notify that a consumption has finished.
+         *
+         * @param purchase The purchase that was (or was to be) consumed.
+         * @param result The result of the consumption operation.
+         */
+        public void onConsumeFinished(Purchase purchase, IabResult result);
+    }
+
+    /**
+     * Callback that notifies when a multi-item consumption operation finishes.
+     */
+    public interface OnConsumeMultiFinishedListener {
+        /**
+         * Called to notify that a consumption of multiple items has finished.
+         *
+         * @param purchases The purchases that were (or were to be) consumed.
+         * @param results The results of each consumption operation, corresponding to each
+         *     sku.
+         */
+        public void onConsumeMultiFinished(List<Purchase> purchases, List<IabResult> results);
+    }
+
+    /**
+     * Asynchronous wrapper to item consumption. Works like {@link #consume}, but
+     * performs the consumption in the background and notifies completion through
+     * the provided listener. This method is safe to call from a UI thread.
+     *
+     * @param purchase The purchase to be consumed.
+     * @param listener The listener to notify when the consumption operation finishes.
+     */
+    public void consumeAsync(Purchase purchase, OnConsumeFinishedListener listener) {
+        checkNotDisposed();
+        checkSetupDone("consume");
+        List<Purchase> purchases = new ArrayList<Purchase>();
+        purchases.add(purchase);
+        consumeAsyncInternal(purchases, listener, null);
+    }
+
+    /**
+     * Same as {@link consumeAsync}, but for multiple items at once.
+     * @param purchases The list of PurchaseInfo objects representing the purchases to consume.
+     * @param listener The listener to notify when the consumption operation finishes.
+     */
+    public void consumeAsync(List<Purchase> purchases, OnConsumeMultiFinishedListener listener) {
+        checkNotDisposed();
+        checkSetupDone("consume");
+        consumeAsyncInternal(purchases, null, listener);
+    }
+
+    /**
+     * Returns a human-readable description for the given response code.
+     *
+     * @param code The response code
+     * @return A human-readable string explaining the result code.
+     *     It also includes the result code numerically.
+     */
+    public static String getResponseDesc(int code) {
+        String[] iab_msgs = ("0:OK/1:User Canceled/2:Unknown/" +
+                "3:Billing Unavailable/4:Item unavailable/" +
+                "5:Developer Error/6:Error/7:Item Already Owned/" +
+                "8:Item not owned").split("/");
+        String[] iabhelper_msgs = ("0:OK/-1001:Remote exception during initialization/" +
+                                   "-1002:Bad response received/" +
+                                   "-1003:Purchase signature verification failed/" +
+                                   "-1004:Send intent failed/" +
+                                   "-1005:User cancelled/" +
+                                   "-1006:Unknown purchase response/" +
+                                   "-1007:Missing token/" +
+                                   "-1008:Unknown error/" +
+                                   "-1009:Subscriptions not available/" +
+                                   "-1010:Invalid consumption attempt").split("/");
+
+        if (code <= IABHELPER_ERROR_BASE) {
+            int index = IABHELPER_ERROR_BASE - code;
+            if (index >= 0 && index < iabhelper_msgs.length) return iabhelper_msgs[index];
+            else return String.valueOf(code) + ":Unknown IAB Helper Error";
+        }
+        else if (code < 0 || code >= iab_msgs.length)
+            return String.valueOf(code) + ":Unknown";
+        else
+            return iab_msgs[code];
+    }
+
+
+    // Checks that setup was done; if not, throws an exception.
+    void checkSetupDone(String operation) {
+        if (!mSetupDone) {
+            logError("Illegal state for operation (" + operation + "): IAB helper is not set up.");
+            throw new IllegalStateException("IAB helper is not set up. Can't perform operation: " + operation);
+        }
+    }
+
+    // Workaround to bug where sometimes response codes come as Long instead of Integer
+    int getResponseCodeFromBundle(Bundle b) {
+        Object o = b.get(RESPONSE_CODE);
+        if (o == null) {
+            logDebug("Bundle with null response code, assuming OK (known issue)");
+            return BILLING_RESPONSE_RESULT_OK;
+        }
+        else if (o instanceof Integer) return ((Integer)o).intValue();
+        else if (o instanceof Long) return (int)((Long)o).longValue();
+        else {
+            logError("Unexpected type for bundle response code.");
+            logError(o.getClass().getName());
+            throw new RuntimeException("Unexpected type for bundle response code: " + o.getClass().getName());
+        }
+    }
+
+    // Workaround to bug where sometimes response codes come as Long instead of Integer
+    int getResponseCodeFromIntent(Intent i) {
+        Object o = i.getExtras().get(RESPONSE_CODE);
+        if (o == null) {
+            logError("Intent with no response code, assuming OK (known issue)");
+            return BILLING_RESPONSE_RESULT_OK;
+        }
+        else if (o instanceof Integer) return ((Integer)o).intValue();
+        else if (o instanceof Long) return (int)((Long)o).longValue();
+        else {
+            logError("Unexpected type for intent response code.");
+            logError(o.getClass().getName());
+            throw new RuntimeException("Unexpected type for intent response code: " + o.getClass().getName());
+        }
+    }
+
+    void flagStartAsync(String operation) {
+        if (mAsyncInProgress) throw new IllegalStateException("Can't start async operation (" +
+                operation + ") because another async operation(" + mAsyncOperation + ") is in progress.");
+        mAsyncOperation = operation;
+        mAsyncInProgress = true;
+        logDebug("Starting async operation: " + operation);
+    }
+
+    void flagEndAsync() {
+        logDebug("Ending async operation: " + mAsyncOperation);
+        mAsyncOperation = "";
+        mAsyncInProgress = false;
+    }
+
+
+    int queryPurchases(Inventory inv, String itemType) throws JSONException, RemoteException {
+        // Query purchases
+        logDebug("Querying owned items, item type: " + itemType);
+        logDebug("Package name: " + mContext.getPackageName());
+        boolean verificationFailed = false;
+        String continueToken = null;
+
+        do {
+            logDebug("Calling getPurchases with continuation token: " + continueToken);
+            Bundle ownedItems = mService.getPurchases(3, mContext.getPackageName(),
+                    itemType, continueToken);
+
+            int response = getResponseCodeFromBundle(ownedItems);
+            logDebug("Owned items response: " + String.valueOf(response));
+            if (response != BILLING_RESPONSE_RESULT_OK) {
+                logDebug("getPurchases() failed: " + getResponseDesc(response));
+                return response;
+            }
+            if (!ownedItems.containsKey(RESPONSE_INAPP_ITEM_LIST)
+                    || !ownedItems.containsKey(RESPONSE_INAPP_PURCHASE_DATA_LIST)
+                    || !ownedItems.containsKey(RESPONSE_INAPP_SIGNATURE_LIST)) {
+                logError("Bundle returned from getPurchases() doesn't contain required fields.");
+                return IABHELPER_BAD_RESPONSE;
+            }
+
+            ArrayList<String> ownedSkus = ownedItems.getStringArrayList(
+                        RESPONSE_INAPP_ITEM_LIST);
+            ArrayList<String> purchaseDataList = ownedItems.getStringArrayList(
+                        RESPONSE_INAPP_PURCHASE_DATA_LIST);
+            ArrayList<String> signatureList = ownedItems.getStringArrayList(
+                        RESPONSE_INAPP_SIGNATURE_LIST);
+
+            for (int i = 0; i < purchaseDataList.size(); ++i) {
+                String purchaseData = purchaseDataList.get(i);
+                String signature = signatureList.get(i);
+                String sku = ownedSkus.get(i);
+                if (Security.verifyPurchase(mSignatureBase64, purchaseData, signature)) {
+                    logDebug("Sku is owned: " + sku);
+                    Purchase purchase = new Purchase(itemType, purchaseData, signature);
+
+                    if (TextUtils.isEmpty(purchase.getToken())) {
+                        logWarn("BUG: empty/null token!");
+                        logDebug("Purchase data: " + purchaseData);
+                    }
+
+                    // Record ownership and token
+                    inv.addPurchase(purchase);
+                }
+                else {
+                    logWarn("Purchase signature verification **FAILED**. Not adding item.");
+                    logDebug("   Purchase data: " + purchaseData);
+                    logDebug("   Signature: " + signature);
+                    verificationFailed = true;
+                }
+            }
+
+            continueToken = ownedItems.getString(INAPP_CONTINUATION_TOKEN);
+            logDebug("Continuation token: " + continueToken);
+        } while (!TextUtils.isEmpty(continueToken));
+
+        return verificationFailed ? IABHELPER_VERIFICATION_FAILED : BILLING_RESPONSE_RESULT_OK;
+    }
+
+    int querySkuDetails(String itemType, Inventory inv, List<String> moreSkus)
+                                throws RemoteException, JSONException {
+        logDebug("Querying SKU details.");
+        ArrayList<String> skuList = new ArrayList<String>();
+        skuList.addAll(inv.getAllOwnedSkus(itemType));
+        if (moreSkus != null) {
+            for (String sku : moreSkus) {
+                if (!skuList.contains(sku)) {
+                    skuList.add(sku);
+                }
+            }
+        }
+
+        if (skuList.size() == 0) {
+            logDebug("queryPrices: nothing to do because there are no SKUs.");
+            return BILLING_RESPONSE_RESULT_OK;
+        }
+
+        Bundle querySkus = new Bundle();
+        querySkus.putStringArrayList(GET_SKU_DETAILS_ITEM_LIST, skuList);
+        Bundle skuDetails = mService.getSkuDetails(3, mContext.getPackageName(),
+                itemType, querySkus);
+
+        if (!skuDetails.containsKey(RESPONSE_GET_SKU_DETAILS_LIST)) {
+            int response = getResponseCodeFromBundle(skuDetails);
+            if (response != BILLING_RESPONSE_RESULT_OK) {
+                logDebug("getSkuDetails() failed: " + getResponseDesc(response));
+                return response;
+            }
+            else {
+                logError("getSkuDetails() returned a bundle with neither an error nor a detail list.");
+                return IABHELPER_BAD_RESPONSE;
+            }
+        }
+
+        ArrayList<String> responseList = skuDetails.getStringArrayList(
+                RESPONSE_GET_SKU_DETAILS_LIST);
+
+        for (String thisResponse : responseList) {
+            SkuDetails d = new SkuDetails(itemType, thisResponse);
+            logDebug("Got sku details: " + d);
+            inv.addSkuDetails(d);
+        }
+        return BILLING_RESPONSE_RESULT_OK;
+    }
+
+
+    void consumeAsyncInternal(final List<Purchase> purchases,
+                              final OnConsumeFinishedListener singleListener,
+                              final OnConsumeMultiFinishedListener multiListener) {
+        final Handler handler = new Handler();
+        flagStartAsync("consume");
+        (new Thread(new Runnable() {
+            public void run() {
+                final List<IabResult> results = new ArrayList<IabResult>();
+                for (Purchase purchase : purchases) {
+                    try {
+                        consume(purchase);
+                        results.add(new IabResult(BILLING_RESPONSE_RESULT_OK, "Successful consume of sku " + purchase.getSku()));
+                    }
+                    catch (IabException ex) {
+                        results.add(ex.getResult());
+                    }
+                }
+
+                flagEndAsync();
+                if (!mDisposed && singleListener != null) {
+                    handler.post(new Runnable() {
+                        public void run() {
+                            singleListener.onConsumeFinished(purchases.get(0), results.get(0));
+                        }
+                    });
+                }
+                if (!mDisposed && multiListener != null) {
+                    handler.post(new Runnable() {
+                        public void run() {
+                            multiListener.onConsumeMultiFinished(purchases, results);
+                        }
+                    });
+                }
+            }
+        })).start();
+    }
+
+    void logDebug(String msg) {
+        if (mDebugLog) Log.d(mDebugTag, msg);
+    }
+
+    void logError(String msg) {
+        Log.e(mDebugTag, "In-app billing error: " + msg);
+    }
+
+    void logWarn(String msg) {
+        Log.w(mDebugTag, "In-app billing warning: " + msg);
+    }
+}
Index: CSipSimple/src/ro/callromania/util/IabResult.java
===================================================================
--- CSipSimple/src/ro/callromania/util/IabResult.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/IabResult.java	(working copy)
@@ -0,0 +1,45 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+/**
+ * Represents the result of an in-app billing operation.
+ * A result is composed of a response code (an integer) and possibly a
+ * message (String). You can get those by calling
+ * {@link #getResponse} and {@link #getMessage()}, respectively. You
+ * can also inquire whether a result is a success or a failure by
+ * calling {@link #isSuccess()} and {@link #isFailure()}.
+ */
+public class IabResult {
+    int mResponse;
+    String mMessage;
+
+    public IabResult(int response, String message) {
+        mResponse = response;
+        if (message == null || message.trim().length() == 0) {
+            mMessage = IabHelper.getResponseDesc(response);
+        }
+        else {
+            mMessage = message + " (response: " + IabHelper.getResponseDesc(response) + ")";
+        }
+    }
+    public int getResponse() { return mResponse; }
+    public String getMessage() { return mMessage; }
+    public boolean isSuccess() { return ((mResponse == IabHelper.BILLING_RESPONSE_RESULT_OK) || (mResponse == IabHelper.BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED)); }
+    public boolean isFailure() { return !isSuccess(); }
+    public String toString() { return "IabResult: " + getMessage(); }
+}
+
Index: CSipSimple/src/ro/callromania/util/Inventory.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Inventory.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Inventory.java	(working copy)
@@ -0,0 +1,91 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Represents a block of information about in-app items.
+ * An Inventory is returned by such methods as {@link IabHelper#queryInventory}.
+ */
+public class Inventory {
+    Map<String,SkuDetails> mSkuMap = new HashMap<String,SkuDetails>();
+    Map<String,Purchase> mPurchaseMap = new HashMap<String,Purchase>();
+
+    Inventory() { }
+
+    /** Returns the listing details for an in-app product. */
+    public SkuDetails getSkuDetails(String sku) {
+        return mSkuMap.get(sku);
+    }
+
+    /** Returns purchase information for a given product, or null if there is no purchase. */
+    public Purchase getPurchase(String sku) {
+        return mPurchaseMap.get(sku);
+    }
+
+    /** Returns whether or not there exists a purchase of the given product. */
+    public boolean hasPurchase(String sku) {
+        return mPurchaseMap.containsKey(sku);
+    }
+
+    /** Return whether or not details about the given product are available. */
+    public boolean hasDetails(String sku) {
+        return mSkuMap.containsKey(sku);
+    }
+
+    /**
+     * Erase a purchase (locally) from the inventory, given its product ID. This just
+     * modifies the Inventory object locally and has no effect on the server! This is
+     * useful when you have an existing Inventory object which you know to be up to date,
+     * and you have just consumed an item successfully, which means that erasing its
+     * purchase data from the Inventory you already have is quicker than querying for
+     * a new Inventory.
+     */
+    public void erasePurchase(String sku) {
+        if (mPurchaseMap.containsKey(sku)) mPurchaseMap.remove(sku);
+    }
+
+    /** Returns a list of all owned product IDs. */
+    List<String> getAllOwnedSkus() {
+        return new ArrayList<String>(mPurchaseMap.keySet());
+    }
+
+    /** Returns a list of all owned product IDs of a given type */
+    List<String> getAllOwnedSkus(String itemType) {
+        List<String> result = new ArrayList<String>();
+        for (Purchase p : mPurchaseMap.values()) {
+            if (p.getItemType().equals(itemType)) result.add(p.getSku());
+        }
+        return result;
+    }
+
+    /** Returns a list of all purchases. */
+    List<Purchase> getAllPurchases() {
+        return new ArrayList<Purchase>(mPurchaseMap.values());
+    }
+
+    void addSkuDetails(SkuDetails d) {
+        mSkuMap.put(d.getSku(), d);
+    }
+
+    void addPurchase(Purchase p) {
+        mPurchaseMap.put(p.getSku(), p);
+    }
+}
Index: CSipSimple/src/ro/callromania/util/Purchase.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Purchase.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Purchase.java	(working copy)
@@ -0,0 +1,63 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Represents an in-app billing purchase.
+ */
+public class Purchase {
+    String mItemType;  // ITEM_TYPE_INAPP or ITEM_TYPE_SUBS
+    String mOrderId;
+    String mPackageName;
+    String mSku;
+    long mPurchaseTime;
+    int mPurchaseState;
+    String mDeveloperPayload;
+    String mToken;
+    String mOriginalJson;
+    String mSignature;
+
+    public Purchase(String itemType, String jsonPurchaseInfo, String signature) throws JSONException {
+        mItemType = itemType;
+        mOriginalJson = jsonPurchaseInfo;
+        JSONObject o = new JSONObject(mOriginalJson);
+        mOrderId = o.optString("orderId");
+        mPackageName = o.optString("packageName");
+        mSku = o.optString("productId");
+        mPurchaseTime = o.optLong("purchaseTime");
+        mPurchaseState = o.optInt("purchaseState");
+        mDeveloperPayload = o.optString("developerPayload");
+        mToken = o.optString("token", o.optString("purchaseToken"));
+        mSignature = signature;
+    }
+
+    public String getItemType() { return mItemType; }
+    public String getOrderId() { return mOrderId; }
+    public String getPackageName() { return mPackageName; }
+    public String getSku() { return mSku; }
+    public long getPurchaseTime() { return mPurchaseTime; }
+    public int getPurchaseState() { return mPurchaseState; }
+    public String getDeveloperPayload() { return mDeveloperPayload; }
+    public String getToken() { return mToken; }
+    public String getOriginalJson() { return mOriginalJson; }
+    public String getSignature() { return mSignature; }
+
+    @Override
+    public String toString() { return "PurchaseInfo(type:" + mItemType + "):" + mOriginalJson; }
+}
Index: CSipSimple/src/ro/callromania/util/Security.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Security.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Security.java	(working copy)
@@ -0,0 +1,123 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import android.text.TextUtils;
+import android.util.Log;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+
+import java.security.InvalidKeyException;
+import java.security.KeyFactory;
+import java.security.NoSuchAlgorithmException;
+import java.security.PublicKey;
+import java.security.Signature;
+import java.security.SignatureException;
+import java.security.spec.InvalidKeySpecException;
+import java.security.spec.X509EncodedKeySpec;
+
+/**
+ * Security-related methods. For a secure implementation, all of this code
+ * should be implemented on a server that communicates with the
+ * application on the device. For the sake of simplicity and clarity of this
+ * example, this code is included here and is executed on the device. If you
+ * must verify the purchases on the phone, you should obfuscate this code to
+ * make it harder for an attacker to replace the code with stubs that treat all
+ * purchases as verified.
+ */
+public class Security {
+    private static final String TAG = "IABUtil/Security";
+
+    private static final String KEY_FACTORY_ALGORITHM = "RSA";
+    private static final String SIGNATURE_ALGORITHM = "SHA1withRSA";
+
+    /**
+     * Verifies that the data was signed with the given signature, and returns
+     * the verified purchase. The data is in JSON format and signed
+     * with a private key. The data also contains the {@link PurchaseState}
+     * and product ID of the purchase.
+     * @param base64PublicKey the base64-encoded public key to use for verifying.
+     * @param signedData the signed JSON string (signed, not encrypted)
+     * @param signature the signature for the data, signed with the private key
+     */
+    public static boolean verifyPurchase(String base64PublicKey, String signedData, String signature) {
+        if (TextUtils.isEmpty(signedData) || TextUtils.isEmpty(base64PublicKey) ||
+                TextUtils.isEmpty(signature)) {
+            Log.e(TAG, "Purchase verification failed: missing data.");
+            return false;
+        }
+
+        PublicKey key = Security.generatePublicKey(base64PublicKey);
+        return Security.verify(key, signedData, signature);
+    }
+
+    /**
+     * Generates a PublicKey instance from a string containing the
+     * Base64-encoded public key.
+     *
+     * @param encodedPublicKey Base64-encoded public key
+     * @throws IllegalArgumentException if encodedPublicKey is invalid
+     */
+    public static PublicKey generatePublicKey(String encodedPublicKey) {
+        try {
+            byte[] decodedKey = Base64.decode(encodedPublicKey);
+            KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);
+            return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey));
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+        } catch (InvalidKeySpecException e) {
+            Log.e(TAG, "Invalid key specification.");
+            throw new IllegalArgumentException(e);
+        } catch (Base64DecoderException e) {
+            Log.e(TAG, "Base64 decoding failed.");
+            throw new IllegalArgumentException(e);
+        }
+    }
+
+    /**
+     * Verifies that the signature from the server matches the computed
+     * signature on the data.  Returns true if the data is correctly signed.
+     *
+     * @param publicKey public key associated with the developer account
+     * @param signedData signed data from server
+     * @param signature server signature
+     * @return true if the data and signature match
+     */
+    public static boolean verify(PublicKey publicKey, String signedData, String signature) {
+        Signature sig;
+        try {
+            sig = Signature.getInstance(SIGNATURE_ALGORITHM);
+            sig.initVerify(publicKey);
+            sig.update(signedData.getBytes());
+            if (!sig.verify(Base64.decode(signature))) {
+                Log.e(TAG, "Signature verification failed.");
+                return false;
+            }
+            return true;
+        } catch (NoSuchAlgorithmException e) {
+            Log.e(TAG, "NoSuchAlgorithmException.");
+        } catch (InvalidKeyException e) {
+            Log.e(TAG, "Invalid key specification.");
+        } catch (SignatureException e) {
+            Log.e(TAG, "Signature exception.");
+        } catch (Base64DecoderException e) {
+            Log.e(TAG, "Base64 decoding failed.");
+        }
+        return false;
+    }
+}
Index: CSipSimple/src/ro/callromania/util/SkuDetails.java
===================================================================
--- CSipSimple/src/ro/callromania/util/SkuDetails.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/SkuDetails.java	(working copy)
@@ -0,0 +1,58 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Represents an in-app product's listing details.
+ */
+public class SkuDetails {
+    String mItemType;
+    String mSku;
+    String mType;
+    String mPrice;
+    String mTitle;
+    String mDescription;
+    String mJson;
+
+    public SkuDetails(String jsonSkuDetails) throws JSONException {
+        this(IabHelper.ITEM_TYPE_INAPP, jsonSkuDetails);
+    }
+
+    public SkuDetails(String itemType, String jsonSkuDetails) throws JSONException {
+        mItemType = itemType;
+        mJson = jsonSkuDetails;
+        JSONObject o = new JSONObject(mJson);
+        mSku = o.optString("productId");
+        mType = o.optString("type");
+        mPrice = o.optString("price");
+        mTitle = o.optString("title");
+        mDescription = o.optString("description");
+    }
+
+    public String getSku() { return mSku; }
+    public String getType() { return mType; }
+    public String getPrice() { return mPrice; }
+    public String getTitle() { return mTitle; }
+    public String getDescription() { return mDescription; }
+
+    @Override
+    public String toString() {
+        return "SkuDetails:" + mJson;
+    }
+}
Index: CSipSimple/src/ro/callromania/util/Base64.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Base64.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Base64.java	(working copy)
@@ -0,0 +1,570 @@
+// Portions copyright 2002, Google, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ro.callromania.util;
+
+// This code was converted from code at http://iharder.sourceforge.net/base64/
+// Lots of extraneous features were removed.
+/* The original code said:
+ * <p>
+ * I am placing this code in the Public Domain. Do with it as you will.
+ * This software comes with no guarantees or warranties but with
+ * plenty of well-wishing instead!
+ * Please visit
+ * <a href="http://iharder.net/xmlizable">http://iharder.net/xmlizable</a>
+ * periodically to check for updates or to contribute improvements.
+ * </p>
+ *
+ * @author Robert Harder
+ * @author rharder@usa.net
+ * @version 1.3
+ */
+
+/**
+ * Base64 converter class. This code is not a complete MIME encoder;
+ * it simply converts binary data to base64 data and back.
+ *
+ * <p>Note {@link CharBase64} is a GWT-compatible implementation of this
+ * class.
+ */
+public class Base64 {
+    /** Specify encoding (value is {@code true}). */
+    public final static boolean ENCODE = true;
+
+    /** Specify decoding (value is {@code false}). */
+    public final static boolean DECODE = false;
+
+    /** The equals sign (=) as a byte. */
+    private final static byte EQUALS_SIGN = (byte) '=';
+
+    /** The new line character (\n) as a byte. */
+    private final static byte NEW_LINE = (byte) '\n';
+
+    /**
+     * The 64 valid Base64 values.
+     */
+    private final static byte[] ALPHABET =
+        {(byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
+        (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
+        (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
+        (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
+        (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
+        (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
+        (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',
+        (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
+        (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't',
+        (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y',
+        (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
+        (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
+        (byte) '9', (byte) '+', (byte) '/'};
+
+    /**
+     * The 64 valid web safe Base64 values.
+     */
+    private final static byte[] WEBSAFE_ALPHABET =
+        {(byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
+        (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
+        (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
+        (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
+        (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
+        (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
+        (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',
+        (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
+        (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't',
+        (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y',
+        (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
+        (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
+        (byte) '9', (byte) '-', (byte) '_'};
+
+    /**
+     * Translates a Base64 value to either its 6-bit reconstruction value
+     * or a negative number indicating some other meaning.
+     **/
+    private final static byte[] DECODABET = {-9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
+        -5, -5, // Whitespace: Tab and Linefeed
+        -9, -9, // Decimal 11 - 12
+        -5, // Whitespace: Carriage Return
+        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
+        -9, -9, -9, -9, -9, // Decimal 27 - 31
+        -5, // Whitespace: Space
+        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
+        62, // Plus sign at decimal 43
+        -9, -9, -9, // Decimal 44 - 46
+        63, // Slash at decimal 47
+        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
+        -9, -9, -9, // Decimal 58 - 60
+        -1, // Equals sign at decimal 61
+        -9, -9, -9, // Decimal 62 - 64
+        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
+        14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
+        -9, -9, -9, -9, -9, -9, // Decimal 91 - 96
+        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
+        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
+        -9, -9, -9, -9, -9 // Decimal 123 - 127
+        /*  ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
+    };
+
+    /** The web safe decodabet */
+    private final static byte[] WEBSAFE_DECODABET =
+        {-9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
+        -5, -5, // Whitespace: Tab and Linefeed
+        -9, -9, // Decimal 11 - 12
+        -5, // Whitespace: Carriage Return
+        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
+        -9, -9, -9, -9, -9, // Decimal 27 - 31
+        -5, // Whitespace: Space
+        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 44
+        62, // Dash '-' sign at decimal 45
+        -9, -9, // Decimal 46-47
+        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
+        -9, -9, -9, // Decimal 58 - 60
+        -1, // Equals sign at decimal 61
+        -9, -9, -9, // Decimal 62 - 64
+        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
+        14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
+        -9, -9, -9, -9, // Decimal 91-94
+        63, // Underscore '_' at decimal 95
+        -9, // Decimal 96
+        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
+        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
+        -9, -9, -9, -9, -9 // Decimal 123 - 127
+        /*  ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
+        };
+
+    // Indicates white space in encoding
+    private final static byte WHITE_SPACE_ENC = -5;
+    // Indicates equals sign in encoding
+    private final static byte EQUALS_SIGN_ENC = -1;
+
+    /** Defeats instantiation. */
+    private Base64() {
+    }
+
+    /* ********  E N C O D I N G   M E T H O D S  ******** */
+
+    /**
+     * Encodes up to three bytes of the array <var>source</var>
+     * and writes the resulting four Base64 bytes to <var>destination</var>.
+     * The source and destination arrays can be manipulated
+     * anywhere along their length by specifying
+     * <var>srcOffset</var> and <var>destOffset</var>.
+     * This method does not check to make sure your arrays
+     * are large enough to accommodate <var>srcOffset</var> + 3 for
+     * the <var>source</var> array or <var>destOffset</var> + 4 for
+     * the <var>destination</var> array.
+     * The actual number of significant bytes in your array is
+     * given by <var>numSigBytes</var>.
+     *
+     * @param source the array to convert
+     * @param srcOffset the index where conversion begins
+     * @param numSigBytes the number of significant bytes in your array
+     * @param destination the array to hold the conversion
+     * @param destOffset the index where output will be put
+     * @param alphabet is the encoding alphabet
+     * @return the <var>destination</var> array
+     * @since 1.3
+     */
+    private static byte[] encode3to4(byte[] source, int srcOffset,
+            int numSigBytes, byte[] destination, int destOffset, byte[] alphabet) {
+        //           1         2         3
+        // 01234567890123456789012345678901 Bit position
+        // --------000000001111111122222222 Array position from threeBytes
+        // --------|    ||    ||    ||    | Six bit groups to index alphabet
+        //          >>18  >>12  >> 6  >> 0  Right shift necessary
+        //                0x3f  0x3f  0x3f  Additional AND
+
+        // Create buffer with zero-padding if there are only one or two
+        // significant bytes passed in the array.
+        // We have to shift left 24 in order to flush out the 1's that appear
+        // when Java treats a value as negative that is cast from a byte to an int.
+        int inBuff =
+                (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0)
+                | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0)
+                | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);
+
+        switch (numSigBytes) {
+            case 3:
+                destination[destOffset] = alphabet[(inBuff >>> 18)];
+                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
+                destination[destOffset + 2] = alphabet[(inBuff >>> 6) & 0x3f];
+                destination[destOffset + 3] = alphabet[(inBuff) & 0x3f];
+                return destination;
+            case 2:
+                destination[destOffset] = alphabet[(inBuff >>> 18)];
+                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
+                destination[destOffset + 2] = alphabet[(inBuff >>> 6) & 0x3f];
+                destination[destOffset + 3] = EQUALS_SIGN;
+                return destination;
+            case 1:
+                destination[destOffset] = alphabet[(inBuff >>> 18)];
+                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
+                destination[destOffset + 2] = EQUALS_SIGN;
+                destination[destOffset + 3] = EQUALS_SIGN;
+                return destination;
+            default:
+                return destination;
+        } // end switch
+    } // end encode3to4
+
+    /**
+     * Encodes a byte array into Base64 notation.
+     * Equivalent to calling
+     * {@code encodeBytes(source, 0, source.length)}
+     *
+     * @param source The data to convert
+     * @since 1.4
+     */
+    public static String encode(byte[] source) {
+        return encode(source, 0, source.length, ALPHABET, true);
+    }
+
+    /**
+     * Encodes a byte array into web safe Base64 notation.
+     *
+     * @param source The data to convert
+     * @param doPadding is {@code true} to pad result with '=' chars
+     *        if it does not fall on 3 byte boundaries
+     */
+    public static String encodeWebSafe(byte[] source, boolean doPadding) {
+        return encode(source, 0, source.length, WEBSAFE_ALPHABET, doPadding);
+    }
+
+    /**
+     * Encodes a byte array into Base64 notation.
+     *
+     * @param source the data to convert
+     * @param off offset in array where conversion should begin
+     * @param len length of data to convert
+     * @param alphabet the encoding alphabet
+     * @param doPadding is {@code true} to pad result with '=' chars
+     * if it does not fall on 3 byte boundaries
+     * @since 1.4
+     */
+    public static String encode(byte[] source, int off, int len, byte[] alphabet,
+            boolean doPadding) {
+        byte[] outBuff = encode(source, off, len, alphabet, Integer.MAX_VALUE);
+        int outLen = outBuff.length;
+
+        // If doPadding is false, set length to truncate '='
+        // padding characters
+        while (doPadding == false && outLen > 0) {
+            if (outBuff[outLen - 1] != '=') {
+                break;
+            }
+            outLen -= 1;
+        }
+
+        return new String(outBuff, 0, outLen);
+    }
+
+    /**
+     * Encodes a byte array into Base64 notation.
+     *
+     * @param source the data to convert
+     * @param off offset in array where conversion should begin
+     * @param len length of data to convert
+     * @param alphabet is the encoding alphabet
+     * @param maxLineLength maximum length of one line.
+     * @return the BASE64-encoded byte array
+     */
+    public static byte[] encode(byte[] source, int off, int len, byte[] alphabet,
+            int maxLineLength) {
+        int lenDiv3 = (len + 2) / 3; // ceil(len / 3)
+        int len43 = lenDiv3 * 4;
+        byte[] outBuff = new byte[len43 // Main 4:3
+                                  + (len43 / maxLineLength)]; // New lines
+
+        int d = 0;
+        int e = 0;
+        int len2 = len - 2;
+        int lineLength = 0;
+        for (; d < len2; d += 3, e += 4) {
+
+            // The following block of code is the same as
+            // encode3to4( source, d + off, 3, outBuff, e, alphabet );
+            // but inlined for faster encoding (~20% improvement)
+            int inBuff =
+                    ((source[d + off] << 24) >>> 8)
+                    | ((source[d + 1 + off] << 24) >>> 16)
+                    | ((source[d + 2 + off] << 24) >>> 24);
+            outBuff[e] = alphabet[(inBuff >>> 18)];
+            outBuff[e + 1] = alphabet[(inBuff >>> 12) & 0x3f];
+            outBuff[e + 2] = alphabet[(inBuff >>> 6) & 0x3f];
+            outBuff[e + 3] = alphabet[(inBuff) & 0x3f];
+
+            lineLength += 4;
+            if (lineLength == maxLineLength) {
+                outBuff[e + 4] = NEW_LINE;
+                e++;
+                lineLength = 0;
+            } // end if: end of line
+        } // end for: each piece of array
+
+        if (d < len) {
+            encode3to4(source, d + off, len - d, outBuff, e, alphabet);
+
+            lineLength += 4;
+            if (lineLength == maxLineLength) {
+                // Add a last newline
+                outBuff[e + 4] = NEW_LINE;
+                e++;
+            }
+            e += 4;
+        }
+
+        assert (e == outBuff.length);
+        return outBuff;
+    }
+
+
+    /* ********  D E C O D I N G   M E T H O D S  ******** */
+
+
+    /**
+     * Decodes four bytes from array <var>source</var>
+     * and writes the resulting bytes (up to three of them)
+     * to <var>destination</var>.
+     * The source and destination arrays can be manipulated
+     * anywhere along their length by specifying
+     * <var>srcOffset</var> and <var>destOffset</var>.
+     * This method does not check to make sure your arrays
+     * are large enough to accommodate <var>srcOffset</var> + 4 for
+     * the <var>source</var> array or <var>destOffset</var> + 3 for
+     * the <var>destination</var> array.
+     * This method returns the actual number of bytes that
+     * were converted from the Base64 encoding.
+     *
+     *
+     * @param source the array to convert
+     * @param srcOffset the index where conversion begins
+     * @param destination the array to hold the conversion
+     * @param destOffset the index where output will be put
+     * @param decodabet the decodabet for decoding Base64 content
+     * @return the number of decoded bytes converted
+     * @since 1.3
+     */
+    private static int decode4to3(byte[] source, int srcOffset,
+            byte[] destination, int destOffset, byte[] decodabet) {
+        // Example: Dk==
+        if (source[srcOffset + 2] == EQUALS_SIGN) {
+            int outBuff =
+                    ((decodabet[source[srcOffset]] << 24) >>> 6)
+                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12);
+
+            destination[destOffset] = (byte) (outBuff >>> 16);
+            return 1;
+        } else if (source[srcOffset + 3] == EQUALS_SIGN) {
+            // Example: DkL=
+            int outBuff =
+                    ((decodabet[source[srcOffset]] << 24) >>> 6)
+                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)
+                    | ((decodabet[source[srcOffset + 2]] << 24) >>> 18);
+
+            destination[destOffset] = (byte) (outBuff >>> 16);
+            destination[destOffset + 1] = (byte) (outBuff >>> 8);
+            return 2;
+        } else {
+            // Example: DkLE
+            int outBuff =
+                    ((decodabet[source[srcOffset]] << 24) >>> 6)
+                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)
+                    | ((decodabet[source[srcOffset + 2]] << 24) >>> 18)
+                    | ((decodabet[source[srcOffset + 3]] << 24) >>> 24);
+
+            destination[destOffset] = (byte) (outBuff >> 16);
+            destination[destOffset + 1] = (byte) (outBuff >> 8);
+            destination[destOffset + 2] = (byte) (outBuff);
+            return 3;
+        }
+    } // end decodeToBytes
+
+
+    /**
+     * Decodes data from Base64 notation.
+     *
+     * @param s the string to decode (decoded in default encoding)
+     * @return the decoded data
+     * @since 1.4
+     */
+    public static byte[] decode(String s) throws Base64DecoderException {
+        byte[] bytes = s.getBytes();
+        return decode(bytes, 0, bytes.length);
+    }
+
+    /**
+     * Decodes data from web safe Base64 notation.
+     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
+     *
+     * @param s the string to decode (decoded in default encoding)
+     * @return the decoded data
+     */
+    public static byte[] decodeWebSafe(String s) throws Base64DecoderException {
+        byte[] bytes = s.getBytes();
+        return decodeWebSafe(bytes, 0, bytes.length);
+    }
+
+    /**
+     * Decodes Base64 content in byte array format and returns
+     * the decoded byte array.
+     *
+     * @param source The Base64 encoded data
+     * @return decoded data
+     * @since 1.3
+     * @throws Base64DecoderException
+     */
+    public static byte[] decode(byte[] source) throws Base64DecoderException {
+        return decode(source, 0, source.length);
+    }
+
+    /**
+     * Decodes web safe Base64 content in byte array format and returns
+     * the decoded data.
+     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
+     *
+     * @param source the string to decode (decoded in default encoding)
+     * @return the decoded data
+     */
+    public static byte[] decodeWebSafe(byte[] source)
+            throws Base64DecoderException {
+        return decodeWebSafe(source, 0, source.length);
+    }
+
+    /**
+     * Decodes Base64 content in byte array format and returns
+     * the decoded byte array.
+     *
+     * @param source the Base64 encoded data
+     * @param off    the offset of where to begin decoding
+     * @param len    the length of characters to decode
+     * @return decoded data
+     * @since 1.3
+     * @throws Base64DecoderException
+     */
+    public static byte[] decode(byte[] source, int off, int len)
+            throws Base64DecoderException {
+        return decode(source, off, len, DECODABET);
+    }
+
+    /**
+     * Decodes web safe Base64 content in byte array format and returns
+     * the decoded byte array.
+     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
+     *
+     * @param source the Base64 encoded data
+     * @param off    the offset of where to begin decoding
+     * @param len    the length of characters to decode
+     * @return decoded data
+     */
+    public static byte[] decodeWebSafe(byte[] source, int off, int len)
+            throws Base64DecoderException {
+        return decode(source, off, len, WEBSAFE_DECODABET);
+    }
+
+    /**
+     * Decodes Base64 content using the supplied decodabet and returns
+     * the decoded byte array.
+     *
+     * @param source the Base64 encoded data
+     * @param off the offset of where to begin decoding
+     * @param len the length of characters to decode
+     * @param decodabet the decodabet for decoding Base64 content
+     * @return decoded data
+     */
+    public static byte[] decode(byte[] source, int off, int len, byte[] decodabet)
+            throws Base64DecoderException {
+        int len34 = len * 3 / 4;
+        byte[] outBuff = new byte[2 + len34]; // Upper limit on size of output
+        int outBuffPosn = 0;
+
+        byte[] b4 = new byte[4];
+        int b4Posn = 0;
+        int i = 0;
+        byte sbiCrop = 0;
+        byte sbiDecode = 0;
+        for (i = 0; i < len; i++) {
+            sbiCrop = (byte) (source[i + off] & 0x7f); // Only the low seven bits
+            sbiDecode = decodabet[sbiCrop];
+
+            if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better
+                if (sbiDecode >= EQUALS_SIGN_ENC) {
+                    // An equals sign (for padding) must not occur at position 0 or 1
+                    // and must be the last byte[s] in the encoded value
+                    if (sbiCrop == EQUALS_SIGN) {
+                        int bytesLeft = len - i;
+                        byte lastByte = (byte) (source[len - 1 + off] & 0x7f);
+                        if (b4Posn == 0 || b4Posn == 1) {
+                            throw new Base64DecoderException(
+                                    "invalid padding byte '=' at byte offset " + i);
+                        } else if ((b4Posn == 3 && bytesLeft > 2)
+                                || (b4Posn == 4 && bytesLeft > 1)) {
+                            throw new Base64DecoderException(
+                                    "padding byte '=' falsely signals end of encoded value "
+                                            + "at offset " + i);
+                        } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {
+                            throw new Base64DecoderException(
+                                    "encoded value has invalid trailing byte");
+                        }
+                        break;
+                    }
+
+                    b4[b4Posn++] = sbiCrop;
+                    if (b4Posn == 4) {
+                        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);
+                        b4Posn = 0;
+                    }
+                }
+            } else {
+                throw new Base64DecoderException("Bad Base64 input character at " + i
+                        + ": " + source[i + off] + "(decimal)");
+            }
+        }
+
+        // Because web safe encoding allows non padding base64 encodes, we
+        // need to pad the rest of the b4 buffer with equal signs when
+        // b4Posn != 0.  There can be at most 2 equal signs at the end of
+        // four characters, so the b4 buffer must have two or three
+        // characters.  This also catches the case where the input is
+        // padded with EQUALS_SIGN
+        if (b4Posn != 0) {
+            if (b4Posn == 1) {
+                throw new Base64DecoderException("single trailing character at offset "
+                        + (len - 1));
+            }
+            b4[b4Posn++] = EQUALS_SIGN;
+            outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);
+        }
+
+        byte[] out = new byte[outBuffPosn];
+        System.arraycopy(outBuff, 0, out, 0, outBuffPosn);
+        return out;
+    }
+}
Index: CSipSimple/src/ro/callromania/util/Base64DecoderException.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Base64DecoderException.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Base64DecoderException.java	(working copy)
@@ -0,0 +1,32 @@
+// Copyright 2002, Google, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ro.callromania.util;
+
+/**
+ * Exception thrown when encountering an invalid Base64 input character.
+ *
+ * @author nelson
+ */
+public class Base64DecoderException extends Exception {
+    public Base64DecoderException() {
+        super();
+    }
+
+    public Base64DecoderException(String s) {
+        super(s);
+    }
+
+    private static final long serialVersionUID = 1L;
+}
Index: CSipSimple/src/ro/callromania/util/GcmBroadcastReceiver.java
===================================================================
--- CSipSimple/src/ro/callromania/util/GcmBroadcastReceiver.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/GcmBroadcastReceiver.java	(working copy)
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2013 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ro.callromania.util;
+
+import android.app.Activity;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.support.v4.content.WakefulBroadcastReceiver;
+
+
+/**
+ * This {@code WakefulBroadcastReceiver} takes care of creating and managing a
+ * partial wake lock for your app. It passes off the work of processing the GCM
+ * message to an {@code IntentService}, while ensuring that the device does not
+ * go back to sleep in the transition. The {@code IntentService} calls
+ * {@code GcmBroadcastReceiver.completeWakefulIntent()} when it is ready to
+ * release the wake lock.
+ */
+
+public class GcmBroadcastReceiver extends WakefulBroadcastReceiver 
+{
+
+    @Override
+    public void onReceive(Context context, Intent intent) 
+    {
+        // Explicitly specify that GcmIntentService will handle the intent.
+        ComponentName comp = new ComponentName(context.getPackageName(), GcmIntentService.class.getName());
+        // Start the service, keeping the device awake while it is launching.
+        startWakefulService(context, (intent.setComponent(comp)));
+        setResultCode(Activity.RESULT_OK);
+    }
+}
Index: CSipSimple/src/ro/callromania/util/GcmIntentService.java
===================================================================
--- CSipSimple/src/ro/callromania/util/GcmIntentService.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/GcmIntentService.java	(working copy)
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import ro.callromania.R;
+import android.app.IntentService;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.media.RingtoneManager;
+import android.os.Bundle;
+import android.support.v4.app.NotificationCompat;
+
+import com.csipsimple.ui.SipHome;
+import com.google.android.gms.gcm.GoogleCloudMessaging;
+
+/**
+ * This {@code IntentService} does the actual handling of the GCM message.
+ * {@code GcmBroadcastReceiver} (a {@code WakefulBroadcastReceiver}) holds a
+ * partial wake lock for this service while the service does its work. When the
+ * service is finished, it calls {@code completeWakefulIntent()} to release the
+ * wake lock.
+ */
+public class GcmIntentService extends IntentService 
+{
+    public static int NOTIFICATION_ID = 1;
+    private NotificationManager mNotificationManager;
+    NotificationCompat.Builder builder;
+
+    public GcmIntentService() 
+    {
+        super("GcmIntentService");
+    }
+    public static final String TAG = "GCM Demo";
+
+    @Override
+    protected void onHandleIntent(Intent intent) 
+    {
+        Bundle extras = intent.getExtras();
+        GoogleCloudMessaging gcm = GoogleCloudMessaging.getInstance(this);
+        // The getMessageType() intent parameter must be the intent you received
+        // in your BroadcastReceiver.
+        String messageType = gcm.getMessageType(intent);
+
+        if (!extras.isEmpty()) {  // has effect of unparcelling Bundle
+            /*
+             * Filter messages based on message type. Since it is likely that GCM will be
+             * extended in the future with new message types, just ignore any message types you're
+             * not interested in, or that you don't recognize.
+             */
+            if (GoogleCloudMessaging.MESSAGE_TYPE_SEND_ERROR.equals(messageType)) 
+            {
+            	//TODO: really ceck this out
+//                sendNotification("Send error: " + extras.toString());
+            }
+            else if (GoogleCloudMessaging.MESSAGE_TYPE_DELETED.equals(messageType)) 
+            {
+            	//TODO: really ceck this out
+//                sendNotification("Deleted messages on server: " + extras.toString());
+            // If it's a regular GCM message, do some work.
+            } 
+            else if (GoogleCloudMessaging.MESSAGE_TYPE_MESSAGE.equals(messageType)) 
+            {
+                // This loop represents the service doing some work.
+//                for (int i = 0; i < 5; i++) 
+//                {
+//                    Log.i(TAG, "Working... " + (i + 1)
+//                            + "/5 @ " + SystemClock.elapsedRealtime());
+//                    try {
+//                        Thread.sleep(5000);
+//                    } catch (InterruptedException e) {
+//                    }
+//                }
+//                Log.i(TAG, "Completed work @ " + SystemClock.elapsedRealtime());
+            	
+                // Post notification of received message.
+                sendNotification(extras);
+//                Log.i(TAG, "Received: " + extras.toString());
+            }
+        }
+        // Release the wake lock provided by the WakefulBroadcastReceiver.
+        GcmBroadcastReceiver.completeWakefulIntent(intent);
+    }
+
+    // Put the message into a notification and post it.
+    // This is just one simple example of what you might choose to do with
+    // a GCM message.
+    private void sendNotification(Bundle msg) 
+    {    	
+        mNotificationManager = (NotificationManager) this.getSystemService(Context.NOTIFICATION_SERVICE);
+
+        PendingIntent contentIntent = PendingIntent.getActivity(this, 0, new Intent(this, SipHome.class), PendingIntent.FLAG_UPDATE_CURRENT);
+        
+        String title = msg.getString("title");
+        if (title == null) title = "CallRomania";
+        
+        String subtitle = msg.getString("subtitle");
+        if (subtitle == null) subtitle = "";
+
+        String message = msg.getString("message");
+        if (message == null) message = "";
+        
+        String tickerText = msg.getString("tickerText");
+        if (tickerText == null) tickerText = title;
+
+        NotificationCompat.Builder mBuilder = 
+        		new NotificationCompat.Builder(this)
+			        .setSmallIcon(R.drawable.ic_wizard_callromania)
+			        .setContentTitle(title)
+//			        .setStyle(new NotificationCompat.BigTextStyle()
+//			        .bigText(message))
+//			        .setContentText(subtitle)
+			        .setContentText(message)
+			        .setAutoCancel(true)
+			        .setSound(RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION))
+			        .setTicker(tickerText);
+
+        mBuilder.setContentIntent(contentIntent);
+        mNotificationManager.notify(NOTIFICATION_ID++, mBuilder.build());
+    }
+}
Index: CSipSimple/src/ro/callromania/util/IabException.java
===================================================================
--- CSipSimple/src/ro/callromania/util/IabException.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/IabException.java	(working copy)
@@ -0,0 +1,43 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+/**
+ * Exception thrown when something went wrong with in-app billing.
+ * An IabException has an associated IabResult (an error).
+ * To get the IAB result that caused this exception to be thrown,
+ * call {@link #getResult()}.
+ */
+public class IabException extends Exception {
+    IabResult mResult;
+
+    public IabException(IabResult r) {
+        this(r, null);
+    }
+    public IabException(int response, String message) {
+        this(new IabResult(response, message));
+    }
+    public IabException(IabResult r, Exception cause) {
+        super(r.getMessage(), cause);
+        mResult = r;
+    }
+    public IabException(int response, String message, Exception cause) {
+        this(new IabResult(response, message), cause);
+    }
+
+    /** Returns the IAB result (error) that this exception signals. */
+    public IabResult getResult() { return mResult; }
+}
\ No newline at end of file
Index: CSipSimple/src/ro/callromania/util/IabHelper.java
===================================================================
--- CSipSimple/src/ro/callromania/util/IabHelper.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/IabHelper.java	(working copy)
@@ -0,0 +1,991 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import android.app.Activity;
+import android.app.PendingIntent;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentSender.SendIntentException;
+import android.content.ServiceConnection;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.android.vending.billing.IInAppBillingService;
+
+import org.json.JSONException;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * Provides convenience methods for in-app billing. You can create one instance of this
+ * class for your application and use it to process in-app billing operations.
+ * It provides synchronous (blocking) and asynchronous (non-blocking) methods for
+ * many common in-app billing operations, as well as automatic signature
+ * verification.
+ *
+ * After instantiating, you must perform setup in order to start using the object.
+ * To perform setup, call the {@link #startSetup} method and provide a listener;
+ * that listener will be notified when setup is complete, after which (and not before)
+ * you may call other methods.
+ *
+ * After setup is complete, you will typically want to request an inventory of owned
+ * items and subscriptions. See {@link #queryInventory}, {@link #queryInventoryAsync}
+ * and related methods.
+ *
+ * When you are done with this object, don't forget to call {@link #dispose}
+ * to ensure proper cleanup. This object holds a binding to the in-app billing
+ * service, which will leak unless you dispose of it correctly. If you created
+ * the object on an Activity's onCreate method, then the recommended
+ * place to dispose of it is the Activity's onDestroy method.
+ *
+ * A note about threading: When using this object from a background thread, you may
+ * call the blocking versions of methods; when using from a UI thread, call
+ * only the asynchronous versions and handle the results via callbacks.
+ * Also, notice that you can only call one asynchronous operation at a time;
+ * attempting to start a second asynchronous operation while the first one
+ * has not yet completed will result in an exception being thrown.
+ *
+ * @author Bruno Oliveira (Google)
+ *
+ */
+public class IabHelper {
+    // Is debug logging enabled?
+    boolean mDebugLog = false;
+    String mDebugTag = "IabHelper";
+
+    // Is setup done?
+    boolean mSetupDone = false;
+
+    // Has this object been disposed of? (If so, we should ignore callbacks, etc)
+    boolean mDisposed = false;
+
+    // Are subscriptions supported?
+    boolean mSubscriptionsSupported = false;
+
+    // Is an asynchronous operation in progress?
+    // (only one at a time can be in progress)
+    boolean mAsyncInProgress = false;
+
+    // (for logging/debugging)
+    // if mAsyncInProgress == true, what asynchronous operation is in progress?
+    String mAsyncOperation = "";
+
+    // Context we were passed during initialization
+    Context mContext;
+
+    // Connection to the service
+    IInAppBillingService mService;
+    ServiceConnection mServiceConn;
+
+    // The request code used to launch purchase flow
+    int mRequestCode;
+
+    // The item type of the current purchase flow
+    String mPurchasingItemType;
+
+    // Public key for verifying signature, in base64 encoding
+    String mSignatureBase64 = null;
+
+    // Billing response codes
+    public static final int BILLING_RESPONSE_RESULT_OK = 0;
+    public static final int BILLING_RESPONSE_RESULT_USER_CANCELED = 1;
+    public static final int BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE = 3;
+    public static final int BILLING_RESPONSE_RESULT_ITEM_UNAVAILABLE = 4;
+    public static final int BILLING_RESPONSE_RESULT_DEVELOPER_ERROR = 5;
+    public static final int BILLING_RESPONSE_RESULT_ERROR = 6;
+    public static final int BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED = 7;
+    public static final int BILLING_RESPONSE_RESULT_ITEM_NOT_OWNED = 8;
+
+    // IAB Helper error codes
+    public static final int IABHELPER_ERROR_BASE = -1000;
+    public static final int IABHELPER_REMOTE_EXCEPTION = -1001;
+    public static final int IABHELPER_BAD_RESPONSE = -1002;
+    public static final int IABHELPER_VERIFICATION_FAILED = -1003;
+    public static final int IABHELPER_SEND_INTENT_FAILED = -1004;
+    public static final int IABHELPER_USER_CANCELLED = -1005;
+    public static final int IABHELPER_UNKNOWN_PURCHASE_RESPONSE = -1006;
+    public static final int IABHELPER_MISSING_TOKEN = -1007;
+    public static final int IABHELPER_UNKNOWN_ERROR = -1008;
+    public static final int IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE = -1009;
+    public static final int IABHELPER_INVALID_CONSUMPTION = -1010;
+
+    // Keys for the responses from InAppBillingService
+    public static final String RESPONSE_CODE = "RESPONSE_CODE";
+    public static final String RESPONSE_GET_SKU_DETAILS_LIST = "DETAILS_LIST";
+    public static final String RESPONSE_BUY_INTENT = "BUY_INTENT";
+    public static final String RESPONSE_INAPP_PURCHASE_DATA = "INAPP_PURCHASE_DATA";
+    public static final String RESPONSE_INAPP_SIGNATURE = "INAPP_DATA_SIGNATURE";
+    public static final String RESPONSE_INAPP_ITEM_LIST = "INAPP_PURCHASE_ITEM_LIST";
+    public static final String RESPONSE_INAPP_PURCHASE_DATA_LIST = "INAPP_PURCHASE_DATA_LIST";
+    public static final String RESPONSE_INAPP_SIGNATURE_LIST = "INAPP_DATA_SIGNATURE_LIST";
+    public static final String INAPP_CONTINUATION_TOKEN = "INAPP_CONTINUATION_TOKEN";
+
+    // Item types
+    public static final String ITEM_TYPE_INAPP = "inapp";
+    public static final String ITEM_TYPE_SUBS = "subs";
+
+    // some fields on the getSkuDetails response bundle
+    public static final String GET_SKU_DETAILS_ITEM_LIST = "ITEM_ID_LIST";
+    public static final String GET_SKU_DETAILS_ITEM_TYPE_LIST = "ITEM_TYPE_LIST";
+
+    /**
+     * Creates an instance. After creation, it will not yet be ready to use. You must perform
+     * setup by calling {@link #startSetup} and wait for setup to complete. This constructor does not
+     * block and is safe to call from a UI thread.
+     *
+     * @param ctx Your application or Activity context. Needed to bind to the in-app billing service.
+     * @param base64PublicKey Your application's public key, encoded in base64.
+     *     This is used for verification of purchase signatures. You can find your app's base64-encoded
+     *     public key in your application's page on Google Play Developer Console. Note that this
+     *     is NOT your "developer public key".
+     */
+    public IabHelper(Context ctx, String base64PublicKey) {
+        mContext = ctx.getApplicationContext();
+        mSignatureBase64 = base64PublicKey;
+        logDebug("IAB helper created.");
+    }
+
+    /**
+     * Enables or disable debug logging through LogCat.
+     */
+    public void enableDebugLogging(boolean enable, String tag) {
+        checkNotDisposed();
+        mDebugLog = enable;
+        mDebugTag = tag;
+    }
+
+    public void enableDebugLogging(boolean enable) {
+        checkNotDisposed();
+        mDebugLog = enable;
+    }
+
+    /**
+     * Callback for setup process. This listener's {@link #onIabSetupFinished} method is called
+     * when the setup process is complete.
+     */
+    public interface OnIabSetupFinishedListener {
+        /**
+         * Called to notify that setup is complete.
+         *
+         * @param result The result of the setup process.
+         */
+        public void onIabSetupFinished(IabResult result);
+    }
+
+    /**
+     * Starts the setup process. This will start up the setup process asynchronously.
+     * You will be notified through the listener when the setup process is complete.
+     * This method is safe to call from a UI thread.
+     *
+     * @param listener The listener to notify when the setup process is complete.
+     */
+    public void startSetup(final OnIabSetupFinishedListener listener) {
+        // If already set up, can't do it again.
+        checkNotDisposed();
+        if (mSetupDone) throw new IllegalStateException("IAB helper is already set up.");
+
+        // Connection to IAB service
+        logDebug("Starting in-app billing setup.");
+        mServiceConn = new ServiceConnection() {
+            @Override
+            public void onServiceDisconnected(ComponentName name) {
+                logDebug("Billing service disconnected.");
+                mService = null;
+            }
+
+            @Override
+            public void onServiceConnected(ComponentName name, IBinder service) {
+                if (mDisposed) return;
+                logDebug("Billing service connected.");
+                mService = IInAppBillingService.Stub.asInterface(service);
+                String packageName = mContext.getPackageName();
+                try {
+                    logDebug("Checking for in-app billing 3 support.");
+
+                    // check for in-app billing v3 support
+                    int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);
+                    if (response != BILLING_RESPONSE_RESULT_OK) {
+                        if (listener != null) listener.onIabSetupFinished(new IabResult(response,
+                                "Error checking for billing v3 support."));
+
+                        // if in-app purchases aren't supported, neither are subscriptions.
+                        mSubscriptionsSupported = false;
+                        return;
+                    }
+                    logDebug("In-app billing version 3 supported for " + packageName);
+
+                    // check for v3 subscriptions support
+                    response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);
+                    if (response == BILLING_RESPONSE_RESULT_OK) {
+                        logDebug("Subscriptions AVAILABLE.");
+                        mSubscriptionsSupported = true;
+                    }
+                    else {
+                        logDebug("Subscriptions NOT AVAILABLE. Response: " + response);
+                    }
+
+                    mSetupDone = true;
+                }
+                catch (RemoteException e) {
+                    if (listener != null) {
+                        listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION,
+                                                    "RemoteException while setting up in-app billing."));
+                    }
+                    e.printStackTrace();
+                    return;
+                }
+
+                if (listener != null) {
+                    listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Setup successful."));
+                }
+            }
+        };
+
+        Intent serviceIntent = new Intent("com.android.vending.billing.InAppBillingService.BIND");
+        serviceIntent.setPackage("com.android.vending");
+        if (!mContext.getPackageManager().queryIntentServices(serviceIntent, 0).isEmpty()) {
+            // service available to handle that Intent
+            mContext.bindService(serviceIntent, mServiceConn, Context.BIND_AUTO_CREATE);
+        }
+        else {
+            // no service available to handle that Intent
+            if (listener != null) {
+                listener.onIabSetupFinished(
+                        new IabResult(BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE,
+                        "Billing service unavailable on device."));
+            }
+        }
+    }
+
+    /**
+     * Dispose of object, releasing resources. It's very important to call this
+     * method when you are done with this object. It will release any resources
+     * used by it such as service connections. Naturally, once the object is
+     * disposed of, it can't be used again.
+     */
+    public void dispose() {
+        logDebug("Disposing.");
+        mSetupDone = false;
+        if (mServiceConn != null) {
+            logDebug("Unbinding from service.");
+            if (mContext != null) mContext.unbindService(mServiceConn);
+        }
+        mDisposed = true;
+        mContext = null;
+        mServiceConn = null;
+        mService = null;
+        mPurchaseListener = null;
+    }
+
+    private void checkNotDisposed() {
+        if (mDisposed) throw new IllegalStateException("IabHelper was disposed of, so it cannot be used.");
+    }
+
+    /** Returns whether subscriptions are supported. */
+    public boolean subscriptionsSupported() {
+        checkNotDisposed();
+        return mSubscriptionsSupported;
+    }
+
+
+    /**
+     * Callback that notifies when a purchase is finished.
+     */
+    public interface OnIabPurchaseFinishedListener {
+        /**
+         * Called to notify that an in-app purchase finished. If the purchase was successful,
+         * then the sku parameter specifies which item was purchased. If the purchase failed,
+         * the sku and extraData parameters may or may not be null, depending on how far the purchase
+         * process went.
+         *
+         * @param result The result of the purchase.
+         * @param info The purchase information (null if purchase failed)
+         */
+        public void onIabPurchaseFinished(IabResult result, Purchase info);
+    }
+
+    // The listener registered on launchPurchaseFlow, which we have to call back when
+    // the purchase finishes
+    OnIabPurchaseFinishedListener mPurchaseListener;
+
+    public void launchPurchaseFlow(Activity act, String sku, int requestCode, OnIabPurchaseFinishedListener listener) {
+        launchPurchaseFlow(act, sku, requestCode, listener, "");
+    }
+
+    public void launchPurchaseFlow(Activity act, String sku, int requestCode,
+            OnIabPurchaseFinishedListener listener, String extraData) {
+        launchPurchaseFlow(act, sku, ITEM_TYPE_INAPP, requestCode, listener, extraData);
+    }
+
+    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
+            OnIabPurchaseFinishedListener listener) {
+        launchSubscriptionPurchaseFlow(act, sku, requestCode, listener, "");
+    }
+
+    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
+            OnIabPurchaseFinishedListener listener, String extraData) {
+        launchPurchaseFlow(act, sku, ITEM_TYPE_SUBS, requestCode, listener, extraData);
+    }
+
+    /**
+     * Initiate the UI flow for an in-app purchase. Call this method to initiate an in-app purchase,
+     * which will involve bringing up the Google Play screen. The calling activity will be paused while
+     * the user interacts with Google Play, and the result will be delivered via the activity's
+     * {@link android.app.Activity#onActivityResult} method, at which point you must call
+     * this object's {@link #handleActivityResult} method to continue the purchase flow. This method
+     * MUST be called from the UI thread of the Activity.
+     *
+     * @param act The calling activity.
+     * @param sku The sku of the item to purchase.
+     * @param itemType indicates if it's a product or a subscription (ITEM_TYPE_INAPP or ITEM_TYPE_SUBS)
+     * @param requestCode A request code (to differentiate from other responses --
+     *     as in {@link android.app.Activity#startActivityForResult}).
+     * @param listener The listener to notify when the purchase process finishes
+     * @param extraData Extra data (developer payload), which will be returned with the purchase data
+     *     when the purchase completes. This extra data will be permanently bound to that purchase
+     *     and will always be returned when the purchase is queried.
+     */
+    public void launchPurchaseFlow(Activity act, String sku, String itemType, int requestCode,
+                        OnIabPurchaseFinishedListener listener, String extraData) {
+        checkNotDisposed();
+        checkSetupDone("launchPurchaseFlow");
+        flagStartAsync("launchPurchaseFlow");
+        IabResult result;
+
+        if (itemType.equals(ITEM_TYPE_SUBS) && !mSubscriptionsSupported) {
+            IabResult r = new IabResult(IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE,
+                    "Subscriptions are not available.");
+            flagEndAsync();
+            if (listener != null) listener.onIabPurchaseFinished(r, null);
+            return;
+        }
+
+        try {
+            logDebug("Constructing buy intent for " + sku + ", item type: " + itemType);
+            Bundle buyIntentBundle = mService.getBuyIntent(3, mContext.getPackageName(), sku, itemType, extraData);
+            int response = getResponseCodeFromBundle(buyIntentBundle);
+            if (response != BILLING_RESPONSE_RESULT_OK) {
+                logError("Unable to buy item, Error response: " + getResponseDesc(response));
+                flagEndAsync();
+                result = new IabResult(response, "Unable to buy item");
+                if (listener != null) listener.onIabPurchaseFinished(result, null);
+                return;
+            }
+
+            PendingIntent pendingIntent = buyIntentBundle.getParcelable(RESPONSE_BUY_INTENT);
+            logDebug("Launching buy intent for " + sku + ". Request code: " + requestCode);
+            mRequestCode = requestCode;
+            mPurchaseListener = listener;
+            mPurchasingItemType = itemType;
+            act.startIntentSenderForResult(pendingIntent.getIntentSender(),
+                                           requestCode, new Intent(),
+                                           Integer.valueOf(0), Integer.valueOf(0),
+                                           Integer.valueOf(0));
+        }
+        catch (SendIntentException e) {
+            logError("SendIntentException while launching purchase flow for sku " + sku);
+            e.printStackTrace();
+            flagEndAsync();
+
+            result = new IabResult(IABHELPER_SEND_INTENT_FAILED, "Failed to send intent.");
+            if (listener != null) listener.onIabPurchaseFinished(result, null);
+        }
+        catch (RemoteException e) {
+            logError("RemoteException while launching purchase flow for sku " + sku);
+            e.printStackTrace();
+            flagEndAsync();
+
+            result = new IabResult(IABHELPER_REMOTE_EXCEPTION, "Remote exception while starting purchase flow");
+            if (listener != null) listener.onIabPurchaseFinished(result, null);
+        }
+    }
+
+    /**
+     * Handles an activity result that's part of the purchase flow in in-app billing. If you
+     * are calling {@link #launchPurchaseFlow}, then you must call this method from your
+     * Activity's {@link android.app.Activity@onActivityResult} method. This method
+     * MUST be called from the UI thread of the Activity.
+     *
+     * @param requestCode The requestCode as you received it.
+     * @param resultCode The resultCode as you received it.
+     * @param data The data (Intent) as you received it.
+     * @return Returns true if the result was related to a purchase flow and was handled;
+     *     false if the result was not related to a purchase, in which case you should
+     *     handle it normally.
+     */
+    public boolean handleActivityResult(int requestCode, int resultCode, Intent data) {
+        IabResult result;
+        if (requestCode != mRequestCode) return false;
+
+        checkNotDisposed();
+        checkSetupDone("handleActivityResult");
+
+        // end of async purchase operation that started on launchPurchaseFlow
+        flagEndAsync();
+
+        if (data == null) {
+            logError("Null data in IAB activity result.");
+            result = new IabResult(IABHELPER_BAD_RESPONSE, "Null data in IAB result");
+            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+            return true;
+        }
+
+        int responseCode = getResponseCodeFromIntent(data);
+        String purchaseData = data.getStringExtra(RESPONSE_INAPP_PURCHASE_DATA);
+        String dataSignature = data.getStringExtra(RESPONSE_INAPP_SIGNATURE);
+
+        if (resultCode == Activity.RESULT_OK && responseCode == BILLING_RESPONSE_RESULT_OK) {
+            logDebug("Successful resultcode from purchase activity.");
+            logDebug("Purchase data: " + purchaseData);
+            logDebug("Data signature: " + dataSignature);
+            logDebug("Extras: " + data.getExtras());
+            logDebug("Expected item type: " + mPurchasingItemType);
+
+            if (purchaseData == null || dataSignature == null) {
+                logError("BUG: either purchaseData or dataSignature is null.");
+                logDebug("Extras: " + data.getExtras().toString());
+                result = new IabResult(IABHELPER_UNKNOWN_ERROR, "IAB returned null purchaseData or dataSignature");
+                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+                return true;
+            }
+
+            Purchase purchase = null;
+            try {
+                purchase = new Purchase(mPurchasingItemType, purchaseData, dataSignature);
+                String sku = purchase.getSku();
+
+                // Verify signature
+                if (!Security.verifyPurchase(mSignatureBase64, purchaseData, dataSignature)) {
+                    logError("Purchase signature verification FAILED for sku " + sku);
+                    result = new IabResult(IABHELPER_VERIFICATION_FAILED, "Signature verification failed for sku " + sku);
+                    if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, purchase);
+                    return true;
+                }
+                logDebug("Purchase signature successfully verified.");
+            }
+            catch (JSONException e) {
+                logError("Failed to parse purchase data.");
+                e.printStackTrace();
+                result = new IabResult(IABHELPER_BAD_RESPONSE, "Failed to parse purchase data.");
+                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+                return true;
+            }
+
+            if (mPurchaseListener != null) {
+                mPurchaseListener.onIabPurchaseFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Success"), purchase);
+            }
+        }
+        else if (resultCode == Activity.RESULT_OK) {
+            // result code was OK, but in-app billing response was not OK.
+            logDebug("Result code was OK but in-app billing response was not OK: " + getResponseDesc(responseCode));
+            if (mPurchaseListener != null) {
+                result = new IabResult(responseCode, "Problem purchashing item.");
+                mPurchaseListener.onIabPurchaseFinished(result, null);
+            }
+        }
+        else if (resultCode == Activity.RESULT_CANCELED) {
+            logDebug("Purchase canceled - Response: " + getResponseDesc(responseCode));
+            result = new IabResult(IABHELPER_USER_CANCELLED, "User canceled.");
+            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+        }
+        else {
+            logError("Purchase failed. Result code: " + Integer.toString(resultCode)
+                    + ". Response: " + getResponseDesc(responseCode));
+            result = new IabResult(IABHELPER_UNKNOWN_PURCHASE_RESPONSE, "Unknown purchase response.");
+            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+        }
+        return true;
+    }
+
+    public Inventory queryInventory(boolean querySkuDetails, List<String> moreSkus) throws IabException {
+        return queryInventory(querySkuDetails, moreSkus, null);
+    }
+
+    /**
+     * Queries the inventory. This will query all owned items from the server, as well as
+     * information on additional skus, if specified. This method may block or take long to execute.
+     * Do not call from a UI thread. For that, use the non-blocking version {@link #refreshInventoryAsync}.
+     *
+     * @param querySkuDetails if true, SKU details (price, description, etc) will be queried as well
+     *     as purchase information.
+     * @param moreItemSkus additional PRODUCT skus to query information on, regardless of ownership.
+     *     Ignored if null or if querySkuDetails is false.
+     * @param moreSubsSkus additional SUBSCRIPTIONS skus to query information on, regardless of ownership.
+     *     Ignored if null or if querySkuDetails is false.
+     * @throws IabException if a problem occurs while refreshing the inventory.
+     */
+    public Inventory queryInventory(boolean querySkuDetails, List<String> moreItemSkus,
+                                        List<String> moreSubsSkus) throws IabException {
+        checkNotDisposed();
+        checkSetupDone("queryInventory");
+        try {
+            Inventory inv = new Inventory();
+            int r = queryPurchases(inv, ITEM_TYPE_INAPP);
+            if (r != BILLING_RESPONSE_RESULT_OK) {
+                throw new IabException(r, "Error refreshing inventory (querying owned items).");
+            }
+
+            if (querySkuDetails) {
+                r = querySkuDetails(ITEM_TYPE_INAPP, inv, moreItemSkus);
+                if (r != BILLING_RESPONSE_RESULT_OK) {
+                    throw new IabException(r, "Error refreshing inventory (querying prices of items).");
+                }
+            }
+
+            // if subscriptions are supported, then also query for subscriptions
+            if (mSubscriptionsSupported) {
+                r = queryPurchases(inv, ITEM_TYPE_SUBS);
+                if (r != BILLING_RESPONSE_RESULT_OK) {
+                    throw new IabException(r, "Error refreshing inventory (querying owned subscriptions).");
+                }
+
+                if (querySkuDetails) {
+                    r = querySkuDetails(ITEM_TYPE_SUBS, inv, moreItemSkus);
+                    if (r != BILLING_RESPONSE_RESULT_OK) {
+                        throw new IabException(r, "Error refreshing inventory (querying prices of subscriptions).");
+                    }
+                }
+            }
+
+            return inv;
+        }
+        catch (RemoteException e) {
+            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while refreshing inventory.", e);
+        }
+        catch (JSONException e) {
+            throw new IabException(IABHELPER_BAD_RESPONSE, "Error parsing JSON response while refreshing inventory.", e);
+        }
+    }
+
+    /**
+     * Listener that notifies when an inventory query operation completes.
+     */
+    public interface QueryInventoryFinishedListener {
+        /**
+         * Called to notify that an inventory query operation completed.
+         *
+         * @param result The result of the operation.
+         * @param inv The inventory.
+         */
+        public void onQueryInventoryFinished(IabResult result, Inventory inv);
+    }
+
+
+    /**
+     * Asynchronous wrapper for inventory query. This will perform an inventory
+     * query as described in {@link #queryInventory}, but will do so asynchronously
+     * and call back the specified listener upon completion. This method is safe to
+     * call from a UI thread.
+     *
+     * @param querySkuDetails as in {@link #queryInventory}
+     * @param moreSkus as in {@link #queryInventory}
+     * @param listener The listener to notify when the refresh operation completes.
+     */
+    public void queryInventoryAsync(final boolean querySkuDetails,
+                               final List<String> moreSkus,
+                               final QueryInventoryFinishedListener listener) {
+        final Handler handler = new Handler();
+        checkNotDisposed();
+        checkSetupDone("queryInventory");
+        flagStartAsync("refresh inventory");
+        (new Thread(new Runnable() {
+            public void run() {
+                IabResult result = new IabResult(BILLING_RESPONSE_RESULT_OK, "Inventory refresh successful.");
+                Inventory inv = null;
+                try {
+                    inv = queryInventory(querySkuDetails, moreSkus);
+                }
+                catch (IabException ex) {
+                    result = ex.getResult();
+                }
+
+                flagEndAsync();
+
+                final IabResult result_f = result;
+                final Inventory inv_f = inv;
+                if (!mDisposed && listener != null) {
+                    handler.post(new Runnable() {
+                        public void run() {
+                            listener.onQueryInventoryFinished(result_f, inv_f);
+                        }
+                    });
+                }
+            }
+        })).start();
+    }
+
+    public void queryInventoryAsync(QueryInventoryFinishedListener listener) {
+        queryInventoryAsync(true, null, listener);
+    }
+
+    public void queryInventoryAsync(boolean querySkuDetails, QueryInventoryFinishedListener listener) {
+        queryInventoryAsync(querySkuDetails, null, listener);
+    }
+
+
+    /**
+     * Consumes a given in-app product. Consuming can only be done on an item
+     * that's owned, and as a result of consumption, the user will no longer own it.
+     * This method may block or take long to return. Do not call from the UI thread.
+     * For that, see {@link #consumeAsync}.
+     *
+     * @param itemInfo The PurchaseInfo that represents the item to consume.
+     * @throws IabException if there is a problem during consumption.
+     */
+    void consume(Purchase itemInfo) throws IabException {
+        checkNotDisposed();
+        checkSetupDone("consume");
+
+        if (!itemInfo.mItemType.equals(ITEM_TYPE_INAPP)) {
+            throw new IabException(IABHELPER_INVALID_CONSUMPTION,
+                    "Items of type '" + itemInfo.mItemType + "' can't be consumed.");
+        }
+
+        try {
+            String token = itemInfo.getToken();
+            String sku = itemInfo.getSku();
+            if (token == null || token.equals("")) {
+               logError("Can't consume "+ sku + ". No token.");
+               throw new IabException(IABHELPER_MISSING_TOKEN, "PurchaseInfo is missing token for sku: "
+                   + sku + " " + itemInfo);
+            }
+
+            logDebug("Consuming sku: " + sku + ", token: " + token);
+            int response = mService.consumePurchase(3, mContext.getPackageName(), token);
+            if (response == BILLING_RESPONSE_RESULT_OK) {
+               logDebug("Successfully consumed sku: " + sku);
+            }
+            else {
+               logDebug("Error consuming consuming sku " + sku + ". " + getResponseDesc(response));
+               throw new IabException(response, "Error consuming sku " + sku);
+            }
+        }
+        catch (RemoteException e) {
+            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while consuming. PurchaseInfo: " + itemInfo, e);
+        }
+    }
+
+    /**
+     * Callback that notifies when a consumption operation finishes.
+     */
+    public interface OnConsumeFinishedListener {
+        /**
+         * Called to notify that a consumption has finished.
+         *
+         * @param purchase The purchase that was (or was to be) consumed.
+         * @param result The result of the consumption operation.
+         */
+        public void onConsumeFinished(Purchase purchase, IabResult result);
+    }
+
+    /**
+     * Callback that notifies when a multi-item consumption operation finishes.
+     */
+    public interface OnConsumeMultiFinishedListener {
+        /**
+         * Called to notify that a consumption of multiple items has finished.
+         *
+         * @param purchases The purchases that were (or were to be) consumed.
+         * @param results The results of each consumption operation, corresponding to each
+         *     sku.
+         */
+        public void onConsumeMultiFinished(List<Purchase> purchases, List<IabResult> results);
+    }
+
+    /**
+     * Asynchronous wrapper to item consumption. Works like {@link #consume}, but
+     * performs the consumption in the background and notifies completion through
+     * the provided listener. This method is safe to call from a UI thread.
+     *
+     * @param purchase The purchase to be consumed.
+     * @param listener The listener to notify when the consumption operation finishes.
+     */
+    public void consumeAsync(Purchase purchase, OnConsumeFinishedListener listener) {
+        checkNotDisposed();
+        checkSetupDone("consume");
+        List<Purchase> purchases = new ArrayList<Purchase>();
+        purchases.add(purchase);
+        consumeAsyncInternal(purchases, listener, null);
+    }
+
+    /**
+     * Same as {@link consumeAsync}, but for multiple items at once.
+     * @param purchases The list of PurchaseInfo objects representing the purchases to consume.
+     * @param listener The listener to notify when the consumption operation finishes.
+     */
+    public void consumeAsync(List<Purchase> purchases, OnConsumeMultiFinishedListener listener) {
+        checkNotDisposed();
+        checkSetupDone("consume");
+        consumeAsyncInternal(purchases, null, listener);
+    }
+
+    /**
+     * Returns a human-readable description for the given response code.
+     *
+     * @param code The response code
+     * @return A human-readable string explaining the result code.
+     *     It also includes the result code numerically.
+     */
+    public static String getResponseDesc(int code) {
+        String[] iab_msgs = ("0:OK/1:User Canceled/2:Unknown/" +
+                "3:Billing Unavailable/4:Item unavailable/" +
+                "5:Developer Error/6:Error/7:Item Already Owned/" +
+                "8:Item not owned").split("/");
+        String[] iabhelper_msgs = ("0:OK/-1001:Remote exception during initialization/" +
+                                   "-1002:Bad response received/" +
+                                   "-1003:Purchase signature verification failed/" +
+                                   "-1004:Send intent failed/" +
+                                   "-1005:User cancelled/" +
+                                   "-1006:Unknown purchase response/" +
+                                   "-1007:Missing token/" +
+                                   "-1008:Unknown error/" +
+                                   "-1009:Subscriptions not available/" +
+                                   "-1010:Invalid consumption attempt").split("/");
+
+        if (code <= IABHELPER_ERROR_BASE) {
+            int index = IABHELPER_ERROR_BASE - code;
+            if (index >= 0 && index < iabhelper_msgs.length) return iabhelper_msgs[index];
+            else return String.valueOf(code) + ":Unknown IAB Helper Error";
+        }
+        else if (code < 0 || code >= iab_msgs.length)
+            return String.valueOf(code) + ":Unknown";
+        else
+            return iab_msgs[code];
+    }
+
+
+    // Checks that setup was done; if not, throws an exception.
+    void checkSetupDone(String operation) {
+        if (!mSetupDone) {
+            logError("Illegal state for operation (" + operation + "): IAB helper is not set up.");
+            throw new IllegalStateException("IAB helper is not set up. Can't perform operation: " + operation);
+        }
+    }
+
+    // Workaround to bug where sometimes response codes come as Long instead of Integer
+    int getResponseCodeFromBundle(Bundle b) {
+        Object o = b.get(RESPONSE_CODE);
+        if (o == null) {
+            logDebug("Bundle with null response code, assuming OK (known issue)");
+            return BILLING_RESPONSE_RESULT_OK;
+        }
+        else if (o instanceof Integer) return ((Integer)o).intValue();
+        else if (o instanceof Long) return (int)((Long)o).longValue();
+        else {
+            logError("Unexpected type for bundle response code.");
+            logError(o.getClass().getName());
+            throw new RuntimeException("Unexpected type for bundle response code: " + o.getClass().getName());
+        }
+    }
+
+    // Workaround to bug where sometimes response codes come as Long instead of Integer
+    int getResponseCodeFromIntent(Intent i) {
+        Object o = i.getExtras().get(RESPONSE_CODE);
+        if (o == null) {
+            logError("Intent with no response code, assuming OK (known issue)");
+            return BILLING_RESPONSE_RESULT_OK;
+        }
+        else if (o instanceof Integer) return ((Integer)o).intValue();
+        else if (o instanceof Long) return (int)((Long)o).longValue();
+        else {
+            logError("Unexpected type for intent response code.");
+            logError(o.getClass().getName());
+            throw new RuntimeException("Unexpected type for intent response code: " + o.getClass().getName());
+        }
+    }
+
+    void flagStartAsync(String operation) {
+        if (mAsyncInProgress) throw new IllegalStateException("Can't start async operation (" +
+                operation + ") because another async operation(" + mAsyncOperation + ") is in progress.");
+        mAsyncOperation = operation;
+        mAsyncInProgress = true;
+        logDebug("Starting async operation: " + operation);
+    }
+
+    void flagEndAsync() {
+        logDebug("Ending async operation: " + mAsyncOperation);
+        mAsyncOperation = "";
+        mAsyncInProgress = false;
+    }
+
+
+    int queryPurchases(Inventory inv, String itemType) throws JSONException, RemoteException {
+        // Query purchases
+        logDebug("Querying owned items, item type: " + itemType);
+        logDebug("Package name: " + mContext.getPackageName());
+        boolean verificationFailed = false;
+        String continueToken = null;
+
+        do {
+            logDebug("Calling getPurchases with continuation token: " + continueToken);
+            Bundle ownedItems = mService.getPurchases(3, mContext.getPackageName(),
+                    itemType, continueToken);
+
+            int response = getResponseCodeFromBundle(ownedItems);
+            logDebug("Owned items response: " + String.valueOf(response));
+            if (response != BILLING_RESPONSE_RESULT_OK) {
+                logDebug("getPurchases() failed: " + getResponseDesc(response));
+                return response;
+            }
+            if (!ownedItems.containsKey(RESPONSE_INAPP_ITEM_LIST)
+                    || !ownedItems.containsKey(RESPONSE_INAPP_PURCHASE_DATA_LIST)
+                    || !ownedItems.containsKey(RESPONSE_INAPP_SIGNATURE_LIST)) {
+                logError("Bundle returned from getPurchases() doesn't contain required fields.");
+                return IABHELPER_BAD_RESPONSE;
+            }
+
+            ArrayList<String> ownedSkus = ownedItems.getStringArrayList(
+                        RESPONSE_INAPP_ITEM_LIST);
+            ArrayList<String> purchaseDataList = ownedItems.getStringArrayList(
+                        RESPONSE_INAPP_PURCHASE_DATA_LIST);
+            ArrayList<String> signatureList = ownedItems.getStringArrayList(
+                        RESPONSE_INAPP_SIGNATURE_LIST);
+
+            for (int i = 0; i < purchaseDataList.size(); ++i) {
+                String purchaseData = purchaseDataList.get(i);
+                String signature = signatureList.get(i);
+                String sku = ownedSkus.get(i);
+                if (Security.verifyPurchase(mSignatureBase64, purchaseData, signature)) {
+                    logDebug("Sku is owned: " + sku);
+                    Purchase purchase = new Purchase(itemType, purchaseData, signature);
+
+                    if (TextUtils.isEmpty(purchase.getToken())) {
+                        logWarn("BUG: empty/null token!");
+                        logDebug("Purchase data: " + purchaseData);
+                    }
+
+                    // Record ownership and token
+                    inv.addPurchase(purchase);
+                }
+                else {
+                    logWarn("Purchase signature verification **FAILED**. Not adding item.");
+                    logDebug("   Purchase data: " + purchaseData);
+                    logDebug("   Signature: " + signature);
+                    verificationFailed = true;
+                }
+            }
+
+            continueToken = ownedItems.getString(INAPP_CONTINUATION_TOKEN);
+            logDebug("Continuation token: " + continueToken);
+        } while (!TextUtils.isEmpty(continueToken));
+
+        return verificationFailed ? IABHELPER_VERIFICATION_FAILED : BILLING_RESPONSE_RESULT_OK;
+    }
+
+    int querySkuDetails(String itemType, Inventory inv, List<String> moreSkus)
+                                throws RemoteException, JSONException {
+        logDebug("Querying SKU details.");
+        ArrayList<String> skuList = new ArrayList<String>();
+        skuList.addAll(inv.getAllOwnedSkus(itemType));
+        if (moreSkus != null) {
+            for (String sku : moreSkus) {
+                if (!skuList.contains(sku)) {
+                    skuList.add(sku);
+                }
+            }
+        }
+
+        if (skuList.size() == 0) {
+            logDebug("queryPrices: nothing to do because there are no SKUs.");
+            return BILLING_RESPONSE_RESULT_OK;
+        }
+
+        Bundle querySkus = new Bundle();
+        querySkus.putStringArrayList(GET_SKU_DETAILS_ITEM_LIST, skuList);
+        Bundle skuDetails = mService.getSkuDetails(3, mContext.getPackageName(),
+                itemType, querySkus);
+
+        if (!skuDetails.containsKey(RESPONSE_GET_SKU_DETAILS_LIST)) {
+            int response = getResponseCodeFromBundle(skuDetails);
+            if (response != BILLING_RESPONSE_RESULT_OK) {
+                logDebug("getSkuDetails() failed: " + getResponseDesc(response));
+                return response;
+            }
+            else {
+                logError("getSkuDetails() returned a bundle with neither an error nor a detail list.");
+                return IABHELPER_BAD_RESPONSE;
+            }
+        }
+
+        ArrayList<String> responseList = skuDetails.getStringArrayList(
+                RESPONSE_GET_SKU_DETAILS_LIST);
+
+        for (String thisResponse : responseList) {
+            SkuDetails d = new SkuDetails(itemType, thisResponse);
+            logDebug("Got sku details: " + d);
+            inv.addSkuDetails(d);
+        }
+        return BILLING_RESPONSE_RESULT_OK;
+    }
+
+
+    void consumeAsyncInternal(final List<Purchase> purchases,
+                              final OnConsumeFinishedListener singleListener,
+                              final OnConsumeMultiFinishedListener multiListener) {
+        final Handler handler = new Handler();
+        flagStartAsync("consume");
+        (new Thread(new Runnable() {
+            public void run() {
+                final List<IabResult> results = new ArrayList<IabResult>();
+                for (Purchase purchase : purchases) {
+                    try {
+                        consume(purchase);
+                        results.add(new IabResult(BILLING_RESPONSE_RESULT_OK, "Successful consume of sku " + purchase.getSku()));
+                    }
+                    catch (IabException ex) {
+                        results.add(ex.getResult());
+                    }
+                }
+
+                flagEndAsync();
+                if (!mDisposed && singleListener != null) {
+                    handler.post(new Runnable() {
+                        public void run() {
+                            singleListener.onConsumeFinished(purchases.get(0), results.get(0));
+                        }
+                    });
+                }
+                if (!mDisposed && multiListener != null) {
+                    handler.post(new Runnable() {
+                        public void run() {
+                            multiListener.onConsumeMultiFinished(purchases, results);
+                        }
+                    });
+                }
+            }
+        })).start();
+    }
+
+    void logDebug(String msg) {
+        if (mDebugLog) Log.d(mDebugTag, msg);
+    }
+
+    void logError(String msg) {
+        Log.e(mDebugTag, "In-app billing error: " + msg);
+    }
+
+    void logWarn(String msg) {
+        Log.w(mDebugTag, "In-app billing warning: " + msg);
+    }
+}
Index: CSipSimple/src/ro/callromania/util/IabResult.java
===================================================================
--- CSipSimple/src/ro/callromania/util/IabResult.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/IabResult.java	(working copy)
@@ -0,0 +1,45 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+/**
+ * Represents the result of an in-app billing operation.
+ * A result is composed of a response code (an integer) and possibly a
+ * message (String). You can get those by calling
+ * {@link #getResponse} and {@link #getMessage()}, respectively. You
+ * can also inquire whether a result is a success or a failure by
+ * calling {@link #isSuccess()} and {@link #isFailure()}.
+ */
+public class IabResult {
+    int mResponse;
+    String mMessage;
+
+    public IabResult(int response, String message) {
+        mResponse = response;
+        if (message == null || message.trim().length() == 0) {
+            mMessage = IabHelper.getResponseDesc(response);
+        }
+        else {
+            mMessage = message + " (response: " + IabHelper.getResponseDesc(response) + ")";
+        }
+    }
+    public int getResponse() { return mResponse; }
+    public String getMessage() { return mMessage; }
+    public boolean isSuccess() { return ((mResponse == IabHelper.BILLING_RESPONSE_RESULT_OK) || (mResponse == IabHelper.BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED)); }
+    public boolean isFailure() { return !isSuccess(); }
+    public String toString() { return "IabResult: " + getMessage(); }
+}
+
Index: CSipSimple/src/ro/callromania/util/Inventory.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Inventory.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Inventory.java	(working copy)
@@ -0,0 +1,91 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Represents a block of information about in-app items.
+ * An Inventory is returned by such methods as {@link IabHelper#queryInventory}.
+ */
+public class Inventory {
+    Map<String,SkuDetails> mSkuMap = new HashMap<String,SkuDetails>();
+    Map<String,Purchase> mPurchaseMap = new HashMap<String,Purchase>();
+
+    Inventory() { }
+
+    /** Returns the listing details for an in-app product. */
+    public SkuDetails getSkuDetails(String sku) {
+        return mSkuMap.get(sku);
+    }
+
+    /** Returns purchase information for a given product, or null if there is no purchase. */
+    public Purchase getPurchase(String sku) {
+        return mPurchaseMap.get(sku);
+    }
+
+    /** Returns whether or not there exists a purchase of the given product. */
+    public boolean hasPurchase(String sku) {
+        return mPurchaseMap.containsKey(sku);
+    }
+
+    /** Return whether or not details about the given product are available. */
+    public boolean hasDetails(String sku) {
+        return mSkuMap.containsKey(sku);
+    }
+
+    /**
+     * Erase a purchase (locally) from the inventory, given its product ID. This just
+     * modifies the Inventory object locally and has no effect on the server! This is
+     * useful when you have an existing Inventory object which you know to be up to date,
+     * and you have just consumed an item successfully, which means that erasing its
+     * purchase data from the Inventory you already have is quicker than querying for
+     * a new Inventory.
+     */
+    public void erasePurchase(String sku) {
+        if (mPurchaseMap.containsKey(sku)) mPurchaseMap.remove(sku);
+    }
+
+    /** Returns a list of all owned product IDs. */
+    List<String> getAllOwnedSkus() {
+        return new ArrayList<String>(mPurchaseMap.keySet());
+    }
+
+    /** Returns a list of all owned product IDs of a given type */
+    List<String> getAllOwnedSkus(String itemType) {
+        List<String> result = new ArrayList<String>();
+        for (Purchase p : mPurchaseMap.values()) {
+            if (p.getItemType().equals(itemType)) result.add(p.getSku());
+        }
+        return result;
+    }
+
+    /** Returns a list of all purchases. */
+    List<Purchase> getAllPurchases() {
+        return new ArrayList<Purchase>(mPurchaseMap.values());
+    }
+
+    void addSkuDetails(SkuDetails d) {
+        mSkuMap.put(d.getSku(), d);
+    }
+
+    void addPurchase(Purchase p) {
+        mPurchaseMap.put(p.getSku(), p);
+    }
+}
Index: CSipSimple/src/ro/callromania/util/Purchase.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Purchase.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Purchase.java	(working copy)
@@ -0,0 +1,63 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Represents an in-app billing purchase.
+ */
+public class Purchase {
+    String mItemType;  // ITEM_TYPE_INAPP or ITEM_TYPE_SUBS
+    String mOrderId;
+    String mPackageName;
+    String mSku;
+    long mPurchaseTime;
+    int mPurchaseState;
+    String mDeveloperPayload;
+    String mToken;
+    String mOriginalJson;
+    String mSignature;
+
+    public Purchase(String itemType, String jsonPurchaseInfo, String signature) throws JSONException {
+        mItemType = itemType;
+        mOriginalJson = jsonPurchaseInfo;
+        JSONObject o = new JSONObject(mOriginalJson);
+        mOrderId = o.optString("orderId");
+        mPackageName = o.optString("packageName");
+        mSku = o.optString("productId");
+        mPurchaseTime = o.optLong("purchaseTime");
+        mPurchaseState = o.optInt("purchaseState");
+        mDeveloperPayload = o.optString("developerPayload");
+        mToken = o.optString("token", o.optString("purchaseToken"));
+        mSignature = signature;
+    }
+
+    public String getItemType() { return mItemType; }
+    public String getOrderId() { return mOrderId; }
+    public String getPackageName() { return mPackageName; }
+    public String getSku() { return mSku; }
+    public long getPurchaseTime() { return mPurchaseTime; }
+    public int getPurchaseState() { return mPurchaseState; }
+    public String getDeveloperPayload() { return mDeveloperPayload; }
+    public String getToken() { return mToken; }
+    public String getOriginalJson() { return mOriginalJson; }
+    public String getSignature() { return mSignature; }
+
+    @Override
+    public String toString() { return "PurchaseInfo(type:" + mItemType + "):" + mOriginalJson; }
+}
Index: CSipSimple/src/ro/callromania/util/Security.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Security.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Security.java	(working copy)
@@ -0,0 +1,123 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import android.text.TextUtils;
+import android.util.Log;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+
+import java.security.InvalidKeyException;
+import java.security.KeyFactory;
+import java.security.NoSuchAlgorithmException;
+import java.security.PublicKey;
+import java.security.Signature;
+import java.security.SignatureException;
+import java.security.spec.InvalidKeySpecException;
+import java.security.spec.X509EncodedKeySpec;
+
+/**
+ * Security-related methods. For a secure implementation, all of this code
+ * should be implemented on a server that communicates with the
+ * application on the device. For the sake of simplicity and clarity of this
+ * example, this code is included here and is executed on the device. If you
+ * must verify the purchases on the phone, you should obfuscate this code to
+ * make it harder for an attacker to replace the code with stubs that treat all
+ * purchases as verified.
+ */
+public class Security {
+    private static final String TAG = "IABUtil/Security";
+
+    private static final String KEY_FACTORY_ALGORITHM = "RSA";
+    private static final String SIGNATURE_ALGORITHM = "SHA1withRSA";
+
+    /**
+     * Verifies that the data was signed with the given signature, and returns
+     * the verified purchase. The data is in JSON format and signed
+     * with a private key. The data also contains the {@link PurchaseState}
+     * and product ID of the purchase.
+     * @param base64PublicKey the base64-encoded public key to use for verifying.
+     * @param signedData the signed JSON string (signed, not encrypted)
+     * @param signature the signature for the data, signed with the private key
+     */
+    public static boolean verifyPurchase(String base64PublicKey, String signedData, String signature) {
+        if (TextUtils.isEmpty(signedData) || TextUtils.isEmpty(base64PublicKey) ||
+                TextUtils.isEmpty(signature)) {
+            Log.e(TAG, "Purchase verification failed: missing data.");
+            return false;
+        }
+
+        PublicKey key = Security.generatePublicKey(base64PublicKey);
+        return Security.verify(key, signedData, signature);
+    }
+
+    /**
+     * Generates a PublicKey instance from a string containing the
+     * Base64-encoded public key.
+     *
+     * @param encodedPublicKey Base64-encoded public key
+     * @throws IllegalArgumentException if encodedPublicKey is invalid
+     */
+    public static PublicKey generatePublicKey(String encodedPublicKey) {
+        try {
+            byte[] decodedKey = Base64.decode(encodedPublicKey);
+            KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);
+            return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey));
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+        } catch (InvalidKeySpecException e) {
+            Log.e(TAG, "Invalid key specification.");
+            throw new IllegalArgumentException(e);
+        } catch (Base64DecoderException e) {
+            Log.e(TAG, "Base64 decoding failed.");
+            throw new IllegalArgumentException(e);
+        }
+    }
+
+    /**
+     * Verifies that the signature from the server matches the computed
+     * signature on the data.  Returns true if the data is correctly signed.
+     *
+     * @param publicKey public key associated with the developer account
+     * @param signedData signed data from server
+     * @param signature server signature
+     * @return true if the data and signature match
+     */
+    public static boolean verify(PublicKey publicKey, String signedData, String signature) {
+        Signature sig;
+        try {
+            sig = Signature.getInstance(SIGNATURE_ALGORITHM);
+            sig.initVerify(publicKey);
+            sig.update(signedData.getBytes());
+            if (!sig.verify(Base64.decode(signature))) {
+                Log.e(TAG, "Signature verification failed.");
+                return false;
+            }
+            return true;
+        } catch (NoSuchAlgorithmException e) {
+            Log.e(TAG, "NoSuchAlgorithmException.");
+        } catch (InvalidKeyException e) {
+            Log.e(TAG, "Invalid key specification.");
+        } catch (SignatureException e) {
+            Log.e(TAG, "Signature exception.");
+        } catch (Base64DecoderException e) {
+            Log.e(TAG, "Base64 decoding failed.");
+        }
+        return false;
+    }
+}
Index: CSipSimple/src/ro/callromania/util/SkuDetails.java
===================================================================
--- CSipSimple/src/ro/callromania/util/SkuDetails.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/SkuDetails.java	(working copy)
@@ -0,0 +1,58 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Represents an in-app product's listing details.
+ */
+public class SkuDetails {
+    String mItemType;
+    String mSku;
+    String mType;
+    String mPrice;
+    String mTitle;
+    String mDescription;
+    String mJson;
+
+    public SkuDetails(String jsonSkuDetails) throws JSONException {
+        this(IabHelper.ITEM_TYPE_INAPP, jsonSkuDetails);
+    }
+
+    public SkuDetails(String itemType, String jsonSkuDetails) throws JSONException {
+        mItemType = itemType;
+        mJson = jsonSkuDetails;
+        JSONObject o = new JSONObject(mJson);
+        mSku = o.optString("productId");
+        mType = o.optString("type");
+        mPrice = o.optString("price");
+        mTitle = o.optString("title");
+        mDescription = o.optString("description");
+    }
+
+    public String getSku() { return mSku; }
+    public String getType() { return mType; }
+    public String getPrice() { return mPrice; }
+    public String getTitle() { return mTitle; }
+    public String getDescription() { return mDescription; }
+
+    @Override
+    public String toString() {
+        return "SkuDetails:" + mJson;
+    }
+}
Index: CSipSimple/src/ro/callromania/util/Base64.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Base64.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Base64.java	(working copy)
@@ -0,0 +1,570 @@
+// Portions copyright 2002, Google, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ro.callromania.util;
+
+// This code was converted from code at http://iharder.sourceforge.net/base64/
+// Lots of extraneous features were removed.
+/* The original code said:
+ * <p>
+ * I am placing this code in the Public Domain. Do with it as you will.
+ * This software comes with no guarantees or warranties but with
+ * plenty of well-wishing instead!
+ * Please visit
+ * <a href="http://iharder.net/xmlizable">http://iharder.net/xmlizable</a>
+ * periodically to check for updates or to contribute improvements.
+ * </p>
+ *
+ * @author Robert Harder
+ * @author rharder@usa.net
+ * @version 1.3
+ */
+
+/**
+ * Base64 converter class. This code is not a complete MIME encoder;
+ * it simply converts binary data to base64 data and back.
+ *
+ * <p>Note {@link CharBase64} is a GWT-compatible implementation of this
+ * class.
+ */
+public class Base64 {
+    /** Specify encoding (value is {@code true}). */
+    public final static boolean ENCODE = true;
+
+    /** Specify decoding (value is {@code false}). */
+    public final static boolean DECODE = false;
+
+    /** The equals sign (=) as a byte. */
+    private final static byte EQUALS_SIGN = (byte) '=';
+
+    /** The new line character (\n) as a byte. */
+    private final static byte NEW_LINE = (byte) '\n';
+
+    /**
+     * The 64 valid Base64 values.
+     */
+    private final static byte[] ALPHABET =
+        {(byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
+        (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
+        (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
+        (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
+        (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
+        (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
+        (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',
+        (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
+        (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't',
+        (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y',
+        (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
+        (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
+        (byte) '9', (byte) '+', (byte) '/'};
+
+    /**
+     * The 64 valid web safe Base64 values.
+     */
+    private final static byte[] WEBSAFE_ALPHABET =
+        {(byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
+        (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
+        (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
+        (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
+        (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
+        (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
+        (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',
+        (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
+        (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't',
+        (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y',
+        (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
+        (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
+        (byte) '9', (byte) '-', (byte) '_'};
+
+    /**
+     * Translates a Base64 value to either its 6-bit reconstruction value
+     * or a negative number indicating some other meaning.
+     **/
+    private final static byte[] DECODABET = {-9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
+        -5, -5, // Whitespace: Tab and Linefeed
+        -9, -9, // Decimal 11 - 12
+        -5, // Whitespace: Carriage Return
+        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
+        -9, -9, -9, -9, -9, // Decimal 27 - 31
+        -5, // Whitespace: Space
+        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
+        62, // Plus sign at decimal 43
+        -9, -9, -9, // Decimal 44 - 46
+        63, // Slash at decimal 47
+        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
+        -9, -9, -9, // Decimal 58 - 60
+        -1, // Equals sign at decimal 61
+        -9, -9, -9, // Decimal 62 - 64
+        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
+        14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
+        -9, -9, -9, -9, -9, -9, // Decimal 91 - 96
+        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
+        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
+        -9, -9, -9, -9, -9 // Decimal 123 - 127
+        /*  ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
+    };
+
+    /** The web safe decodabet */
+    private final static byte[] WEBSAFE_DECODABET =
+        {-9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
+        -5, -5, // Whitespace: Tab and Linefeed
+        -9, -9, // Decimal 11 - 12
+        -5, // Whitespace: Carriage Return
+        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
+        -9, -9, -9, -9, -9, // Decimal 27 - 31
+        -5, // Whitespace: Space
+        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 44
+        62, // Dash '-' sign at decimal 45
+        -9, -9, // Decimal 46-47
+        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
+        -9, -9, -9, // Decimal 58 - 60
+        -1, // Equals sign at decimal 61
+        -9, -9, -9, // Decimal 62 - 64
+        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
+        14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
+        -9, -9, -9, -9, // Decimal 91-94
+        63, // Underscore '_' at decimal 95
+        -9, // Decimal 96
+        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
+        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
+        -9, -9, -9, -9, -9 // Decimal 123 - 127
+        /*  ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
+        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
+        };
+
+    // Indicates white space in encoding
+    private final static byte WHITE_SPACE_ENC = -5;
+    // Indicates equals sign in encoding
+    private final static byte EQUALS_SIGN_ENC = -1;
+
+    /** Defeats instantiation. */
+    private Base64() {
+    }
+
+    /* ********  E N C O D I N G   M E T H O D S  ******** */
+
+    /**
+     * Encodes up to three bytes of the array <var>source</var>
+     * and writes the resulting four Base64 bytes to <var>destination</var>.
+     * The source and destination arrays can be manipulated
+     * anywhere along their length by specifying
+     * <var>srcOffset</var> and <var>destOffset</var>.
+     * This method does not check to make sure your arrays
+     * are large enough to accommodate <var>srcOffset</var> + 3 for
+     * the <var>source</var> array or <var>destOffset</var> + 4 for
+     * the <var>destination</var> array.
+     * The actual number of significant bytes in your array is
+     * given by <var>numSigBytes</var>.
+     *
+     * @param source the array to convert
+     * @param srcOffset the index where conversion begins
+     * @param numSigBytes the number of significant bytes in your array
+     * @param destination the array to hold the conversion
+     * @param destOffset the index where output will be put
+     * @param alphabet is the encoding alphabet
+     * @return the <var>destination</var> array
+     * @since 1.3
+     */
+    private static byte[] encode3to4(byte[] source, int srcOffset,
+            int numSigBytes, byte[] destination, int destOffset, byte[] alphabet) {
+        //           1         2         3
+        // 01234567890123456789012345678901 Bit position
+        // --------000000001111111122222222 Array position from threeBytes
+        // --------|    ||    ||    ||    | Six bit groups to index alphabet
+        //          >>18  >>12  >> 6  >> 0  Right shift necessary
+        //                0x3f  0x3f  0x3f  Additional AND
+
+        // Create buffer with zero-padding if there are only one or two
+        // significant bytes passed in the array.
+        // We have to shift left 24 in order to flush out the 1's that appear
+        // when Java treats a value as negative that is cast from a byte to an int.
+        int inBuff =
+                (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0)
+                | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0)
+                | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);
+
+        switch (numSigBytes) {
+            case 3:
+                destination[destOffset] = alphabet[(inBuff >>> 18)];
+                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
+                destination[destOffset + 2] = alphabet[(inBuff >>> 6) & 0x3f];
+                destination[destOffset + 3] = alphabet[(inBuff) & 0x3f];
+                return destination;
+            case 2:
+                destination[destOffset] = alphabet[(inBuff >>> 18)];
+                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
+                destination[destOffset + 2] = alphabet[(inBuff >>> 6) & 0x3f];
+                destination[destOffset + 3] = EQUALS_SIGN;
+                return destination;
+            case 1:
+                destination[destOffset] = alphabet[(inBuff >>> 18)];
+                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
+                destination[destOffset + 2] = EQUALS_SIGN;
+                destination[destOffset + 3] = EQUALS_SIGN;
+                return destination;
+            default:
+                return destination;
+        } // end switch
+    } // end encode3to4
+
+    /**
+     * Encodes a byte array into Base64 notation.
+     * Equivalent to calling
+     * {@code encodeBytes(source, 0, source.length)}
+     *
+     * @param source The data to convert
+     * @since 1.4
+     */
+    public static String encode(byte[] source) {
+        return encode(source, 0, source.length, ALPHABET, true);
+    }
+
+    /**
+     * Encodes a byte array into web safe Base64 notation.
+     *
+     * @param source The data to convert
+     * @param doPadding is {@code true} to pad result with '=' chars
+     *        if it does not fall on 3 byte boundaries
+     */
+    public static String encodeWebSafe(byte[] source, boolean doPadding) {
+        return encode(source, 0, source.length, WEBSAFE_ALPHABET, doPadding);
+    }
+
+    /**
+     * Encodes a byte array into Base64 notation.
+     *
+     * @param source the data to convert
+     * @param off offset in array where conversion should begin
+     * @param len length of data to convert
+     * @param alphabet the encoding alphabet
+     * @param doPadding is {@code true} to pad result with '=' chars
+     * if it does not fall on 3 byte boundaries
+     * @since 1.4
+     */
+    public static String encode(byte[] source, int off, int len, byte[] alphabet,
+            boolean doPadding) {
+        byte[] outBuff = encode(source, off, len, alphabet, Integer.MAX_VALUE);
+        int outLen = outBuff.length;
+
+        // If doPadding is false, set length to truncate '='
+        // padding characters
+        while (doPadding == false && outLen > 0) {
+            if (outBuff[outLen - 1] != '=') {
+                break;
+            }
+            outLen -= 1;
+        }
+
+        return new String(outBuff, 0, outLen);
+    }
+
+    /**
+     * Encodes a byte array into Base64 notation.
+     *
+     * @param source the data to convert
+     * @param off offset in array where conversion should begin
+     * @param len length of data to convert
+     * @param alphabet is the encoding alphabet
+     * @param maxLineLength maximum length of one line.
+     * @return the BASE64-encoded byte array
+     */
+    public static byte[] encode(byte[] source, int off, int len, byte[] alphabet,
+            int maxLineLength) {
+        int lenDiv3 = (len + 2) / 3; // ceil(len / 3)
+        int len43 = lenDiv3 * 4;
+        byte[] outBuff = new byte[len43 // Main 4:3
+                                  + (len43 / maxLineLength)]; // New lines
+
+        int d = 0;
+        int e = 0;
+        int len2 = len - 2;
+        int lineLength = 0;
+        for (; d < len2; d += 3, e += 4) {
+
+            // The following block of code is the same as
+            // encode3to4( source, d + off, 3, outBuff, e, alphabet );
+            // but inlined for faster encoding (~20% improvement)
+            int inBuff =
+                    ((source[d + off] << 24) >>> 8)
+                    | ((source[d + 1 + off] << 24) >>> 16)
+                    | ((source[d + 2 + off] << 24) >>> 24);
+            outBuff[e] = alphabet[(inBuff >>> 18)];
+            outBuff[e + 1] = alphabet[(inBuff >>> 12) & 0x3f];
+            outBuff[e + 2] = alphabet[(inBuff >>> 6) & 0x3f];
+            outBuff[e + 3] = alphabet[(inBuff) & 0x3f];
+
+            lineLength += 4;
+            if (lineLength == maxLineLength) {
+                outBuff[e + 4] = NEW_LINE;
+                e++;
+                lineLength = 0;
+            } // end if: end of line
+        } // end for: each piece of array
+
+        if (d < len) {
+            encode3to4(source, d + off, len - d, outBuff, e, alphabet);
+
+            lineLength += 4;
+            if (lineLength == maxLineLength) {
+                // Add a last newline
+                outBuff[e + 4] = NEW_LINE;
+                e++;
+            }
+            e += 4;
+        }
+
+        assert (e == outBuff.length);
+        return outBuff;
+    }
+
+
+    /* ********  D E C O D I N G   M E T H O D S  ******** */
+
+
+    /**
+     * Decodes four bytes from array <var>source</var>
+     * and writes the resulting bytes (up to three of them)
+     * to <var>destination</var>.
+     * The source and destination arrays can be manipulated
+     * anywhere along their length by specifying
+     * <var>srcOffset</var> and <var>destOffset</var>.
+     * This method does not check to make sure your arrays
+     * are large enough to accommodate <var>srcOffset</var> + 4 for
+     * the <var>source</var> array or <var>destOffset</var> + 3 for
+     * the <var>destination</var> array.
+     * This method returns the actual number of bytes that
+     * were converted from the Base64 encoding.
+     *
+     *
+     * @param source the array to convert
+     * @param srcOffset the index where conversion begins
+     * @param destination the array to hold the conversion
+     * @param destOffset the index where output will be put
+     * @param decodabet the decodabet for decoding Base64 content
+     * @return the number of decoded bytes converted
+     * @since 1.3
+     */
+    private static int decode4to3(byte[] source, int srcOffset,
+            byte[] destination, int destOffset, byte[] decodabet) {
+        // Example: Dk==
+        if (source[srcOffset + 2] == EQUALS_SIGN) {
+            int outBuff =
+                    ((decodabet[source[srcOffset]] << 24) >>> 6)
+                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12);
+
+            destination[destOffset] = (byte) (outBuff >>> 16);
+            return 1;
+        } else if (source[srcOffset + 3] == EQUALS_SIGN) {
+            // Example: DkL=
+            int outBuff =
+                    ((decodabet[source[srcOffset]] << 24) >>> 6)
+                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)
+                    | ((decodabet[source[srcOffset + 2]] << 24) >>> 18);
+
+            destination[destOffset] = (byte) (outBuff >>> 16);
+            destination[destOffset + 1] = (byte) (outBuff >>> 8);
+            return 2;
+        } else {
+            // Example: DkLE
+            int outBuff =
+                    ((decodabet[source[srcOffset]] << 24) >>> 6)
+                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)
+                    | ((decodabet[source[srcOffset + 2]] << 24) >>> 18)
+                    | ((decodabet[source[srcOffset + 3]] << 24) >>> 24);
+
+            destination[destOffset] = (byte) (outBuff >> 16);
+            destination[destOffset + 1] = (byte) (outBuff >> 8);
+            destination[destOffset + 2] = (byte) (outBuff);
+            return 3;
+        }
+    } // end decodeToBytes
+
+
+    /**
+     * Decodes data from Base64 notation.
+     *
+     * @param s the string to decode (decoded in default encoding)
+     * @return the decoded data
+     * @since 1.4
+     */
+    public static byte[] decode(String s) throws Base64DecoderException {
+        byte[] bytes = s.getBytes();
+        return decode(bytes, 0, bytes.length);
+    }
+
+    /**
+     * Decodes data from web safe Base64 notation.
+     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
+     *
+     * @param s the string to decode (decoded in default encoding)
+     * @return the decoded data
+     */
+    public static byte[] decodeWebSafe(String s) throws Base64DecoderException {
+        byte[] bytes = s.getBytes();
+        return decodeWebSafe(bytes, 0, bytes.length);
+    }
+
+    /**
+     * Decodes Base64 content in byte array format and returns
+     * the decoded byte array.
+     *
+     * @param source The Base64 encoded data
+     * @return decoded data
+     * @since 1.3
+     * @throws Base64DecoderException
+     */
+    public static byte[] decode(byte[] source) throws Base64DecoderException {
+        return decode(source, 0, source.length);
+    }
+
+    /**
+     * Decodes web safe Base64 content in byte array format and returns
+     * the decoded data.
+     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
+     *
+     * @param source the string to decode (decoded in default encoding)
+     * @return the decoded data
+     */
+    public static byte[] decodeWebSafe(byte[] source)
+            throws Base64DecoderException {
+        return decodeWebSafe(source, 0, source.length);
+    }
+
+    /**
+     * Decodes Base64 content in byte array format and returns
+     * the decoded byte array.
+     *
+     * @param source the Base64 encoded data
+     * @param off    the offset of where to begin decoding
+     * @param len    the length of characters to decode
+     * @return decoded data
+     * @since 1.3
+     * @throws Base64DecoderException
+     */
+    public static byte[] decode(byte[] source, int off, int len)
+            throws Base64DecoderException {
+        return decode(source, off, len, DECODABET);
+    }
+
+    /**
+     * Decodes web safe Base64 content in byte array format and returns
+     * the decoded byte array.
+     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
+     *
+     * @param source the Base64 encoded data
+     * @param off    the offset of where to begin decoding
+     * @param len    the length of characters to decode
+     * @return decoded data
+     */
+    public static byte[] decodeWebSafe(byte[] source, int off, int len)
+            throws Base64DecoderException {
+        return decode(source, off, len, WEBSAFE_DECODABET);
+    }
+
+    /**
+     * Decodes Base64 content using the supplied decodabet and returns
+     * the decoded byte array.
+     *
+     * @param source the Base64 encoded data
+     * @param off the offset of where to begin decoding
+     * @param len the length of characters to decode
+     * @param decodabet the decodabet for decoding Base64 content
+     * @return decoded data
+     */
+    public static byte[] decode(byte[] source, int off, int len, byte[] decodabet)
+            throws Base64DecoderException {
+        int len34 = len * 3 / 4;
+        byte[] outBuff = new byte[2 + len34]; // Upper limit on size of output
+        int outBuffPosn = 0;
+
+        byte[] b4 = new byte[4];
+        int b4Posn = 0;
+        int i = 0;
+        byte sbiCrop = 0;
+        byte sbiDecode = 0;
+        for (i = 0; i < len; i++) {
+            sbiCrop = (byte) (source[i + off] & 0x7f); // Only the low seven bits
+            sbiDecode = decodabet[sbiCrop];
+
+            if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better
+                if (sbiDecode >= EQUALS_SIGN_ENC) {
+                    // An equals sign (for padding) must not occur at position 0 or 1
+                    // and must be the last byte[s] in the encoded value
+                    if (sbiCrop == EQUALS_SIGN) {
+                        int bytesLeft = len - i;
+                        byte lastByte = (byte) (source[len - 1 + off] & 0x7f);
+                        if (b4Posn == 0 || b4Posn == 1) {
+                            throw new Base64DecoderException(
+                                    "invalid padding byte '=' at byte offset " + i);
+                        } else if ((b4Posn == 3 && bytesLeft > 2)
+                                || (b4Posn == 4 && bytesLeft > 1)) {
+                            throw new Base64DecoderException(
+                                    "padding byte '=' falsely signals end of encoded value "
+                                            + "at offset " + i);
+                        } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {
+                            throw new Base64DecoderException(
+                                    "encoded value has invalid trailing byte");
+                        }
+                        break;
+                    }
+
+                    b4[b4Posn++] = sbiCrop;
+                    if (b4Posn == 4) {
+                        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);
+                        b4Posn = 0;
+                    }
+                }
+            } else {
+                throw new Base64DecoderException("Bad Base64 input character at " + i
+                        + ": " + source[i + off] + "(decimal)");
+            }
+        }
+
+        // Because web safe encoding allows non padding base64 encodes, we
+        // need to pad the rest of the b4 buffer with equal signs when
+        // b4Posn != 0.  There can be at most 2 equal signs at the end of
+        // four characters, so the b4 buffer must have two or three
+        // characters.  This also catches the case where the input is
+        // padded with EQUALS_SIGN
+        if (b4Posn != 0) {
+            if (b4Posn == 1) {
+                throw new Base64DecoderException("single trailing character at offset "
+                        + (len - 1));
+            }
+            b4[b4Posn++] = EQUALS_SIGN;
+            outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);
+        }
+
+        byte[] out = new byte[outBuffPosn];
+        System.arraycopy(outBuff, 0, out, 0, outBuffPosn);
+        return out;
+    }
+}
Index: CSipSimple/src/ro/callromania/util/Base64DecoderException.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Base64DecoderException.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Base64DecoderException.java	(working copy)
@@ -0,0 +1,32 @@
+// Copyright 2002, Google, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package ro.callromania.util;
+
+/**
+ * Exception thrown when encountering an invalid Base64 input character.
+ *
+ * @author nelson
+ */
+public class Base64DecoderException extends Exception {
+    public Base64DecoderException() {
+        super();
+    }
+
+    public Base64DecoderException(String s) {
+        super(s);
+    }
+
+    private static final long serialVersionUID = 1L;
+}
Index: CSipSimple/src/ro/callromania/util/GcmBroadcastReceiver.java
===================================================================
--- CSipSimple/src/ro/callromania/util/GcmBroadcastReceiver.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/GcmBroadcastReceiver.java	(working copy)
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2013 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ro.callromania.util;
+
+import android.app.Activity;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.support.v4.content.WakefulBroadcastReceiver;
+
+
+/**
+ * This {@code WakefulBroadcastReceiver} takes care of creating and managing a
+ * partial wake lock for your app. It passes off the work of processing the GCM
+ * message to an {@code IntentService}, while ensuring that the device does not
+ * go back to sleep in the transition. The {@code IntentService} calls
+ * {@code GcmBroadcastReceiver.completeWakefulIntent()} when it is ready to
+ * release the wake lock.
+ */
+
+public class GcmBroadcastReceiver extends WakefulBroadcastReceiver 
+{
+
+    @Override
+    public void onReceive(Context context, Intent intent) 
+    {
+        // Explicitly specify that GcmIntentService will handle the intent.
+        ComponentName comp = new ComponentName(context.getPackageName(), GcmIntentService.class.getName());
+        // Start the service, keeping the device awake while it is launching.
+        startWakefulService(context, (intent.setComponent(comp)));
+        setResultCode(Activity.RESULT_OK);
+    }
+}
Index: CSipSimple/src/ro/callromania/util/GcmIntentService.java
===================================================================
--- CSipSimple/src/ro/callromania/util/GcmIntentService.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/GcmIntentService.java	(working copy)
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import ro.callromania.R;
+import android.app.IntentService;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.media.RingtoneManager;
+import android.os.Bundle;
+import android.support.v4.app.NotificationCompat;
+
+import com.csipsimple.ui.SipHome;
+import com.google.android.gms.gcm.GoogleCloudMessaging;
+
+/**
+ * This {@code IntentService} does the actual handling of the GCM message.
+ * {@code GcmBroadcastReceiver} (a {@code WakefulBroadcastReceiver}) holds a
+ * partial wake lock for this service while the service does its work. When the
+ * service is finished, it calls {@code completeWakefulIntent()} to release the
+ * wake lock.
+ */
+public class GcmIntentService extends IntentService 
+{
+    public static int NOTIFICATION_ID = 1;
+    private NotificationManager mNotificationManager;
+    NotificationCompat.Builder builder;
+
+    public GcmIntentService() 
+    {
+        super("GcmIntentService");
+    }
+    public static final String TAG = "GCM Demo";
+
+    @Override
+    protected void onHandleIntent(Intent intent) 
+    {
+        Bundle extras = intent.getExtras();
+        GoogleCloudMessaging gcm = GoogleCloudMessaging.getInstance(this);
+        // The getMessageType() intent parameter must be the intent you received
+        // in your BroadcastReceiver.
+        String messageType = gcm.getMessageType(intent);
+
+        if (!extras.isEmpty()) {  // has effect of unparcelling Bundle
+            /*
+             * Filter messages based on message type. Since it is likely that GCM will be
+             * extended in the future with new message types, just ignore any message types you're
+             * not interested in, or that you don't recognize.
+             */
+            if (GoogleCloudMessaging.MESSAGE_TYPE_SEND_ERROR.equals(messageType)) 
+            {
+            	//TODO: really ceck this out
+//                sendNotification("Send error: " + extras.toString());
+            }
+            else if (GoogleCloudMessaging.MESSAGE_TYPE_DELETED.equals(messageType)) 
+            {
+            	//TODO: really ceck this out
+//                sendNotification("Deleted messages on server: " + extras.toString());
+            // If it's a regular GCM message, do some work.
+            } 
+            else if (GoogleCloudMessaging.MESSAGE_TYPE_MESSAGE.equals(messageType)) 
+            {
+                // This loop represents the service doing some work.
+//                for (int i = 0; i < 5; i++) 
+//                {
+//                    Log.i(TAG, "Working... " + (i + 1)
+//                            + "/5 @ " + SystemClock.elapsedRealtime());
+//                    try {
+//                        Thread.sleep(5000);
+//                    } catch (InterruptedException e) {
+//                    }
+//                }
+//                Log.i(TAG, "Completed work @ " + SystemClock.elapsedRealtime());
+            	
+                // Post notification of received message.
+                sendNotification(extras);
+//                Log.i(TAG, "Received: " + extras.toString());
+            }
+        }
+        // Release the wake lock provided by the WakefulBroadcastReceiver.
+        GcmBroadcastReceiver.completeWakefulIntent(intent);
+    }
+
+    // Put the message into a notification and post it.
+    // This is just one simple example of what you might choose to do with
+    // a GCM message.
+    private void sendNotification(Bundle msg) 
+    {    	
+        mNotificationManager = (NotificationManager) this.getSystemService(Context.NOTIFICATION_SERVICE);
+
+        PendingIntent contentIntent = PendingIntent.getActivity(this, 0, new Intent(this, SipHome.class), PendingIntent.FLAG_UPDATE_CURRENT);
+        
+        String title = msg.getString("title");
+        if (title == null) title = "CallRomania";
+        
+        String subtitle = msg.getString("subtitle");
+        if (subtitle == null) subtitle = "";
+
+        String message = msg.getString("message");
+        if (message == null) message = "";
+        
+        String tickerText = msg.getString("tickerText");
+        if (tickerText == null) tickerText = title;
+
+        NotificationCompat.Builder mBuilder = 
+        		new NotificationCompat.Builder(this)
+			        .setSmallIcon(R.drawable.ic_wizard_callromania)
+			        .setContentTitle(title)
+//			        .setStyle(new NotificationCompat.BigTextStyle()
+//			        .bigText(message))
+//			        .setContentText(subtitle)
+			        .setContentText(message)
+			        .setAutoCancel(true)
+			        .setSound(RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION))
+			        .setTicker(tickerText);
+
+        mBuilder.setContentIntent(contentIntent);
+        mNotificationManager.notify(NOTIFICATION_ID++, mBuilder.build());
+    }
+}
Index: CSipSimple/src/ro/callromania/util/IabException.java
===================================================================
--- CSipSimple/src/ro/callromania/util/IabException.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/IabException.java	(working copy)
@@ -0,0 +1,43 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+/**
+ * Exception thrown when something went wrong with in-app billing.
+ * An IabException has an associated IabResult (an error).
+ * To get the IAB result that caused this exception to be thrown,
+ * call {@link #getResult()}.
+ */
+public class IabException extends Exception {
+    IabResult mResult;
+
+    public IabException(IabResult r) {
+        this(r, null);
+    }
+    public IabException(int response, String message) {
+        this(new IabResult(response, message));
+    }
+    public IabException(IabResult r, Exception cause) {
+        super(r.getMessage(), cause);
+        mResult = r;
+    }
+    public IabException(int response, String message, Exception cause) {
+        this(new IabResult(response, message), cause);
+    }
+
+    /** Returns the IAB result (error) that this exception signals. */
+    public IabResult getResult() { return mResult; }
+}
\ No newline at end of file
Index: CSipSimple/src/ro/callromania/util/IabHelper.java
===================================================================
--- CSipSimple/src/ro/callromania/util/IabHelper.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/IabHelper.java	(working copy)
@@ -0,0 +1,991 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import android.app.Activity;
+import android.app.PendingIntent;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentSender.SendIntentException;
+import android.content.ServiceConnection;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.android.vending.billing.IInAppBillingService;
+
+import org.json.JSONException;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * Provides convenience methods for in-app billing. You can create one instance of this
+ * class for your application and use it to process in-app billing operations.
+ * It provides synchronous (blocking) and asynchronous (non-blocking) methods for
+ * many common in-app billing operations, as well as automatic signature
+ * verification.
+ *
+ * After instantiating, you must perform setup in order to start using the object.
+ * To perform setup, call the {@link #startSetup} method and provide a listener;
+ * that listener will be notified when setup is complete, after which (and not before)
+ * you may call other methods.
+ *
+ * After setup is complete, you will typically want to request an inventory of owned
+ * items and subscriptions. See {@link #queryInventory}, {@link #queryInventoryAsync}
+ * and related methods.
+ *
+ * When you are done with this object, don't forget to call {@link #dispose}
+ * to ensure proper cleanup. This object holds a binding to the in-app billing
+ * service, which will leak unless you dispose of it correctly. If you created
+ * the object on an Activity's onCreate method, then the recommended
+ * place to dispose of it is the Activity's onDestroy method.
+ *
+ * A note about threading: When using this object from a background thread, you may
+ * call the blocking versions of methods; when using from a UI thread, call
+ * only the asynchronous versions and handle the results via callbacks.
+ * Also, notice that you can only call one asynchronous operation at a time;
+ * attempting to start a second asynchronous operation while the first one
+ * has not yet completed will result in an exception being thrown.
+ *
+ * @author Bruno Oliveira (Google)
+ *
+ */
+public class IabHelper {
+    // Is debug logging enabled?
+    boolean mDebugLog = false;
+    String mDebugTag = "IabHelper";
+
+    // Is setup done?
+    boolean mSetupDone = false;
+
+    // Has this object been disposed of? (If so, we should ignore callbacks, etc)
+    boolean mDisposed = false;
+
+    // Are subscriptions supported?
+    boolean mSubscriptionsSupported = false;
+
+    // Is an asynchronous operation in progress?
+    // (only one at a time can be in progress)
+    boolean mAsyncInProgress = false;
+
+    // (for logging/debugging)
+    // if mAsyncInProgress == true, what asynchronous operation is in progress?
+    String mAsyncOperation = "";
+
+    // Context we were passed during initialization
+    Context mContext;
+
+    // Connection to the service
+    IInAppBillingService mService;
+    ServiceConnection mServiceConn;
+
+    // The request code used to launch purchase flow
+    int mRequestCode;
+
+    // The item type of the current purchase flow
+    String mPurchasingItemType;
+
+    // Public key for verifying signature, in base64 encoding
+    String mSignatureBase64 = null;
+
+    // Billing response codes
+    public static final int BILLING_RESPONSE_RESULT_OK = 0;
+    public static final int BILLING_RESPONSE_RESULT_USER_CANCELED = 1;
+    public static final int BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE = 3;
+    public static final int BILLING_RESPONSE_RESULT_ITEM_UNAVAILABLE = 4;
+    public static final int BILLING_RESPONSE_RESULT_DEVELOPER_ERROR = 5;
+    public static final int BILLING_RESPONSE_RESULT_ERROR = 6;
+    public static final int BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED = 7;
+    public static final int BILLING_RESPONSE_RESULT_ITEM_NOT_OWNED = 8;
+
+    // IAB Helper error codes
+    public static final int IABHELPER_ERROR_BASE = -1000;
+    public static final int IABHELPER_REMOTE_EXCEPTION = -1001;
+    public static final int IABHELPER_BAD_RESPONSE = -1002;
+    public static final int IABHELPER_VERIFICATION_FAILED = -1003;
+    public static final int IABHELPER_SEND_INTENT_FAILED = -1004;
+    public static final int IABHELPER_USER_CANCELLED = -1005;
+    public static final int IABHELPER_UNKNOWN_PURCHASE_RESPONSE = -1006;
+    public static final int IABHELPER_MISSING_TOKEN = -1007;
+    public static final int IABHELPER_UNKNOWN_ERROR = -1008;
+    public static final int IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE = -1009;
+    public static final int IABHELPER_INVALID_CONSUMPTION = -1010;
+
+    // Keys for the responses from InAppBillingService
+    public static final String RESPONSE_CODE = "RESPONSE_CODE";
+    public static final String RESPONSE_GET_SKU_DETAILS_LIST = "DETAILS_LIST";
+    public static final String RESPONSE_BUY_INTENT = "BUY_INTENT";
+    public static final String RESPONSE_INAPP_PURCHASE_DATA = "INAPP_PURCHASE_DATA";
+    public static final String RESPONSE_INAPP_SIGNATURE = "INAPP_DATA_SIGNATURE";
+    public static final String RESPONSE_INAPP_ITEM_LIST = "INAPP_PURCHASE_ITEM_LIST";
+    public static final String RESPONSE_INAPP_PURCHASE_DATA_LIST = "INAPP_PURCHASE_DATA_LIST";
+    public static final String RESPONSE_INAPP_SIGNATURE_LIST = "INAPP_DATA_SIGNATURE_LIST";
+    public static final String INAPP_CONTINUATION_TOKEN = "INAPP_CONTINUATION_TOKEN";
+
+    // Item types
+    public static final String ITEM_TYPE_INAPP = "inapp";
+    public static final String ITEM_TYPE_SUBS = "subs";
+
+    // some fields on the getSkuDetails response bundle
+    public static final String GET_SKU_DETAILS_ITEM_LIST = "ITEM_ID_LIST";
+    public static final String GET_SKU_DETAILS_ITEM_TYPE_LIST = "ITEM_TYPE_LIST";
+
+    /**
+     * Creates an instance. After creation, it will not yet be ready to use. You must perform
+     * setup by calling {@link #startSetup} and wait for setup to complete. This constructor does not
+     * block and is safe to call from a UI thread.
+     *
+     * @param ctx Your application or Activity context. Needed to bind to the in-app billing service.
+     * @param base64PublicKey Your application's public key, encoded in base64.
+     *     This is used for verification of purchase signatures. You can find your app's base64-encoded
+     *     public key in your application's page on Google Play Developer Console. Note that this
+     *     is NOT your "developer public key".
+     */
+    public IabHelper(Context ctx, String base64PublicKey) {
+        mContext = ctx.getApplicationContext();
+        mSignatureBase64 = base64PublicKey;
+        logDebug("IAB helper created.");
+    }
+
+    /**
+     * Enables or disable debug logging through LogCat.
+     */
+    public void enableDebugLogging(boolean enable, String tag) {
+        checkNotDisposed();
+        mDebugLog = enable;
+        mDebugTag = tag;
+    }
+
+    public void enableDebugLogging(boolean enable) {
+        checkNotDisposed();
+        mDebugLog = enable;
+    }
+
+    /**
+     * Callback for setup process. This listener's {@link #onIabSetupFinished} method is called
+     * when the setup process is complete.
+     */
+    public interface OnIabSetupFinishedListener {
+        /**
+         * Called to notify that setup is complete.
+         *
+         * @param result The result of the setup process.
+         */
+        public void onIabSetupFinished(IabResult result);
+    }
+
+    /**
+     * Starts the setup process. This will start up the setup process asynchronously.
+     * You will be notified through the listener when the setup process is complete.
+     * This method is safe to call from a UI thread.
+     *
+     * @param listener The listener to notify when the setup process is complete.
+     */
+    public void startSetup(final OnIabSetupFinishedListener listener) {
+        // If already set up, can't do it again.
+        checkNotDisposed();
+        if (mSetupDone) throw new IllegalStateException("IAB helper is already set up.");
+
+        // Connection to IAB service
+        logDebug("Starting in-app billing setup.");
+        mServiceConn = new ServiceConnection() {
+            @Override
+            public void onServiceDisconnected(ComponentName name) {
+                logDebug("Billing service disconnected.");
+                mService = null;
+            }
+
+            @Override
+            public void onServiceConnected(ComponentName name, IBinder service) {
+                if (mDisposed) return;
+                logDebug("Billing service connected.");
+                mService = IInAppBillingService.Stub.asInterface(service);
+                String packageName = mContext.getPackageName();
+                try {
+                    logDebug("Checking for in-app billing 3 support.");
+
+                    // check for in-app billing v3 support
+                    int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);
+                    if (response != BILLING_RESPONSE_RESULT_OK) {
+                        if (listener != null) listener.onIabSetupFinished(new IabResult(response,
+                                "Error checking for billing v3 support."));
+
+                        // if in-app purchases aren't supported, neither are subscriptions.
+                        mSubscriptionsSupported = false;
+                        return;
+                    }
+                    logDebug("In-app billing version 3 supported for " + packageName);
+
+                    // check for v3 subscriptions support
+                    response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);
+                    if (response == BILLING_RESPONSE_RESULT_OK) {
+                        logDebug("Subscriptions AVAILABLE.");
+                        mSubscriptionsSupported = true;
+                    }
+                    else {
+                        logDebug("Subscriptions NOT AVAILABLE. Response: " + response);
+                    }
+
+                    mSetupDone = true;
+                }
+                catch (RemoteException e) {
+                    if (listener != null) {
+                        listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION,
+                                                    "RemoteException while setting up in-app billing."));
+                    }
+                    e.printStackTrace();
+                    return;
+                }
+
+                if (listener != null) {
+                    listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Setup successful."));
+                }
+            }
+        };
+
+        Intent serviceIntent = new Intent("com.android.vending.billing.InAppBillingService.BIND");
+        serviceIntent.setPackage("com.android.vending");
+        if (!mContext.getPackageManager().queryIntentServices(serviceIntent, 0).isEmpty()) {
+            // service available to handle that Intent
+            mContext.bindService(serviceIntent, mServiceConn, Context.BIND_AUTO_CREATE);
+        }
+        else {
+            // no service available to handle that Intent
+            if (listener != null) {
+                listener.onIabSetupFinished(
+                        new IabResult(BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE,
+                        "Billing service unavailable on device."));
+            }
+        }
+    }
+
+    /**
+     * Dispose of object, releasing resources. It's very important to call this
+     * method when you are done with this object. It will release any resources
+     * used by it such as service connections. Naturally, once the object is
+     * disposed of, it can't be used again.
+     */
+    public void dispose() {
+        logDebug("Disposing.");
+        mSetupDone = false;
+        if (mServiceConn != null) {
+            logDebug("Unbinding from service.");
+            if (mContext != null) mContext.unbindService(mServiceConn);
+        }
+        mDisposed = true;
+        mContext = null;
+        mServiceConn = null;
+        mService = null;
+        mPurchaseListener = null;
+    }
+
+    private void checkNotDisposed() {
+        if (mDisposed) throw new IllegalStateException("IabHelper was disposed of, so it cannot be used.");
+    }
+
+    /** Returns whether subscriptions are supported. */
+    public boolean subscriptionsSupported() {
+        checkNotDisposed();
+        return mSubscriptionsSupported;
+    }
+
+
+    /**
+     * Callback that notifies when a purchase is finished.
+     */
+    public interface OnIabPurchaseFinishedListener {
+        /**
+         * Called to notify that an in-app purchase finished. If the purchase was successful,
+         * then the sku parameter specifies which item was purchased. If the purchase failed,
+         * the sku and extraData parameters may or may not be null, depending on how far the purchase
+         * process went.
+         *
+         * @param result The result of the purchase.
+         * @param info The purchase information (null if purchase failed)
+         */
+        public void onIabPurchaseFinished(IabResult result, Purchase info);
+    }
+
+    // The listener registered on launchPurchaseFlow, which we have to call back when
+    // the purchase finishes
+    OnIabPurchaseFinishedListener mPurchaseListener;
+
+    public void launchPurchaseFlow(Activity act, String sku, int requestCode, OnIabPurchaseFinishedListener listener) {
+        launchPurchaseFlow(act, sku, requestCode, listener, "");
+    }
+
+    public void launchPurchaseFlow(Activity act, String sku, int requestCode,
+            OnIabPurchaseFinishedListener listener, String extraData) {
+        launchPurchaseFlow(act, sku, ITEM_TYPE_INAPP, requestCode, listener, extraData);
+    }
+
+    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
+            OnIabPurchaseFinishedListener listener) {
+        launchSubscriptionPurchaseFlow(act, sku, requestCode, listener, "");
+    }
+
+    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
+            OnIabPurchaseFinishedListener listener, String extraData) {
+        launchPurchaseFlow(act, sku, ITEM_TYPE_SUBS, requestCode, listener, extraData);
+    }
+
+    /**
+     * Initiate the UI flow for an in-app purchase. Call this method to initiate an in-app purchase,
+     * which will involve bringing up the Google Play screen. The calling activity will be paused while
+     * the user interacts with Google Play, and the result will be delivered via the activity's
+     * {@link android.app.Activity#onActivityResult} method, at which point you must call
+     * this object's {@link #handleActivityResult} method to continue the purchase flow. This method
+     * MUST be called from the UI thread of the Activity.
+     *
+     * @param act The calling activity.
+     * @param sku The sku of the item to purchase.
+     * @param itemType indicates if it's a product or a subscription (ITEM_TYPE_INAPP or ITEM_TYPE_SUBS)
+     * @param requestCode A request code (to differentiate from other responses --
+     *     as in {@link android.app.Activity#startActivityForResult}).
+     * @param listener The listener to notify when the purchase process finishes
+     * @param extraData Extra data (developer payload), which will be returned with the purchase data
+     *     when the purchase completes. This extra data will be permanently bound to that purchase
+     *     and will always be returned when the purchase is queried.
+     */
+    public void launchPurchaseFlow(Activity act, String sku, String itemType, int requestCode,
+                        OnIabPurchaseFinishedListener listener, String extraData) {
+        checkNotDisposed();
+        checkSetupDone("launchPurchaseFlow");
+        flagStartAsync("launchPurchaseFlow");
+        IabResult result;
+
+        if (itemType.equals(ITEM_TYPE_SUBS) && !mSubscriptionsSupported) {
+            IabResult r = new IabResult(IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE,
+                    "Subscriptions are not available.");
+            flagEndAsync();
+            if (listener != null) listener.onIabPurchaseFinished(r, null);
+            return;
+        }
+
+        try {
+            logDebug("Constructing buy intent for " + sku + ", item type: " + itemType);
+            Bundle buyIntentBundle = mService.getBuyIntent(3, mContext.getPackageName(), sku, itemType, extraData);
+            int response = getResponseCodeFromBundle(buyIntentBundle);
+            if (response != BILLING_RESPONSE_RESULT_OK) {
+                logError("Unable to buy item, Error response: " + getResponseDesc(response));
+                flagEndAsync();
+                result = new IabResult(response, "Unable to buy item");
+                if (listener != null) listener.onIabPurchaseFinished(result, null);
+                return;
+            }
+
+            PendingIntent pendingIntent = buyIntentBundle.getParcelable(RESPONSE_BUY_INTENT);
+            logDebug("Launching buy intent for " + sku + ". Request code: " + requestCode);
+            mRequestCode = requestCode;
+            mPurchaseListener = listener;
+            mPurchasingItemType = itemType;
+            act.startIntentSenderForResult(pendingIntent.getIntentSender(),
+                                           requestCode, new Intent(),
+                                           Integer.valueOf(0), Integer.valueOf(0),
+                                           Integer.valueOf(0));
+        }
+        catch (SendIntentException e) {
+            logError("SendIntentException while launching purchase flow for sku " + sku);
+            e.printStackTrace();
+            flagEndAsync();
+
+            result = new IabResult(IABHELPER_SEND_INTENT_FAILED, "Failed to send intent.");
+            if (listener != null) listener.onIabPurchaseFinished(result, null);
+        }
+        catch (RemoteException e) {
+            logError("RemoteException while launching purchase flow for sku " + sku);
+            e.printStackTrace();
+            flagEndAsync();
+
+            result = new IabResult(IABHELPER_REMOTE_EXCEPTION, "Remote exception while starting purchase flow");
+            if (listener != null) listener.onIabPurchaseFinished(result, null);
+        }
+    }
+
+    /**
+     * Handles an activity result that's part of the purchase flow in in-app billing. If you
+     * are calling {@link #launchPurchaseFlow}, then you must call this method from your
+     * Activity's {@link android.app.Activity@onActivityResult} method. This method
+     * MUST be called from the UI thread of the Activity.
+     *
+     * @param requestCode The requestCode as you received it.
+     * @param resultCode The resultCode as you received it.
+     * @param data The data (Intent) as you received it.
+     * @return Returns true if the result was related to a purchase flow and was handled;
+     *     false if the result was not related to a purchase, in which case you should
+     *     handle it normally.
+     */
+    public boolean handleActivityResult(int requestCode, int resultCode, Intent data) {
+        IabResult result;
+        if (requestCode != mRequestCode) return false;
+
+        checkNotDisposed();
+        checkSetupDone("handleActivityResult");
+
+        // end of async purchase operation that started on launchPurchaseFlow
+        flagEndAsync();
+
+        if (data == null) {
+            logError("Null data in IAB activity result.");
+            result = new IabResult(IABHELPER_BAD_RESPONSE, "Null data in IAB result");
+            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+            return true;
+        }
+
+        int responseCode = getResponseCodeFromIntent(data);
+        String purchaseData = data.getStringExtra(RESPONSE_INAPP_PURCHASE_DATA);
+        String dataSignature = data.getStringExtra(RESPONSE_INAPP_SIGNATURE);
+
+        if (resultCode == Activity.RESULT_OK && responseCode == BILLING_RESPONSE_RESULT_OK) {
+            logDebug("Successful resultcode from purchase activity.");
+            logDebug("Purchase data: " + purchaseData);
+            logDebug("Data signature: " + dataSignature);
+            logDebug("Extras: " + data.getExtras());
+            logDebug("Expected item type: " + mPurchasingItemType);
+
+            if (purchaseData == null || dataSignature == null) {
+                logError("BUG: either purchaseData or dataSignature is null.");
+                logDebug("Extras: " + data.getExtras().toString());
+                result = new IabResult(IABHELPER_UNKNOWN_ERROR, "IAB returned null purchaseData or dataSignature");
+                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+                return true;
+            }
+
+            Purchase purchase = null;
+            try {
+                purchase = new Purchase(mPurchasingItemType, purchaseData, dataSignature);
+                String sku = purchase.getSku();
+
+                // Verify signature
+                if (!Security.verifyPurchase(mSignatureBase64, purchaseData, dataSignature)) {
+                    logError("Purchase signature verification FAILED for sku " + sku);
+                    result = new IabResult(IABHELPER_VERIFICATION_FAILED, "Signature verification failed for sku " + sku);
+                    if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, purchase);
+                    return true;
+                }
+                logDebug("Purchase signature successfully verified.");
+            }
+            catch (JSONException e) {
+                logError("Failed to parse purchase data.");
+                e.printStackTrace();
+                result = new IabResult(IABHELPER_BAD_RESPONSE, "Failed to parse purchase data.");
+                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+                return true;
+            }
+
+            if (mPurchaseListener != null) {
+                mPurchaseListener.onIabPurchaseFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Success"), purchase);
+            }
+        }
+        else if (resultCode == Activity.RESULT_OK) {
+            // result code was OK, but in-app billing response was not OK.
+            logDebug("Result code was OK but in-app billing response was not OK: " + getResponseDesc(responseCode));
+            if (mPurchaseListener != null) {
+                result = new IabResult(responseCode, "Problem purchashing item.");
+                mPurchaseListener.onIabPurchaseFinished(result, null);
+            }
+        }
+        else if (resultCode == Activity.RESULT_CANCELED) {
+            logDebug("Purchase canceled - Response: " + getResponseDesc(responseCode));
+            result = new IabResult(IABHELPER_USER_CANCELLED, "User canceled.");
+            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+        }
+        else {
+            logError("Purchase failed. Result code: " + Integer.toString(resultCode)
+                    + ". Response: " + getResponseDesc(responseCode));
+            result = new IabResult(IABHELPER_UNKNOWN_PURCHASE_RESPONSE, "Unknown purchase response.");
+            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+        }
+        return true;
+    }
+
+    public Inventory queryInventory(boolean querySkuDetails, List<String> moreSkus) throws IabException {
+        return queryInventory(querySkuDetails, moreSkus, null);
+    }
+
+    /**
+     * Queries the inventory. This will query all owned items from the server, as well as
+     * information on additional skus, if specified. This method may block or take long to execute.
+     * Do not call from a UI thread. For that, use the non-blocking version {@link #refreshInventoryAsync}.
+     *
+     * @param querySkuDetails if true, SKU details (price, description, etc) will be queried as well
+     *     as purchase information.
+     * @param moreItemSkus additional PRODUCT skus to query information on, regardless of ownership.
+     *     Ignored if null or if querySkuDetails is false.
+     * @param moreSubsSkus additional SUBSCRIPTIONS skus to query information on, regardless of ownership.
+     *     Ignored if null or if querySkuDetails is false.
+     * @throws IabException if a problem occurs while refreshing the inventory.
+     */
+    public Inventory queryInventory(boolean querySkuDetails, List<String> moreItemSkus,
+                                        List<String> moreSubsSkus) throws IabException {
+        checkNotDisposed();
+        checkSetupDone("queryInventory");
+        try {
+            Inventory inv = new Inventory();
+            int r = queryPurchases(inv, ITEM_TYPE_INAPP);
+            if (r != BILLING_RESPONSE_RESULT_OK) {
+                throw new IabException(r, "Error refreshing inventory (querying owned items).");
+            }
+
+            if (querySkuDetails) {
+                r = querySkuDetails(ITEM_TYPE_INAPP, inv, moreItemSkus);
+                if (r != BILLING_RESPONSE_RESULT_OK) {
+                    throw new IabException(r, "Error refreshing inventory (querying prices of items).");
+                }
+            }
+
+            // if subscriptions are supported, then also query for subscriptions
+            if (mSubscriptionsSupported) {
+                r = queryPurchases(inv, ITEM_TYPE_SUBS);
+                if (r != BILLING_RESPONSE_RESULT_OK) {
+                    throw new IabException(r, "Error refreshing inventory (querying owned subscriptions).");
+                }
+
+                if (querySkuDetails) {
+                    r = querySkuDetails(ITEM_TYPE_SUBS, inv, moreItemSkus);
+                    if (r != BILLING_RESPONSE_RESULT_OK) {
+                        throw new IabException(r, "Error refreshing inventory (querying prices of subscriptions).");
+                    }
+                }
+            }
+
+            return inv;
+        }
+        catch (RemoteException e) {
+            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while refreshing inventory.", e);
+        }
+        catch (JSONException e) {
+            throw new IabException(IABHELPER_BAD_RESPONSE, "Error parsing JSON response while refreshing inventory.", e);
+        }
+    }
+
+    /**
+     * Listener that notifies when an inventory query operation completes.
+     */
+    public interface QueryInventoryFinishedListener {
+        /**
+         * Called to notify that an inventory query operation completed.
+         *
+         * @param result The result of the operation.
+         * @param inv The inventory.
+         */
+        public void onQueryInventoryFinished(IabResult result, Inventory inv);
+    }
+
+
+    /**
+     * Asynchronous wrapper for inventory query. This will perform an inventory
+     * query as described in {@link #queryInventory}, but will do so asynchronously
+     * and call back the specified listener upon completion. This method is safe to
+     * call from a UI thread.
+     *
+     * @param querySkuDetails as in {@link #queryInventory}
+     * @param moreSkus as in {@link #queryInventory}
+     * @param listener The listener to notify when the refresh operation completes.
+     */
+    public void queryInventoryAsync(final boolean querySkuDetails,
+                               final List<String> moreSkus,
+                               final QueryInventoryFinishedListener listener) {
+        final Handler handler = new Handler();
+        checkNotDisposed();
+        checkSetupDone("queryInventory");
+        flagStartAsync("refresh inventory");
+        (new Thread(new Runnable() {
+            public void run() {
+                IabResult result = new IabResult(BILLING_RESPONSE_RESULT_OK, "Inventory refresh successful.");
+                Inventory inv = null;
+                try {
+                    inv = queryInventory(querySkuDetails, moreSkus);
+                }
+                catch (IabException ex) {
+                    result = ex.getResult();
+                }
+
+                flagEndAsync();
+
+                final IabResult result_f = result;
+                final Inventory inv_f = inv;
+                if (!mDisposed && listener != null) {
+                    handler.post(new Runnable() {
+                        public void run() {
+                            listener.onQueryInventoryFinished(result_f, inv_f);
+                        }
+                    });
+                }
+            }
+        })).start();
+    }
+
+    public void queryInventoryAsync(QueryInventoryFinishedListener listener) {
+        queryInventoryAsync(true, null, listener);
+    }
+
+    public void queryInventoryAsync(boolean querySkuDetails, QueryInventoryFinishedListener listener) {
+        queryInventoryAsync(querySkuDetails, null, listener);
+    }
+
+
+    /**
+     * Consumes a given in-app product. Consuming can only be done on an item
+     * that's owned, and as a result of consumption, the user will no longer own it.
+     * This method may block or take long to return. Do not call from the UI thread.
+     * For that, see {@link #consumeAsync}.
+     *
+     * @param itemInfo The PurchaseInfo that represents the item to consume.
+     * @throws IabException if there is a problem during consumption.
+     */
+    void consume(Purchase itemInfo) throws IabException {
+        checkNotDisposed();
+        checkSetupDone("consume");
+
+        if (!itemInfo.mItemType.equals(ITEM_TYPE_INAPP)) {
+            throw new IabException(IABHELPER_INVALID_CONSUMPTION,
+                    "Items of type '" + itemInfo.mItemType + "' can't be consumed.");
+        }
+
+        try {
+            String token = itemInfo.getToken();
+            String sku = itemInfo.getSku();
+            if (token == null || token.equals("")) {
+               logError("Can't consume "+ sku + ". No token.");
+               throw new IabException(IABHELPER_MISSING_TOKEN, "PurchaseInfo is missing token for sku: "
+                   + sku + " " + itemInfo);
+            }
+
+            logDebug("Consuming sku: " + sku + ", token: " + token);
+            int response = mService.consumePurchase(3, mContext.getPackageName(), token);
+            if (response == BILLING_RESPONSE_RESULT_OK) {
+               logDebug("Successfully consumed sku: " + sku);
+            }
+            else {
+               logDebug("Error consuming consuming sku " + sku + ". " + getResponseDesc(response));
+               throw new IabException(response, "Error consuming sku " + sku);
+            }
+        }
+        catch (RemoteException e) {
+            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while consuming. PurchaseInfo: " + itemInfo, e);
+        }
+    }
+
+    /**
+     * Callback that notifies when a consumption operation finishes.
+     */
+    public interface OnConsumeFinishedListener {
+        /**
+         * Called to notify that a consumption has finished.
+         *
+         * @param purchase The purchase that was (or was to be) consumed.
+         * @param result The result of the consumption operation.
+         */
+        public void onConsumeFinished(Purchase purchase, IabResult result);
+    }
+
+    /**
+     * Callback that notifies when a multi-item consumption operation finishes.
+     */
+    public interface OnConsumeMultiFinishedListener {
+        /**
+         * Called to notify that a consumption of multiple items has finished.
+         *
+         * @param purchases The purchases that were (or were to be) consumed.
+         * @param results The results of each consumption operation, corresponding to each
+         *     sku.
+         */
+        public void onConsumeMultiFinished(List<Purchase> purchases, List<IabResult> results);
+    }
+
+    /**
+     * Asynchronous wrapper to item consumption. Works like {@link #consume}, but
+     * performs the consumption in the background and notifies completion through
+     * the provided listener. This method is safe to call from a UI thread.
+     *
+     * @param purchase The purchase to be consumed.
+     * @param listener The listener to notify when the consumption operation finishes.
+     */
+    public void consumeAsync(Purchase purchase, OnConsumeFinishedListener listener) {
+        checkNotDisposed();
+        checkSetupDone("consume");
+        List<Purchase> purchases = new ArrayList<Purchase>();
+        purchases.add(purchase);
+        consumeAsyncInternal(purchases, listener, null);
+    }
+
+    /**
+     * Same as {@link consumeAsync}, but for multiple items at once.
+     * @param purchases The list of PurchaseInfo objects representing the purchases to consume.
+     * @param listener The listener to notify when the consumption operation finishes.
+     */
+    public void consumeAsync(List<Purchase> purchases, OnConsumeMultiFinishedListener listener) {
+        checkNotDisposed();
+        checkSetupDone("consume");
+        consumeAsyncInternal(purchases, null, listener);
+    }
+
+    /**
+     * Returns a human-readable description for the given response code.
+     *
+     * @param code The response code
+     * @return A human-readable string explaining the result code.
+     *     It also includes the result code numerically.
+     */
+    public static String getResponseDesc(int code) {
+        String[] iab_msgs = ("0:OK/1:User Canceled/2:Unknown/" +
+                "3:Billing Unavailable/4:Item unavailable/" +
+                "5:Developer Error/6:Error/7:Item Already Owned/" +
+                "8:Item not owned").split("/");
+        String[] iabhelper_msgs = ("0:OK/-1001:Remote exception during initialization/" +
+                                   "-1002:Bad response received/" +
+                                   "-1003:Purchase signature verification failed/" +
+                                   "-1004:Send intent failed/" +
+                                   "-1005:User cancelled/" +
+                                   "-1006:Unknown purchase response/" +
+                                   "-1007:Missing token/" +
+                                   "-1008:Unknown error/" +
+                                   "-1009:Subscriptions not available/" +
+                                   "-1010:Invalid consumption attempt").split("/");
+
+        if (code <= IABHELPER_ERROR_BASE) {
+            int index = IABHELPER_ERROR_BASE - code;
+            if (index >= 0 && index < iabhelper_msgs.length) return iabhelper_msgs[index];
+            else return String.valueOf(code) + ":Unknown IAB Helper Error";
+        }
+        else if (code < 0 || code >= iab_msgs.length)
+            return String.valueOf(code) + ":Unknown";
+        else
+            return iab_msgs[code];
+    }
+
+
+    // Checks that setup was done; if not, throws an exception.
+    void checkSetupDone(String operation) {
+        if (!mSetupDone) {
+            logError("Illegal state for operation (" + operation + "): IAB helper is not set up.");
+            throw new IllegalStateException("IAB helper is not set up. Can't perform operation: " + operation);
+        }
+    }
+
+    // Workaround to bug where sometimes response codes come as Long instead of Integer
+    int getResponseCodeFromBundle(Bundle b) {
+        Object o = b.get(RESPONSE_CODE);
+        if (o == null) {
+            logDebug("Bundle with null response code, assuming OK (known issue)");
+            return BILLING_RESPONSE_RESULT_OK;
+        }
+        else if (o instanceof Integer) return ((Integer)o).intValue();
+        else if (o instanceof Long) return (int)((Long)o).longValue();
+        else {
+            logError("Unexpected type for bundle response code.");
+            logError(o.getClass().getName());
+            throw new RuntimeException("Unexpected type for bundle response code: " + o.getClass().getName());
+        }
+    }
+
+    // Workaround to bug where sometimes response codes come as Long instead of Integer
+    int getResponseCodeFromIntent(Intent i) {
+        Object o = i.getExtras().get(RESPONSE_CODE);
+        if (o == null) {
+            logError("Intent with no response code, assuming OK (known issue)");
+            return BILLING_RESPONSE_RESULT_OK;
+        }
+        else if (o instanceof Integer) return ((Integer)o).intValue();
+        else if (o instanceof Long) return (int)((Long)o).longValue();
+        else {
+            logError("Unexpected type for intent response code.");
+            logError(o.getClass().getName());
+            throw new RuntimeException("Unexpected type for intent response code: " + o.getClass().getName());
+        }
+    }
+
+    void flagStartAsync(String operation) {
+        if (mAsyncInProgress) throw new IllegalStateException("Can't start async operation (" +
+                operation + ") because another async operation(" + mAsyncOperation + ") is in progress.");
+        mAsyncOperation = operation;
+        mAsyncInProgress = true;
+        logDebug("Starting async operation: " + operation);
+    }
+
+    void flagEndAsync() {
+        logDebug("Ending async operation: " + mAsyncOperation);
+        mAsyncOperation = "";
+        mAsyncInProgress = false;
+    }
+
+
+    int queryPurchases(Inventory inv, String itemType) throws JSONException, RemoteException {
+        // Query purchases
+        logDebug("Querying owned items, item type: " + itemType);
+        logDebug("Package name: " + mContext.getPackageName());
+        boolean verificationFailed = false;
+        String continueToken = null;
+
+        do {
+            logDebug("Calling getPurchases with continuation token: " + continueToken);
+            Bundle ownedItems = mService.getPurchases(3, mContext.getPackageName(),
+                    itemType, continueToken);
+
+            int response = getResponseCodeFromBundle(ownedItems);
+            logDebug("Owned items response: " + String.valueOf(response));
+            if (response != BILLING_RESPONSE_RESULT_OK) {
+                logDebug("getPurchases() failed: " + getResponseDesc(response));
+                return response;
+            }
+            if (!ownedItems.containsKey(RESPONSE_INAPP_ITEM_LIST)
+                    || !ownedItems.containsKey(RESPONSE_INAPP_PURCHASE_DATA_LIST)
+                    || !ownedItems.containsKey(RESPONSE_INAPP_SIGNATURE_LIST)) {
+                logError("Bundle returned from getPurchases() doesn't contain required fields.");
+                return IABHELPER_BAD_RESPONSE;
+            }
+
+            ArrayList<String> ownedSkus = ownedItems.getStringArrayList(
+                        RESPONSE_INAPP_ITEM_LIST);
+            ArrayList<String> purchaseDataList = ownedItems.getStringArrayList(
+                        RESPONSE_INAPP_PURCHASE_DATA_LIST);
+            ArrayList<String> signatureList = ownedItems.getStringArrayList(
+                        RESPONSE_INAPP_SIGNATURE_LIST);
+
+            for (int i = 0; i < purchaseDataList.size(); ++i) {
+                String purchaseData = purchaseDataList.get(i);
+                String signature = signatureList.get(i);
+                String sku = ownedSkus.get(i);
+                if (Security.verifyPurchase(mSignatureBase64, purchaseData, signature)) {
+                    logDebug("Sku is owned: " + sku);
+                    Purchase purchase = new Purchase(itemType, purchaseData, signature);
+
+                    if (TextUtils.isEmpty(purchase.getToken())) {
+                        logWarn("BUG: empty/null token!");
+                        logDebug("Purchase data: " + purchaseData);
+                    }
+
+                    // Record ownership and token
+                    inv.addPurchase(purchase);
+                }
+                else {
+                    logWarn("Purchase signature verification **FAILED**. Not adding item.");
+                    logDebug("   Purchase data: " + purchaseData);
+                    logDebug("   Signature: " + signature);
+                    verificationFailed = true;
+                }
+            }
+
+            continueToken = ownedItems.getString(INAPP_CONTINUATION_TOKEN);
+            logDebug("Continuation token: " + continueToken);
+        } while (!TextUtils.isEmpty(continueToken));
+
+        return verificationFailed ? IABHELPER_VERIFICATION_FAILED : BILLING_RESPONSE_RESULT_OK;
+    }
+
+    int querySkuDetails(String itemType, Inventory inv, List<String> moreSkus)
+                                throws RemoteException, JSONException {
+        logDebug("Querying SKU details.");
+        ArrayList<String> skuList = new ArrayList<String>();
+        skuList.addAll(inv.getAllOwnedSkus(itemType));
+        if (moreSkus != null) {
+            for (String sku : moreSkus) {
+                if (!skuList.contains(sku)) {
+                    skuList.add(sku);
+                }
+            }
+        }
+
+        if (skuList.size() == 0) {
+            logDebug("queryPrices: nothing to do because there are no SKUs.");
+            return BILLING_RESPONSE_RESULT_OK;
+        }
+
+        Bundle querySkus = new Bundle();
+        querySkus.putStringArrayList(GET_SKU_DETAILS_ITEM_LIST, skuList);
+        Bundle skuDetails = mService.getSkuDetails(3, mContext.getPackageName(),
+                itemType, querySkus);
+
+        if (!skuDetails.containsKey(RESPONSE_GET_SKU_DETAILS_LIST)) {
+            int response = getResponseCodeFromBundle(skuDetails);
+            if (response != BILLING_RESPONSE_RESULT_OK) {
+                logDebug("getSkuDetails() failed: " + getResponseDesc(response));
+                return response;
+            }
+            else {
+                logError("getSkuDetails() returned a bundle with neither an error nor a detail list.");
+                return IABHELPER_BAD_RESPONSE;
+            }
+        }
+
+        ArrayList<String> responseList = skuDetails.getStringArrayList(
+                RESPONSE_GET_SKU_DETAILS_LIST);
+
+        for (String thisResponse : responseList) {
+            SkuDetails d = new SkuDetails(itemType, thisResponse);
+            logDebug("Got sku details: " + d);
+            inv.addSkuDetails(d);
+        }
+        return BILLING_RESPONSE_RESULT_OK;
+    }
+
+
+    void consumeAsyncInternal(final List<Purchase> purchases,
+                              final OnConsumeFinishedListener singleListener,
+                              final OnConsumeMultiFinishedListener multiListener) {
+        final Handler handler = new Handler();
+        flagStartAsync("consume");
+        (new Thread(new Runnable() {
+            public void run() {
+                final List<IabResult> results = new ArrayList<IabResult>();
+                for (Purchase purchase : purchases) {
+                    try {
+                        consume(purchase);
+                        results.add(new IabResult(BILLING_RESPONSE_RESULT_OK, "Successful consume of sku " + purchase.getSku()));
+                    }
+                    catch (IabException ex) {
+                        results.add(ex.getResult());
+                    }
+                }
+
+                flagEndAsync();
+                if (!mDisposed && singleListener != null) {
+                    handler.post(new Runnable() {
+                        public void run() {
+                            singleListener.onConsumeFinished(purchases.get(0), results.get(0));
+                        }
+                    });
+                }
+                if (!mDisposed && multiListener != null) {
+                    handler.post(new Runnable() {
+                        public void run() {
+                            multiListener.onConsumeMultiFinished(purchases, results);
+                        }
+                    });
+                }
+            }
+        })).start();
+    }
+
+    void logDebug(String msg) {
+        if (mDebugLog) Log.d(mDebugTag, msg);
+    }
+
+    void logError(String msg) {
+        Log.e(mDebugTag, "In-app billing error: " + msg);
+    }
+
+    void logWarn(String msg) {
+        Log.w(mDebugTag, "In-app billing warning: " + msg);
+    }
+}
Index: CSipSimple/src/ro/callromania/util/IabResult.java
===================================================================
--- CSipSimple/src/ro/callromania/util/IabResult.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/IabResult.java	(working copy)
@@ -0,0 +1,45 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+/**
+ * Represents the result of an in-app billing operation.
+ * A result is composed of a response code (an integer) and possibly a
+ * message (String). You can get those by calling
+ * {@link #getResponse} and {@link #getMessage()}, respectively. You
+ * can also inquire whether a result is a success or a failure by
+ * calling {@link #isSuccess()} and {@link #isFailure()}.
+ */
+public class IabResult {
+    int mResponse;
+    String mMessage;
+
+    public IabResult(int response, String message) {
+        mResponse = response;
+        if (message == null || message.trim().length() == 0) {
+            mMessage = IabHelper.getResponseDesc(response);
+        }
+        else {
+            mMessage = message + " (response: " + IabHelper.getResponseDesc(response) + ")";
+        }
+    }
+    public int getResponse() { return mResponse; }
+    public String getMessage() { return mMessage; }
+    public boolean isSuccess() { return ((mResponse == IabHelper.BILLING_RESPONSE_RESULT_OK) || (mResponse == IabHelper.BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED)); }
+    public boolean isFailure() { return !isSuccess(); }
+    public String toString() { return "IabResult: " + getMessage(); }
+}
+
Index: CSipSimple/src/ro/callromania/util/Inventory.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Inventory.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Inventory.java	(working copy)
@@ -0,0 +1,91 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Represents a block of information about in-app items.
+ * An Inventory is returned by such methods as {@link IabHelper#queryInventory}.
+ */
+public class Inventory {
+    Map<String,SkuDetails> mSkuMap = new HashMap<String,SkuDetails>();
+    Map<String,Purchase> mPurchaseMap = new HashMap<String,Purchase>();
+
+    Inventory() { }
+
+    /** Returns the listing details for an in-app product. */
+    public SkuDetails getSkuDetails(String sku) {
+        return mSkuMap.get(sku);
+    }
+
+    /** Returns purchase information for a given product, or null if there is no purchase. */
+    public Purchase getPurchase(String sku) {
+        return mPurchaseMap.get(sku);
+    }
+
+    /** Returns whether or not there exists a purchase of the given product. */
+    public boolean hasPurchase(String sku) {
+        return mPurchaseMap.containsKey(sku);
+    }
+
+    /** Return whether or not details about the given product are available. */
+    public boolean hasDetails(String sku) {
+        return mSkuMap.containsKey(sku);
+    }
+
+    /**
+     * Erase a purchase (locally) from the inventory, given its product ID. This just
+     * modifies the Inventory object locally and has no effect on the server! This is
+     * useful when you have an existing Inventory object which you know to be up to date,
+     * and you have just consumed an item successfully, which means that erasing its
+     * purchase data from the Inventory you already have is quicker than querying for
+     * a new Inventory.
+     */
+    public void erasePurchase(String sku) {
+        if (mPurchaseMap.containsKey(sku)) mPurchaseMap.remove(sku);
+    }
+
+    /** Returns a list of all owned product IDs. */
+    List<String> getAllOwnedSkus() {
+        return new ArrayList<String>(mPurchaseMap.keySet());
+    }
+
+    /** Returns a list of all owned product IDs of a given type */
+    List<String> getAllOwnedSkus(String itemType) {
+        List<String> result = new ArrayList<String>();
+        for (Purchase p : mPurchaseMap.values()) {
+            if (p.getItemType().equals(itemType)) result.add(p.getSku());
+        }
+        return result;
+    }
+
+    /** Returns a list of all purchases. */
+    List<Purchase> getAllPurchases() {
+        return new ArrayList<Purchase>(mPurchaseMap.values());
+    }
+
+    void addSkuDetails(SkuDetails d) {
+        mSkuMap.put(d.getSku(), d);
+    }
+
+    void addPurchase(Purchase p) {
+        mPurchaseMap.put(p.getSku(), p);
+    }
+}
Index: CSipSimple/src/ro/callromania/util/Purchase.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Purchase.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Purchase.java	(working copy)
@@ -0,0 +1,63 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Represents an in-app billing purchase.
+ */
+public class Purchase {
+    String mItemType;  // ITEM_TYPE_INAPP or ITEM_TYPE_SUBS
+    String mOrderId;
+    String mPackageName;
+    String mSku;
+    long mPurchaseTime;
+    int mPurchaseState;
+    String mDeveloperPayload;
+    String mToken;
+    String mOriginalJson;
+    String mSignature;
+
+    public Purchase(String itemType, String jsonPurchaseInfo, String signature) throws JSONException {
+        mItemType = itemType;
+        mOriginalJson = jsonPurchaseInfo;
+        JSONObject o = new JSONObject(mOriginalJson);
+        mOrderId = o.optString("orderId");
+        mPackageName = o.optString("packageName");
+        mSku = o.optString("productId");
+        mPurchaseTime = o.optLong("purchaseTime");
+        mPurchaseState = o.optInt("purchaseState");
+        mDeveloperPayload = o.optString("developerPayload");
+        mToken = o.optString("token", o.optString("purchaseToken"));
+        mSignature = signature;
+    }
+
+    public String getItemType() { return mItemType; }
+    public String getOrderId() { return mOrderId; }
+    public String getPackageName() { return mPackageName; }
+    public String getSku() { return mSku; }
+    public long getPurchaseTime() { return mPurchaseTime; }
+    public int getPurchaseState() { return mPurchaseState; }
+    public String getDeveloperPayload() { return mDeveloperPayload; }
+    public String getToken() { return mToken; }
+    public String getOriginalJson() { return mOriginalJson; }
+    public String getSignature() { return mSignature; }
+
+    @Override
+    public String toString() { return "PurchaseInfo(type:" + mItemType + "):" + mOriginalJson; }
+}
Index: CSipSimple/src/ro/callromania/util/Security.java
===================================================================
--- CSipSimple/src/ro/callromania/util/Security.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/Security.java	(working copy)
@@ -0,0 +1,123 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import android.text.TextUtils;
+import android.util.Log;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+
+import java.security.InvalidKeyException;
+import java.security.KeyFactory;
+import java.security.NoSuchAlgorithmException;
+import java.security.PublicKey;
+import java.security.Signature;
+import java.security.SignatureException;
+import java.security.spec.InvalidKeySpecException;
+import java.security.spec.X509EncodedKeySpec;
+
+/**
+ * Security-related methods. For a secure implementation, all of this code
+ * should be implemented on a server that communicates with the
+ * application on the device. For the sake of simplicity and clarity of this
+ * example, this code is included here and is executed on the device. If you
+ * must verify the purchases on the phone, you should obfuscate this code to
+ * make it harder for an attacker to replace the code with stubs that treat all
+ * purchases as verified.
+ */
+public class Security {
+    private static final String TAG = "IABUtil/Security";
+
+    private static final String KEY_FACTORY_ALGORITHM = "RSA";
+    private static final String SIGNATURE_ALGORITHM = "SHA1withRSA";
+
+    /**
+     * Verifies that the data was signed with the given signature, and returns
+     * the verified purchase. The data is in JSON format and signed
+     * with a private key. The data also contains the {@link PurchaseState}
+     * and product ID of the purchase.
+     * @param base64PublicKey the base64-encoded public key to use for verifying.
+     * @param signedData the signed JSON string (signed, not encrypted)
+     * @param signature the signature for the data, signed with the private key
+     */
+    public static boolean verifyPurchase(String base64PublicKey, String signedData, String signature) {
+        if (TextUtils.isEmpty(signedData) || TextUtils.isEmpty(base64PublicKey) ||
+                TextUtils.isEmpty(signature)) {
+            Log.e(TAG, "Purchase verification failed: missing data.");
+            return false;
+        }
+
+        PublicKey key = Security.generatePublicKey(base64PublicKey);
+        return Security.verify(key, signedData, signature);
+    }
+
+    /**
+     * Generates a PublicKey instance from a string containing the
+     * Base64-encoded public key.
+     *
+     * @param encodedPublicKey Base64-encoded public key
+     * @throws IllegalArgumentException if encodedPublicKey is invalid
+     */
+    public static PublicKey generatePublicKey(String encodedPublicKey) {
+        try {
+            byte[] decodedKey = Base64.decode(encodedPublicKey);
+            KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);
+            return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey));
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+        } catch (InvalidKeySpecException e) {
+            Log.e(TAG, "Invalid key specification.");
+            throw new IllegalArgumentException(e);
+        } catch (Base64DecoderException e) {
+            Log.e(TAG, "Base64 decoding failed.");
+            throw new IllegalArgumentException(e);
+        }
+    }
+
+    /**
+     * Verifies that the signature from the server matches the computed
+     * signature on the data.  Returns true if the data is correctly signed.
+     *
+     * @param publicKey public key associated with the developer account
+     * @param signedData signed data from server
+     * @param signature server signature
+     * @return true if the data and signature match
+     */
+    public static boolean verify(PublicKey publicKey, String signedData, String signature) {
+        Signature sig;
+        try {
+            sig = Signature.getInstance(SIGNATURE_ALGORITHM);
+            sig.initVerify(publicKey);
+            sig.update(signedData.getBytes());
+            if (!sig.verify(Base64.decode(signature))) {
+                Log.e(TAG, "Signature verification failed.");
+                return false;
+            }
+            return true;
+        } catch (NoSuchAlgorithmException e) {
+            Log.e(TAG, "NoSuchAlgorithmException.");
+        } catch (InvalidKeyException e) {
+            Log.e(TAG, "Invalid key specification.");
+        } catch (SignatureException e) {
+            Log.e(TAG, "Signature exception.");
+        } catch (Base64DecoderException e) {
+            Log.e(TAG, "Base64 decoding failed.");
+        }
+        return false;
+    }
+}
Index: CSipSimple/src/ro/callromania/util/SkuDetails.java
===================================================================
--- CSipSimple/src/ro/callromania/util/SkuDetails.java	(revision 0)
+++ CSipSimple/src/ro/callromania/util/SkuDetails.java	(working copy)
@@ -0,0 +1,58 @@
+/* Copyright (c) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ro.callromania.util;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Represents an in-app product's listing details.
+ */
+public class SkuDetails {
+    String mItemType;
+    String mSku;
+    String mType;
+    String mPrice;
+    String mTitle;
+    String mDescription;
+    String mJson;
+
+    public SkuDetails(String jsonSkuDetails) throws JSONException {
+        this(IabHelper.ITEM_TYPE_INAPP, jsonSkuDetails);
+    }
+
+    public SkuDetails(String itemType, String jsonSkuDetails) throws JSONException {
+        mItemType = itemType;
+        mJson = jsonSkuDetails;
+        JSONObject o = new JSONObject(mJson);
+        mSku = o.optString("productId");
+        mType = o.optString("type");
+        mPrice = o.optString("price");
+        mTitle = o.optString("title");
+        mDescription = o.optString("description");
+    }
+
+    public String getSku() { return mSku; }
+    public String getType() { return mType; }
+    public String getPrice() { return mPrice; }
+    public String getTitle() { return mTitle; }
+    public String getDescription() { return mDescription; }
+
+    @Override
+    public String toString() {
+        return "SkuDetails:" + mJson;
+    }
+}
